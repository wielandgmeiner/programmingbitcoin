<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Jimmy Song">
<title>Programming Bitcoin</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book">
<div id="header">
<h1>Programming Bitcoin</h1>
<div class="details">
<span id="author" class="author">Jimmy Song</span><br>
<span id="revnumber">version 2.0,</span>
<span id="revdate">2018-12-03</span>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_preface">Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This book will teach you the technology of Bitcoin at a fundamental level.
It doesn&#8217;t cover the monetary, economic, or social dynamics of Bitcoin, but knowing how Bitcoin works under the hood should give you greater insight into what&#8217;s possible.
There&#8217;s a tendency to hype Bitcoin and blockchain without really understanding what&#8217;s going on; this book is meant to be an antidote to that tendency.</p>
</div>
<div class="paragraph">
<p>After all, there are lots of books about Bitcoin, covering the history and the economic aspects and giving technical descriptions.
The aim of this book is to get you to understand Bitcoin by coding all of the components necessary for a Bitcoin library.
The library is not meant to be exhaustive or efficient.
The aim of the library is to help you learn.</p>
</div>
<div class="sect2">
<h3 id="_who_is_this_book_for">Who Is This Book For?</h3>
<div class="paragraph">
<p>This book is for programmers who want to learn how Bitcoin works by coding it themselves.
You will learn Bitcoin by coding the "bare metal" stuff in a Bitcoin library you will create from scratch.
This is not a reference book where you can look up the specification for a particular feature.</p>
</div>
<div class="paragraph">
<p>The material from this book has been largely taken from my <a href="https://programmingblockchain.com">two-day seminar</a> where I teach developers all about Bitcoin.
The material has been refined extensively, as I&#8217;ve taught this course more than 20 times, to over 400 people as of this writing.</p>
</div>
<div class="paragraph">
<p>By the time you&#8217;re done with the book, you&#8217;ll not only be able to create transactions, but also get all the data you need from peers and send the transactions over the network.
It covers everything needed to accomplish this, including the math, parsing, network connectivity, and block validation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_do_i_need_to_know">What Do I Need to Know?</h3>
<div class="paragraph">
<p>A prerequisite for this book is that you know programming—Python, in particular.
The library itself is written in Python 3, and a lot of the exercises can be done in a controlled environment like a Jupyter notebook.
An intermediate knowledge of Python is preferable, but even a beginning knowledge is probably sufficient to get a lot of the concepts.</p>
</div>
<div class="paragraph">
<p>Some knowledge of math is required, especially for Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_finite_fields">#chapter_finite_fields</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_elliptic_curves">#chapter_elliptic_curves</a>.
These chapters introduce mathematical concepts probably not familiar to those who didn&#8217;t major in mathematics.
Math knowledge around algebra level should suffice to understand the new concepts and to code the exercises covered in those chapters.</p>
</div>
<div class="paragraph">
<p>General computer science knowledge, for example, of hash functions, will come in handy but is not strictly necessary to complete the exercises in this book.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_is_the_book_arranged">How Is the Book Arranged?</h3>
<div class="paragraph">
<p>This book is split into 14 chapters. Each is meant to build on the previous one as the Bitcoin library gets built from scratch all the way to the end.</p>
</div>
<div class="paragraph">
<p>Roughly speaking, Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_finite_fields">#chapter_finite_fields</a>–<a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_serialization">#chapter_serialization</a> establish the mathematical tools that we need; Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_tx_parsing">#chapter_tx_parsing</a>–<a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_p2sh">#chapter_p2sh</a> cover transactions, which are the fundamental unit of Bitcoin; and Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_blocks">#chapter_blocks</a>–<a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_bloom_filters">#chapter_bloom_filters</a> cover blocks and networking.
The last two chapters cover some advanced topics but don&#8217;t actually require you to write code.</p>
</div>
<div class="paragraph">
<p>Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_finite_fields">#chapter_finite_fields</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_elliptic_curves">#chapter_elliptic_curves</a> cover some math that we need.
Finite fields and elliptic curves are needed to understand elliptic curve cryptography in <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>.
After we&#8217;ve established the public key cryptography at the end of <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>, <a href="#chapter_serialization">Serialization</a> adds parsing and serialization, which are how cryptographic primitives are stored and transmitted.</p>
</div>
<div class="paragraph">
<p><a href="#chapter_tx_parsing">Transactions</a> covers the transaction structure.
<a href="#chapter_script">Script</a> goes into the smart contract language behind Bitcoin, called Script.
<a href="#chapter_tx">Transaction Creation and Validation</a> builds on all the previous chapters, showing how to validate and create transactions based on the elliptic curve cryptography from the first four chapters.
<a href="#chapter_p2sh">Pay-to-Script Hash</a> establishes how pay-to-script-hash (p2sh) works, which is a way to make more powerful smart contracts.</p>
</div>
<div class="paragraph">
<p><a href="#chapter_blocks">Blocks</a> covers blocks, which are groups of ordered transactions.
<a href="#chapter_networking">Networking</a> covers network communication in Bitcoin. Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_spv">#chapter_spv</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#chapter_bloom_filters">#chapter_bloom_filters</a> go into how a light client, or software without access to the entire blockchain, might request and broadcast data to and from nodes that store the entire blockchain.</p>
</div>
<div class="paragraph">
<p><a href="#chapter_segwit">Segwit</a> covers Segwit, a backward-compatible upgrade introduced in 2017, and <a href="#chapter_advanced">Advanced Topics and Next Steps</a> provides suggestions for further study.
These chapters are not strictly necessary, but are included as a way to give you a taste of what more there is to learn.</p>
</div>
<div class="paragraph">
<p>Chapters 1–12 have exercises that require you to build up the library from scratch.
The answers are in <a href="#appendix_solutions">Solutions</a> and in the corresponding chapter directory in the <a href="https://github.com/jimmysong/programmingbitcoin">GitHub repo</a>.
You will be writing many Python classes and building toward not just validating transactions/blocks, but also creating your own transactions and broadcasting them on the network.</p>
</div>
<div class="paragraph">
<p>The last exercise in <a href="#chapter_bloom_filters">Bloom Filters</a> specifically asks you to connect to another node on the testnet network, calculate what you can spend, construct and sign a transaction of your devising, and broadcast that on the network.
The first 11 chapters essentially prepare you for this exercise.</p>
</div>
<div class="paragraph">
<p>There will be a lot of unit tests that your code will need to pass.
The book has been designed this way so you can do the "fun" part of coding.
To aid your progress, we will be looking at a lot of code and diagrams throughout.</p>
</div>
</div>
<div class="sect2">
<h3 id="setting_up">Setting Up</h3>
<div class="paragraph">
<p>To get the most out of this book, you&#8217;ll want to create an environment where you can run the example code and do the exercises.
Here are the steps required to set everything up:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Install Python 3.5 or higher on your machine:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Windows</dt>
<dd>
<p><a href="https://www.python.org/ftp/python/3.6.2/python-3.6.2-amd64.exe" class="bare">https://www.python.org/ftp/python/3.6.2/python-3.6.2-amd64.exe</a></p>
</dd>
<dt class="hdlist1">macOS</dt>
<dd>
<p><a href="https://www.python.org/ftp/python/3.6.2/python-3.6.2-macosx10.6.pkg" class="bare">https://www.python.org/ftp/python/3.6.2/python-3.6.2-macosx10.6.pkg</a></p>
</dd>
<dt class="hdlist1">Linux</dt>
<dd>
<p>See your distro docs (many Linux distributions, like Ubuntu, come with Python 3.5+ preinstalled)</p>
</dd>
</dl>
</div>
</li>
<li>
<p>Install pip by downloading this script: <a href="https://bootstrap.pypa.io/get-pip.py" class="bare">https://bootstrap.pypa.io/get-pip.py</a>.</p>
</li>
<li>
<p>Run this script using Python 3:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ python3 get-pip.py</code></pre>
</div>
</div>
</li>
<li>
<p>Install Git. The commands for downloading and installing it are at <a href="https://git-scm.com/downloads" class="bare">https://git-scm.com/downloads</a>.</p>
</li>
<li>
<p>Download the source code for this book:</p>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/jimmysong/programmingbitcoin
$ cd programmingbitcoin</pre>
</div>
</div>
</li>
<li>
<p>Install virtualenv:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ pip install virtualenv --user</code></pre>
</div>
</div>
</li>
<li>
<p>Install the requirements:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Linux/macOS</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ virtualenv -p python3 .venv
$ . .venv/bin/activate
(.venv) $ pip install -r requirements.txt</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Windows</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre>C:\programmingbitcoin&gt; virtualenv -p
    C:\PathToYourPythonInstallation\Python.exe .venv
C:\programmingbitcoin&gt; .venv\Scripts\activate.bat
C:\programmingbitcoin&gt; pip install -r requirements.txt</pre>
</div>
</div>
</dd>
</dl>
</div>
</li>
<li>
<p>Run Jupyter Notebook:</p>
<div class="listingblock">
<div class="content">
<pre>(.venv) $ jupyter notebook
[I 11:13:23.061 NotebookApp] Serving notebooks from local directory:
  /home/jimmy/programmingbitcoin
[I 11:13:23.061 NotebookApp] The Jupyter Notebook is running at:
[I 11:13:23.061 NotebookApp] http://localhost:8888/?token=
  f849627e4d9d07d2158e3fcde93590eff4a9a7a01f65a8e7
[I 11:13:23.061 NotebookApp] Use Control-C to stop this server and
  shut down all kernels (twice to skip confirmation).
[C 11:13:23.065 NotebookApp]

    Copy/paste this URL into your browser when you connect for
    the first time, to login with a token:
        http://localhost:8888/?token=
        f849627e4d9d07d2158e3fcde93590eff4a9a7a01f65a8e7</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>You should have a browser open up automatically, as shown in <a href="#pr0001">Jupyter</a>.</p>
</div>
<div id="pr0001" class="imageblock">
<div class="content">
<img src="./images/prbc_0001.png" alt="Jupyter">
</div>
<div class="title">Figure 1. Jupyter</div>
</div>
<div class="paragraph">
<p>From here, you can navigate to the chapter directories. To do the exercises from <a href="#chapter_finite_fields">Finite Fields</a>, you would navigate to <em>code-ch01</em> (<a href="#pr0002">Jupyter directory view</a>).</p>
</div>
<div id="pr0002" class="imageblock">
<div class="content">
<img src="./images/prbc_0002.png" alt="Chapter 1 Directory">
</div>
<div class="title">Figure 2. Jupyter directory view</div>
</div>
<div class="paragraph">
<p>From here you can open <em>Chapter1.ipynb</em> (<a href="#pr0003">Jupyter notebook</a>).</p>
</div>
<div id="pr0003" class="imageblock">
<div class="content">
<img src="./images/prbc_0003.png" alt="Chapter 1 Notebook">
</div>
<div class="title">Figure 3. Jupyter notebook</div>
</div>
<div class="paragraph">
<p>You may want to familiarize yourself with this interface if you haven&#8217;t seen it before, but the gist of Jupyter is that it can run Python code from the browser in a way that makes experimenting easy.
You can run each "cell" and see the results as if this were an interactive Python shell.</p>
</div>
<div class="paragraph">
<p>A large portion of the exercises will be coding concepts introduced in the book.
The unit tests are written for you, but you will need to write the Python code to make the tests pass.
You can check whether your code is correct directly in Jupyter.
You will need to edit the corresponding file by clicking through a link like the "this test" link in <a href="#pr0003">Jupyter notebook</a>.
This will take you to a browser tab like the one shown in <a href="#pr0004">ecc.py</a>.</p>
</div>
<div id="pr0004" class="imageblock">
<div class="content">
<img src="./images/prbc_0004.png" alt="Chapter 1 ecc.py">
</div>
<div class="title">Figure 4. ecc.py</div>
</div>
<div class="paragraph">
<p>To make the test pass, edit the file here and save.</p>
</div>
</div>
<div class="sect2">
<h3 id="_answers">Answers</h3>
<div class="paragraph">
<p>All the answers to the various exercises in this book are in <a href="#appendix_solutions">Solutions</a>.
They are also available in the <em>code-ch&lt;xx&gt;/answers.py</em> files, where <em>&lt;xx&gt;</em> is the chapter that you&#8217;re on.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conventions_used_in_this_book">Conventions Used in This Book</h3>
<div class="paragraph">
<p>The following typographical conventions are used in this book:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Italic</em></dt>
<dd>
<p>Indicates new terms, URLs, email addresses, filenames, and file extensions.</p>
</dd>
<dt class="hdlist1">Constant width</dt>
<dd>
<p>Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</p>
</dd>
<dt class="hdlist1"><strong><code>Constant width bold</code></strong></dt>
<dd>
<p>Shows commands or other text that should be typed literally by the user.</p>
</dd>
<dt class="hdlist1"><em>Constant width italic</em></dt>
<dd>
<p>Shows text that should be replaced with user-supplied values or by values determined by context.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>This element signifies a tip or suggestion.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This element signifies a general note.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>This element indicates a warning or caution.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_using_code_examples">Using Code Examples</h3>
<div class="paragraph">
<p>Supplemental material (code examples, exercises, etc.) is available for download at <a href="https://github.com/jimmysong/programmingbitcoin" class="bare">https://github.com/jimmysong/programmingbitcoin</a>.</p>
</div>
<div class="paragraph">
<p>This book is here to help you get your job done.
In general, if example code is offered with this book, you may use it in your programs and documentation.
You do not need to contact us for permission unless you’re reproducing a significant portion of the code.
For example, writing a program that uses several chunks of code from this book does not require permission.
Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.
Answering a question by citing this book and quoting example code does not require permission.
Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</p>
</div>
<div class="paragraph">
<p>We appreciate, but do not require, attribution.
An attribution usually includes the title, author, publisher, and ISBN.
For example: “<em>Programming Bitcoin</em> by Jimmy Song (O’Reilly).
Copyright 2019 Jimmy Song, 978-1-492-03149-9.”</p>
</div>
<div class="paragraph">
<p>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <a class="email" href="mailto:permissions@oreilly.com"><em>permissions@oreilly.com</em></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_oreilly_online_learning">O&#8217;Reilly Online Learning</h3>
<div class="admonitionblock note ormenabled">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>For almost 40 years, <a href="http://oreilly.com" class="orm:hideurl"><em class="hyperlink">O’Reilly Media</em></a> has provided technology and business training, knowledge, and insight to help companies succeed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Our unique network of experts and innovators share their knowledge and expertise through books, articles, conferences, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O&#8217;Reilly and 200+ other publishers. For more information, please visit <a href="http://oreilly.com" class="orm:hideurl"><em>http://oreilly.com</em></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_contact_us">How to Contact Us</h3>
<div class="paragraph">
<p>Please address comments and questions concerning this book to the publisher:</p>
</div>
<ul class="simplelist">
  <li>O’Reilly Media, Inc.</li>
  <li>1005 Gravenstein Highway North</li>
  <li>Sebastopol, CA 95472</li>
  <li>800-998-9938 (in the United States or Canada)</li>
  <li>707-829-0515 (intenational or local)</li>
  <li>707-829-0104 (fax)</li>
</ul>
<div class="paragraph">
<p>We have a web page for this book, where we list errata, examples, and any additional information.
You can access this page at <a href="http://bit.ly/programmingBitcoin" class="bare">http://bit.ly/programmingBitcoin</a>.</p>
</div>
<div class="paragraph">
<p>To comment or ask technical questions about this book, send email to <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>.</p>
</div>
<div class="paragraph">
<p>For more information about our books, courses, conferences, and news, see our website at <a href="http://www.oreilly.com" class="bare">http://www.oreilly.com</a>.</p>
</div>
<div class="paragraph">
<p>Find us on Facebook: <a href="http://facebook.com/oreilly" class="bare">http://facebook.com/oreilly</a></p>
</div>
<div class="paragraph">
<p>Follow us on Twitter: <a href="http://twitter.com/oreillymedia" class="bare">http://twitter.com/oreillymedia</a></p>
</div>
<div class="paragraph">
<p>Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia" class="bare">http://www.youtube.com/oreillymedia</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_acknowledgments">Acknowledgments</h3>
<div class="paragraph">
<p>The number of people that got me here is legion. The experiences and knowledge that an author draws from tend to have a lot of sources, and it&#8217;s difficult to give them all their proper credit. This is my way of saying that I&#8217;m probably going to forget a significant number of people, and for that I sincerely apologize.</p>
</div>
<div class="paragraph">
<p>First, I want to thank my Lord Jesus Christ for putting me on this journey. If not for my faith, I would not have had the ethical conviction to blog about the importance of sound money in general and Bitcoin in particular, which ultimately led to the writing of this book.</p>
</div>
<div class="paragraph">
<p>My parents, Kathy and Kyung-Sup, had the courage to immigrate to America back when I was eight years old, which ultimately led to the opportunities I&#8217;ve had. My dad got me my first computers (a Commodore 16, a generic Hyundai 8086, and a 486 33-Mhz from a manufacturer I don&#8217;t remember), and my mom got me private programming tutoring as a sixth- and seventh-grader from a woman whose name I can&#8217;t remember. How she found her when I showed some proclivity for programming, I don&#8217;t know. That teacher-whose-name-I-can&#8217;t-remember stoked that natural tendency, and I hope this acknowledgment finds its way to her.</p>
</div>
<div class="paragraph">
<p>Speaking of which, I&#8217;ve had many teachers along the way, some of whom I hated at the time. Mr. Marain, Mrs. Edelman, and Mrs. Nelson taught me math and computer science back in high school. I&#8217;m not necessarily a fan of the current education system, but what I learned in those classes was instrumental to my love of math and programming.</p>
</div>
<div class="paragraph">
<p>My high school classmate Eric Silberstein gave me my first job out of college as a programmer at Idiom Technologies. I was slated to go down the consulting path before a fateful phone call back in 1998 that led me down the programmer/startup path instead. In a sense, I&#8217;ve never left.</p>
</div>
<div class="paragraph">
<p>At that first job, I met Ken Liu, and I&#8217;m amazed that we&#8217;re where we are in our careers writing books. He not only gave me great advice about book publishing, but also wrote the wonderful foreword. He&#8217;s also a great sounding board and an amazing friend, and I&#8217;m privileged to know him.</p>
</div>
<div class="paragraph">
<p>With regard to Bitcoin, the anonymous developer Satoshi Nakamoto invented what I thought before was impossible: decentralized digital scarcity. Bitcoin is a profound invention that the world hasn&#8217;t fully grokked. The website <a href="http://slashdot.org">Slashdot</a> introduced me to Bitcoin in 2011, and Alex Mizrahi gave me my first work as a Bitcoin developer in 2013. I had no idea what I was doing, but I learned quite a bit about what Bitcoin was about through his direction.</p>
</div>
<div class="paragraph">
<p>The Austin Bitcoin Meetup in 2013 was where I met a lot of Bitcoiners, and at the subsequent Texas Bitcoin Conference in 2014 I met a ton of people that I still know today. Though this meetup and conference are not ones I attend anymore, I am grateful for the people I met there—among them Michael Goldstein, Daniel Krawisz, and Napoleon Cole.</p>
</div>
<div class="paragraph">
<p>Alan Reiner recruited me to Armory back in 2014, and I&#8217;m grateful I had the opportunity to contribute to such a significant project.</p>
</div>
<div class="paragraph">
<p>Paxos/itBit was where I worked next. Chad Cascarilla and Raj Nair were the CEO and VP of Engineering who stretched me while I was there. Raj, in particular, made me write some blog posts for Paxos, which I was surprised to find I enjoyed. This led to blog posts on my own site, which eventually led to my seminars, which finally led to this book.</p>
</div>
<div class="paragraph">
<p>Three colleagues I met at Paxos were particularly significant. Richard Kiss, creator of pycoin, was the impetus for my writing this book, as he proposed that we write one together. Somewhere along the way, that turned into just me writing a book, but I&#8217;m grateful to him for giving me the idea. Aaron Caswell is a great dev who has helped me out in my seminars and reviewed this book. He&#8217;s a great programmer and mathematician, and a pretty good karate fighter from what I hear. Michael Flaxman has reviewed almost everything Bitcoin-related I&#8217;ve written, including my blog, many of my GitHub libraries, and this book. He&#8217;s also helped me out on my seminars and is just a great person to talk to. He&#8217;s one of those people who make others sharper, and I&#8217;m grateful for his significant friendship.</p>
</div>
<div class="paragraph">
<p>Vortex, Thomas Hunt, and Tone Vays brought me into the World Crypto Network back in 2017, which launched my YouTube career. Tone in particular has been an inspiration on working hard and being dedicated to a craft.</p>
</div>
<div class="paragraph">
<p>John Newbery was very helpful to me when I first contributed to Bitcoin Core, and he&#8217;s just a really good person, period. He&#8217;s become such a significant contributor in a relatively short time, which speaks to his talent and dedication. I&#8217;m grateful to other Core developers too, like Marco Falke, Wladimir van der Laan, Alex Morcos, Pieter Wuille, Matt Corallo, Suhas Daftuar, and Greg Maxwell, who have reviewed some of my code and blog posts.</p>
</div>
<div class="paragraph">
<p>David Harding was exceptional in his technical review of this book. He reviewed the text three times, with a lot of great comments. He&#8217;d better write a book about Bitcoin at some point, because he has an encyclopedic knowledge of nearly everything that&#8217;s happend in Bitcoin&#8217;s history.</p>
</div>
<div class="paragraph">
<p>Jim Calvin helped me get in contact with people at O&#8217;Reilly, and Mike Loukides was the intake editor who green-lighted the project. Andreas Antonopolous gave me some great pointers and recommended me to people at O&#8217;Reilly. Michele Cronin kept me on track during my year-long writing spree. Kristen Brown was the production editor who did a lot to get this book out on time. James Fraleigh did copyediting. I&#8217;m a big fan of this publisher, and Tim O&#8217;Reilly has done a great service to the tech community by making such great books available.</p>
</div>
<div class="paragraph">
<p>The crew of Bitcoiners in Austin have helped keep me on track. They include Bryan Bishop, Will Cole, Napoleon Cole, Tipton Cole, Tuur Demeester, Johnny Dilley, Michael Flaxman, Parker Lewis, Justin Moon, Alan Piscitello, and Andrew Poelstra. There&#8217;s also a Slack channel (TAAS) where Saifedean Ammous announced that he was writing a book whose success inspired me.</p>
</div>
<div class="paragraph">
<p>Alumni of my course, Programming Blockchain, in addition to Bitcoiners on GitHub also did tech reviews of my book. Jeff Flowers, Brian Liotti, Casey Bowman, Johnson Lau, Albert Chen, Jason Les, Thomas Braunberger, Eduardo Cobain, and Spencer Hanson are among the people who found issues. Katrina Javier is my faithful assistant that helped me make a lot of the diagrams.</p>
</div>
<div class="paragraph">
<p>My subscribers on YouTube, my followers on Twitter, and my readers on Medium have been instrumental in helping me find my voice and setting me on my path as an entrepreneur.</p>
</div>
<div class="paragraph">
<p>Lastly, my wife, Julie, and my kids supported me throughout the past couple of years. If not for them, I doubt I&#8217;d have had the motivation to work as I have.</p>
</div>
</div>
</div>
</div>
<div class="sect1 pagenumrestart">
<h2 id="chapter_finite_fields">Finite Fields</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>One of the most difficult things about learning how to program Bitcoin is knowing where to start.
There are so many components that depend on each other that learning one thing may lead you to have to learn another, which in turn may lead you to need to learn something else before you can understand the original thing.</p>
</div>
<div class="paragraph">
<p>This chapter is going to get you off to a more manageable start.
It may seem strange, but we&#8217;ll start with the basic math that you need to understand elliptic curve cryptography.
Elliptic curve cryptography, in turn, gives us the signing and verification algorithms.
These are at the heart of how transactions work, and transactions are the atomic unit of value transfer in Bitcoin.
By learning about finite fields and elliptic curves first, you&#8217;ll get a firm grasp of concepts that you&#8217;ll need to progress logically.</p>
</div>
<div class="paragraph">
<p>Be aware that this chapter and the next two chapters may feel a bit like you&#8217;re eating vegetables, especially if you haven&#8217;t done formal math in a long time.
I would encourage you to get through them, though, as the concepts and code presented here will be used throughout the book.</p>
</div>
<div class="sect2">
<h3 id="_learning_higher_level_math">Learning Higher-Level Math</h3>
<div class="paragraph">
<p>Learning about new mathematical structures can be a bit intimidating, and in this chapter, I hope to dispel the myth that high-level math is difficult.
Finite fields, in particular, don&#8217;t require all that much more in terms of prior mathematical knowledge than, say, algebra.</p>
</div>
<div class="paragraph">
<p>Think of finite fields as something that you could have learned instead of trigonometry, except that the education system you&#8217;re a part of decided that trigonometry was more important for you to learn.
This is my way of telling you that finite fields are not that hard to learn and require no more background than algebra.</p>
</div>
<div class="paragraph">
<p>This chapter is required if you want to understand elliptic curve cryptography.
Elliptic curve cryptography is required for understanding signing and verification, which is at the heart of Bitcoin itself.
As I&#8217;ve said, this chapter and the next two may feel a bit unrelated, but I encourage you to endure.
The fundamentals here will not only make understanding Bitcoin a lot easier, but also make understanding Schnorr signatures, confidential transactions, and other leading-edge Bitcoin technologies easier.</p>
</div>
</div>
<div class="sect2">
<h3 id="_finite_field_definition">Finite Field Definition</h3>
<div class="paragraph">
<p>Mathematically, a <em>finite field</em> is defined as a finite set of numbers and two operations <strong>+</strong> (addition) and <strong>⋅</strong> (multiplication) that satisfy the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If <em>a</em> and <em>b</em> are in the set, <em>a + b</em> and <em>a</em> ⋅ <em>b</em> are in the set.
We call this property <em>closed</em>.</p>
</li>
<li>
<p>0 exists and has the property <em>a</em> + 0 = <em>a</em>. We call this the <em>additive identity</em>.</p>
</li>
<li>
<p>1 exists and has the property <em>a</em> ⋅ 1 = <em>a</em>. We call this the <em>multiplicative identity</em>.</p>
</li>
<li>
<p>If <em>a</em> is in the set, <em>–a</em> is in the set, which is defined as the value that makes <em>a</em> + (–<em>a</em>) = 0.
This is what we call the <em>additive inverse</em>.</p>
</li>
<li>
<p>If <em>a</em> is in the set and is not 0, <em>a</em><sup>–1</sup> is in the set, which is defined as the value that makes <em>a</em> ⋅ <em>a</em><sup>–1</sup> = 1.
This is what we call the <em>multiplicative inverse</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s unpack each of these criteria.</p>
</div>
<div class="paragraph">
<p>We have a set of numbers that&#8217;s finite.
Because the set is finite, we can designate a number <em>p</em>, which is how big the set is.
This is what we call the <em>order</em> of the set.</p>
</div>
<div class="paragraph">
<p>#1 says we are closed under addition and multiplication.
This means that we have to define addition and multiplication in a way that ensures the results stay in the set.
For example, a set containing {0,1,2} is <em>not</em> closed under addition, since 1 + 2 = 3 and 3 is not in the set; neither is 2 + 2 = 4.
Of course we can define addition a little differently to make this work, but using "normal" addition, this set is not closed.
On the other hand, the set {–1,0,1} is closed under normal multiplication.
Any two numbers can be multiplied (there are nine such combinations), and the result is always in the set.</p>
</div>
<div class="paragraph">
<p>The other option we have in mathematics is to define multiplication in a particular way to make these sets closed.
We&#8217;ll get to how exactly we define addition and multiplication later in this chapter, but the key concept here is that we can <em>define addition and subtraction differently than the addition and subtraction you are familiar with</em>.</p>
</div>
<div class="paragraph">
<p>#2 and #3 mean that we have the additive and multiplicative identities.
That means 0 and 1 are in the set.</p>
</div>
<div class="paragraph">
<p>#4 means that we have the additive inverse.
That is, if <em>a</em> is in the set, <em>–a</em> is in the set.
Using the additive inverse, we can define subtraction.</p>
</div>
<div class="paragraph">
<p>#5 means that multiplication has the same property.
If <em>a</em> is in the set, <em>a</em><sup>–1</sup> is in the set.
That is <em>a</em> ⋅ <em>a</em><sup>–1</sup> = 1.
Using the multiplicative inverse, we can define division.
This will be the trickiest to define in a finite field.</p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_finite_sets">Defining Finite Sets</h3>
<div class="paragraph">
<p>If the order (or size) of the set is <em>p</em>, we can call the elements of the set, 0, 1, 2, &#8230;&#8203; <em>p</em> – 1.
These numbers are what we call the <em>elements</em> of the set, not necessarily the traditional numbers 0, 1, 2, 3, etc.
They behave in many ways like traditional numbers, but have some differences in how we add, subtract, multiply, and so forth.</p>
</div>
<div class="paragraph">
<p>In math notation the finite field set looks like this:</p>
</div>
<ul class="simplelist">
<li><em>F</em><sub>p</sub> = {0, 1, 2, ... <em>p</em>–1}</li>
</ul>
<div class="paragraph">
<p>What&#8217;s in the finite field set are the elements.
<em>F</em><sub><em>p</em></sub> is a specific finite field called "field of <em>p</em>" or "field of 29" or whatever the size of it is (again, the size is what mathematicians call <em>order</em>).
The numbers between the {}s represent what elements are in the field.
We name the elements 0, 1, 2, etc. because these names are convenient for our purposes.</p>
</div>
<div class="paragraph">
<p>A finite field of order 11 looks like this:</p>
</div>
<ul class="simplelist">
<li><em>F</em><sub>11</sub> = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</li>
</ul>
<div class="paragraph">
<p>A finite field of order 17 looks like this:</p>
</div>
<ul class="simplelist">
<li><em>F</em><sub>17</sub>= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}</li>
</ul>
<div class="paragraph">
<p>A finite field of order 983 looks like this:</p>
</div>
<ul class="simplelist">
<li><em>F</em><sub>983</sub>= {0, 1, 2, ... 982}</li>
</ul>
<div class="paragraph">
<p>Notice the order of the field is always 1 more than the largest element.
You might have noticed that the field has a prime order every time.
For a variety of reasons that will become clear later, it turns out that fields <em>must</em> have an order that is a power of a prime, and that the finite fields whose order is prime are the ones we&#8217;re interested in.</p>
</div>
<div class="sect3">
<h4 id="_constructing_a_finite_field_in_python">Constructing a Finite Field in Python</h4>
<div class="paragraph">
<p>We want to represent each finite field element, so in Python, we&#8217;ll be creating a class that represents a single finite field element.
Naturally, we&#8217;ll name the class <span class="keep-together"><code>FieldElement</code></span>.</p>
</div>
<div class="paragraph">
<p>The class represents an element in a field <em>F</em><sub>prime</sub>.
The bare bones of the class look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:

    def __init__(self, num, prime):
        if num &gt;= prime or num &lt; 0:  # <b class="conum">(1)</b>
            error = 'Num {} not in field range 0 to {}'.format(
                num, prime - 1)
            raise ValueError(error)
        self.num = num  # <b class="conum">(2)</b>
        self.prime = prime

    def __repr__(self):
        return 'FieldElement_{}({})'.format(self.prime, self.num)

    def __eq__(self, other):
        if other is None:
            return False
        return self.num == other.num and self.prime == other.prime  # <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We first check that <code>num</code> is between <code>0</code> and <code>prime-1</code> inclusive.
If not, we get an invalid FieldElement and we raise a <code>ValueError</code>, which is what we should raise when we get an inappropriate value.</p>
</li>
<li>
<p>The rest of the <code><em>init</em></code> method assigns the initialization values to the object.</p>
</li>
<li>
<p>The <code><em>eq</em></code> method checks if two objects of class <code>FieldElement</code> are equal.
This is only true when the <code>num</code> and <code>prime</code> properties are equal.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>What we&#8217;ve defined already allows us to do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement
&gt;&gt;&gt; a = FieldElement(7, 13)
&gt;&gt;&gt; b = FieldElement(6, 13)
&gt;&gt;&gt; print(a == b)
False
&gt;&gt;&gt; print(a == a)
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Python allows us to override the <code>==</code> operator on <code>FieldElement</code> with the <code><em>eq</em></code> method, which is something we&#8217;ll be taking advantage of going forward.</p>
</div>
<div class="paragraph">
<p>You can see this in action in the code that accompanies this book.
Once you&#8217;ve set up Jupyter Notebook (see <a href="#setting_up">Setting Up</a>), you can navigate to <em>code-ch01/Chapter1.ipynb</em> and run the code to see the results.
For the next exercise, you&#8217;ll want to open up <em>ecc.py</em> by clicking the link in the Exercise 1 box.
If you get stuck, please remember that the answers to every exercise are in <a href="#appendix_solutions">Solutions</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_1">Exercise 1</h4>
<div class="paragraph">
<p>Write the corresponding method <code><em>ne</em></code>, which checks if two <code>FieldElement</code> objects are <em>not equal</em> to each other.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modulo_arithmetic">Modulo Arithmetic</h3>
<div class="paragraph">
<p>One of the tools we can use to make a finite field closed under addition, subtraction, multiplication, and division is something called <em>modulo arithmetic</em>.</p>
</div>
<div class="paragraph">
<p>We can define addition on the finite set using modulo arithmetic, which is something you probably learned when you first learned division.
Remember problems like the one in <a href="#long_division_example_one">Long division example 1</a>?</p>
</div>
<div id="long_division_example_one" class="imageblock">
<div class="content">
<img src="./images/prbc_0101.png" alt="Long Division Example 1">
</div>
<div class="title">Figure 5. Long division example 1</div>
</div>
<div class="paragraph">
<p>Whenever the division wasn&#8217;t even, there was something called the "remainder," which is the amount left over from the actual division.
We define modulo in the same way.
We use the operator % for modulo:</p>
</div>
<ul class="simplelist">
<li>7 % 3 = 1</li>
</ul>
<div class="paragraph">
<p><a href="#long_division_example_two">Long division example 2</a> shows another example.</p>
</div>
<div id="long_division_example_two" class="imageblock">
<div class="content">
<img src="./images/prbc_0102.png" alt="Long Division Example 2">
</div>
<div class="title">Figure 6. Long division example 2</div>
</div>
<div class="paragraph">
<p>Formally speaking, the modulo operation is the remainder after division of one number by another.
Let&#8217;s look at another example with larger numbers:</p>
</div>
<ul class="simplelist">
<li>1747 % 241 = 60</li>
</ul>
<div class="paragraph pagebreak-before">
<p>If it helps, you can think of modulo arithmetic as "wraparound" or "clock" math.
Imagine a problem like this:</p>
</div>
<ul class="simplelist">
<li>It is currently 3 o'clock. What hour will it be 47 hours from now?</li>
</ul>
<div class="paragraph">
<p>The answer is 2 o&#8217;clock because (3 + 47) % 12 = 2 (see <a href="#clock_going_forward_47_hours">Clock going forward 47 hours</a>).</p>
</div>
<div id="clock_going_forward_47_hours" class="imageblock">
<div class="content">
<img src="./images/prbc_0103.png" alt="Clock">
</div>
<div class="title">Figure 7. Clock going forward 47 hours</div>
</div>
<div class="paragraph">
<p>We can also see this as "wrapping around" in the sense that we go past 0 every time we move ahead 12 hours.</p>
</div>
<div class="paragraph">
<p>We can perform modulo on negative numbers.
For example, you can ask:</p>
</div>
<ul class="simplelist">
<li>It is currently 3 o'clock.
What hour was it 16 hours ago?</li>
</ul>
<div class="paragraph">
<p>The answer is 11 o&#8217;clock:</p>
</div>
<ul class="simplelist">
<li>(3 – 16) % 12 = 11</li>
</ul>
<div class="paragraph">
<p>The minute hand is also a modulo operation.
For example, you can ask:</p>
</div>
<ul class="simplelist">
<li>It is currently 12 minutes past the hour.
What minute will it be 843 minutes from now?</li>
</ul>
<div class="paragraph">
<p>It will be 15 minutes past the hour:</p>
</div>
<ul class="simplelist">
<li>(12 + 843) % 60 = 15</li>
</ul>
<div class="paragraph">
<p>Likewise, we can ask:</p>
</div>
<ul class="simplelist">
<li>It is currently 23 minutes past the hour.
What minute will it be 97 minutes from now?</li>
</ul>
<div class="paragraph">
<p>In this case, the answer is 0:</p>
</div>
<ul class="simplelist">
<li>(23 + 97) % 60 = 0</li>
</ul>
<div class="paragraph">
<p>0 is another way of saying there is no remainder.</p>
</div>
<div class="paragraph">
<p>The result of the modulo (%) operation for minutes is always between 0 and 59, inclusive.
This happens to be a very useful property as even very large numbers can be brought down to a relatively small range with modulo:</p>
</div>
<ul class="simplelist">
<li>14738495684013 % 60 = 33</li>
</ul>
<div class="paragraph">
<p>We&#8217;ll be using modulo as we define field arithmetic.
Most operations in finite fields use the modulo operator in some capacity.</p>
</div>
<div class="sect3">
<h4 id="_modulo_arithmetic_in_python">Modulo Arithmetic in Python</h4>
<div class="paragraph">
<p>Python uses the <code>%</code> operator for modulo arithmetic.
Here is how the modulo operator is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; print(7 % 3)
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also use the modulo operator on negative numbers, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; print(-27 % 13)
12</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finite_field_addition_and_subtraction">Finite Field Addition and Subtraction</h3>
<div class="paragraph">
<p>Remember that we need to define finite field addition such that we ensure the result is still in the set.
That is, we want to make sure that addition in a finite field is <em>closed</em>.</p>
</div>
<div class="paragraph">
<p>We can use what we just learned, modulo arithmetic, to make addition closed.
Let&#8217;s say we have a finite field of 19:</p>
</div>
<ul class="simplelist">
<li><em>F</em><sub>19</sub> = {0, 1, 2, ... 18}</li>
</ul>
<div class="paragraph">
<p>where <em>a</em>, <em>b</em> ∈ <em>F</em><sub>19</sub>. Note that the symbol ∈ means "is an element of."
In our case, <em>a</em> and <em>b</em> are elements of <em>F</em><sub>19</sub>.</p>
</div>
<div class="paragraph">
<p>Addition being closed means:</p>
</div>
<ul class="simplelist">
<li><em>a</em>+<sub><em>f</em></sub>b ∈ F<sub>19</sub></li>
</ul>
<div class="paragraph">
<p>We denote finite field addition with +<sub><em>f</em></sub> to avoid confusion with normal integer addition, +.</p>
</div>
<div class="paragraph">
<p>If we utilize modulo arithmetic, we can guarantee this to be the case.
We can define <em>a</em>+<sub><em>f</em></sub><em>b</em> this way:</p>
</div>
<ul class="simplelist">
<li><em>a</em>+<sub><em>f</em></sub><em>b</em> = (<em>a</em> + <em>b</em>)%19</li>
</ul>
<div class="paragraph">
<p>For example:</p>
</div>
<ul class="simplelist">
<li>7+<sub><em>f</em></sub>8 = (7+8)%19 = 15</li>
<li>11+<sub><em>f</em></sub>17 = (11+17)%19 = 9</li>
</ul>
<div class="paragraph">
<p>and so on.</p>
</div>
<div class="paragraph">
<p>We take any two numbers in the set, add, and "wrap around" the end to get the sum.
We are creating our own addition operator here and the result is a bit unintuitive.
After all, 11+<sub><em>f</em></sub>17 = 9 just doesn&#8217;t look right because we&#8217;re not used to finite field addition.</p>
</div>
<div class="paragraph">
<p>More generally, we define field addition this way:</p>
</div>
<ul class="simplelist">
<li><em>a</em>+<sub><em>f</em></sub><em>b</em> = (<em>a</em> + <em>b</em>)%<em>p</em></li>
</ul>
<div class="paragraph">
<p>where <em>a</em>, <em>b</em> ∈ <em>F</em><sub><em>p</em></sub>.</p>
</div>
<div class="paragraph">
<p>We also define the additive inverse this way. <em>a</em> ∈ <em>F</em><sub><em>p</em></sub> implies that –<sub><em>f</em></sub><em>a</em> ∈ <em>F</em><sub><em>p</em></sub>:</p>
</div>
<ul class="simplelist">
<li>–<sub><em>f</em></sub><em>a</em> = (–<em>a</em>) % <em>p</em></li>
</ul>
<div class="paragraph">
<p>Again, for clarity, we use –<sub><em>f</em></sub> to distinguish field subtraction and negation from integer subtraction and negation.</p>
</div>
<div class="paragraph">
<p>In <em>F</em><sub>19</sub>:</p>
</div>
<ul class="simplelist">
<li>–<sub><em>f</em></sub>9 = (–9) % 19 = 10</li>
</ul>
<div class="paragraph">
<p>which means that:</p>
</div>
<ul class="simplelist">
<li>9+<sub><em>f</em></sub> 10 = 0</li>
</ul>
<div class="paragraph">
<p>And that turns out to be true.</p>
</div>
<div class="paragraph">
<p>Similarly, we can do field subtraction:</p>
</div>
<ul class="simplelist">
<li><em>a</em>–<sub><em>f</em></sub><em>b</em> = (<em>a</em> – <em>b</em>)%<em>p</em></li>
</ul>
<div class="paragraph">
<p>where <em>a</em>, <em>b</em> ∈ <em>F</em><sub><em>p</em></sub>.</p>
</div>
<div class="paragraph">
<p>In <em>F</em><sub>19</sub>:</p>
</div>
<ul class="simplelist">
<li>11–<sub><em>f</em></sub>9=(11-9)%19 = 2</li>
<li>6–<sub><em>f</em></sub>13=(6-13)%19 = 12</li>
</ul>
<div class="paragraph">
<p>and so on.</p>
</div>
<div class="sect3">
<h4 id="_exercise_2">Exercise 2</h4>
<div class="paragraph">
<p>Solve these problems in <em>F</em><sub>57</sub> (assume all +'s here are +<sub><em>f</em></sub> and –'s here are –<sub><em>f</em></sub>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>44 + 33</p>
</li>
<li>
<p>9 – 29</p>
</li>
<li>
<p>17 + 42 + 49</p>
</li>
<li>
<p>52 – 30 – 38</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_coding_addition_and_subtraction_in_python">Coding Addition and Subtraction in Python</h4>
<div class="paragraph">
<p>In the class <code>FieldElement</code> we can now define <code><em>add</em></code> and <code><em>sub</em></code> methods.
The idea of these methods is that we want something like this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement
&gt;&gt;&gt; a = FieldElement(7, 13)
&gt;&gt;&gt; b = FieldElement(12, 13)
&gt;&gt;&gt; c = FieldElement(6, 13)
&gt;&gt;&gt; print(a+b==c)
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Python we can define what addition (or the + operator) means for our class with the <code><em>add</em></code> method.
So how do we do this?
We combine what we learned with modulo arithmetic and create a new method of the class <code>FieldElement</code> like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">    def __add__(self, other):
        if self.prime != other.prime:  # <b class="conum">(1)</b>
            raise TypeError('Cannot add two numbers in different Fields')
        num = (self.num + other.num) % self.prime  # <b class="conum">(2)</b>
        return self.__class__(num, self.prime)  # <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We have to ensure that the elements are from the same finite field, otherwise this calculation doesn&#8217;t have any meaning.</p>
</li>
<li>
<p>Addition in a finite field is defined with the modulo operator, as explained earlier.</p>
</li>
<li>
<p>We have to return an instance of the class, which we can conveniently access with <code>self.<em>class</em></code>.
We pass the two initializing arguments, <code>num</code> and <code>self.prime</code>, for the <code><em>init</em></code> method we saw earlier.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that we could use <code>FieldElement</code> instead of <code>self.<em>class</em></code>, but this would not make the method easily inheritable.
We will be subclassing <code>FieldElement</code> later, so making the method inheritable is important here.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3">Exercise 3</h4>
<div class="paragraph">
<p>Write the corresponding <code><em>sub</em></code> method that defines the subtraction of two <span class="keep-together"><code>FieldElement</code></span> objects.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finite_field_multiplication_and_exponentiation">Finite Field Multiplication and Exponentiation</h3>
<div class="paragraph">
<p>Just as we defined a new addition (+<sub><em>f</em></sub>) for finite fields that was closed, we can also define a new multiplication for finite fields that&#8217;s closed.
By multiplying the same number many times, we can also define exponentiation.
In this section, we&#8217;ll go through exactly how to define this using modulo arithmetic.</p>
</div>
<div class="paragraph">
<p>Multiplication is adding multiple times:</p>
</div>
<ul class="simplelist">
<li>5 ⋅ 3 = 5 + 5 + 5 = 15</li>
<li>8 ⋅ 17 = 8 + 8 + 8 + ... (17 total 8's) ... + 8 = 136</li>
</ul>
<div class="paragraph">
<p>We can define multiplication on a finite field the same way.
Operating in <em>F</em><sub>19</sub> once again:</p>
</div>
<ul class="simplelist">
<li>5 ⋅<sub><em>f</em></sub> 3 = 5 +<sub><em>f</em></sub> 5 +<sub><em>f</em></sub> 5</li>
<li>8 ⋅<sub><em>f</em></sub> 17 = 8 +<sub><em>f</em></sub> 8 +<sub><em>f</em></sub> 8 +<sub><em>f</em></sub> ... (17 total 8's) ... +<sub><em>f</em></sub> 8</li>
</ul>
<div class="paragraph">
<p>We already know how to do the right side, and that yields a number within the <em>F</em><sub>19</sub> set:</p>
</div>
<ul class="simplelist">
<li>5 ⋅<sub><em>f</em></sub> 3 = 5 +<sub><em>f</em></sub> 5 +<sub><em>f</em></sub> 5 = 15 % 19 = 15</li>
<li>8 ⋅<sub><em>f</em></sub> 17 = 8 +<sub><em>f</em></sub> 8 +<sub><em>f</em></sub> 8 +<sub><em>f</em></sub> ... (17 total 8's) ... +<sub><em>f</em></sub> 8 = (8⋅17) % 19 = 136 % 19 = 3</li>
</ul>
<div class="paragraph">
<p>Note that the second result is pretty unintuitive.
We don&#8217;t normally think of 8 ⋅<sub><em>f</em></sub> 17 = 3, but that&#8217;s part of what&#8217;s necessary in order to define multiplication to be closed.
That is, the result of field multiplication is always in the set {0, 1, &#8230;&#8203; <em>p</em>–1}.</p>
</div>
<div class="paragraph">
<p>Exponentiation is simply multiplying a number many times:</p>
</div>
<ul class="simplelist">
<li>7<sup>3</sup>=7⋅<sub><em>f</em></sub>7⋅<sub><em>f</em></sub>7 = 343</li>
</ul>
<div class="paragraph">
<p>In a finite field, we can do exponentiation using modulo arithmetic.</p>
</div>
<div class="paragraph">
<p>In <em>F</em><sub>19</sub>:</p>
</div>
<ul class="simplelist">
<li>7<sup>3</sup> = 343 % 19=1</li>
<li>9<sup>12</sup> = 7</li>
</ul>
<div class="paragraph">
<p>Exponentiation again gives us counterintuitive results.
We don&#8217;t normally think 7<sup>3</sup> = 1 or 9<sup>12</sup> = 7.
Again, finite fields have to be defined so that the operations <em>always</em> result in a number within the field.</p>
</div>
<div class="sect3">
<h4 id="_exercise_4">Exercise 4</h4>
<div class="paragraph">
<p>Solve the following equations in <em>F</em><sub>97</sub> (again, assume ⋅ and exponentiation are field <span class="keep-together">versions</span>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>95 ⋅ 45 ⋅ 31</p>
</li>
<li>
<p>17 ⋅ 13 ⋅ 19 ⋅ 44</p>
</li>
<li>
<p>12<sup>7</sup> ⋅ 77<sup>49</sup></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5">Exercise 5</h4>
<div class="paragraph">
<p>For <em>k</em> = 1, 3, 7, 13, 18, what is this set in <em>F</em><sub>19</sub>?</p>
</div>
<ul class="simplelist">
<li>{<em>k</em> ⋅ 0, <em>k</em> ⋅ 1, <em>k</em> ⋅ 2, <em>k</em> ⋅ 3, ... <em>k</em> ⋅ 18}</li>
</ul>
<div class="paragraph">
<p>Do you notice anything about these sets?</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Why Prime Fields are Useful</div>
<div class="paragraph">
<p>The answer to Exercise 5 is why we choose to use finite fields with a <em>prime</em> number of elements.
No matter what <em>k</em> you choose, as long as it&#8217;s greater than 0, multiplying the entire set by <em>k</em> will result in the same set as you started with.</p>
</div>
<div class="paragraph">
<p>Intuitively, the fact that we have a prime order results in every element of a finite field being equivalent.
If the order of the set was a composite number, multiplying the set by one of the divisors would result in a smaller set.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_coding_multiplication_in_python">Coding Multiplication in Python</h4>
<div class="paragraph">
<p>Now that we understand what multiplication should be in <code>FieldElement</code>, we want to define the <code><em>mul</em></code> method that overrides the <code>*</code> operator.
We want this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement
&gt;&gt;&gt; a = FieldElement(3, 13)
&gt;&gt;&gt; b = FieldElement(12, 13)
&gt;&gt;&gt; c = FieldElement(10, 13)
&gt;&gt;&gt; print(a*b==c)
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with addition and subtraction, the next exercise is to make multiplication work for our class by defining the <code><em>mul</em></code> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6">Exercise 6</h4>
<div class="paragraph">
<p>Write the corresponding <code><em>mul</em></code> method that defines the multiplication of two finite field elements.</p>
</div>
</div>
<div class="sect3">
<h4 id="_coding_exponentiation_in_python">Coding Exponentiation in Python</h4>
<div class="paragraph">
<p>We need to define the exponentiation for <code>FieldElement</code>, which in Python can be defined with the <code><em>pow</em></code> method, overriding the <code>**</code> operator.
The difference here is that the exponent is <em>not</em> a <code>FieldElement</code>, so it has to be treated a bit differently.
We want something like this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement
&gt;&gt;&gt; a = FieldElement(3, 13)
&gt;&gt;&gt; b = FieldElement(1, 13)
&gt;&gt;&gt; print(a**3==b)
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that because the exponent is an integer, instead of another instance of <code>FieldElement</code>, the method receives the variable <code>exponent</code> as an integer.
We can code it this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:
...
    def __pow__(self, exponent):
        num = (self.num ** exponent) % self.prime  # <b class="conum">(1)</b>
        return self.__class__(num, self.prime)  # <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is a perfectly fine way to do it, but <code>pow(self.num, exponent, self.prime)</code> is more efficient.</p>
</li>
<li>
<p>We have to return an instance of the class as before.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Why don&#8217;t we force the exponent to be a <code>FieldElement</code> object?
It turns out that the exponent doesn&#8217;t have to be a member of the finite field for the math to work.
In fact, if it were, the exponents wouldn&#8217;t display the intuitive behavior we expect, like being able to add the exponents when we multiply with the same base.</p>
</div>
<div class="paragraph">
<p>Some of what we&#8217;re doing now may seem slow for large numbers, but we&#8217;ll use some clever tricks to improve the performance of these algorithms.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7">Exercise 7</h4>
<div class="paragraph">
<p>For <em>p</em> = 7, 11, 17, 31, what is this set in <em>F<sub>p</sub></em>?</p>
</div>
<ul class="simplelist">
<li>{1<sup>(<em>p</em> – 1)</sup>, 2<sup>(<em>p</em> – 1)</sup>, 3<sup>(<em>p</em> – 1)</sup>, 4<sup>(<em>p</em> – 1)</sup>, ... (<em>p</em> – 1)<sup>(<em>p</em> – 1)</sup>}</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_finite_field_division">Finite Field Division</h3>
<div class="paragraph">
<p>The intuition that helps us with addition, subtraction, multiplication, and perhaps even exponentiation unfortunately doesn&#8217;t help us quite as much with division.
Because division is the hardest operation to make sense of, we&#8217;ll start with something that should make sense.</p>
</div>
<div class="paragraph">
<p>In normal math, division is the inverse of multiplication:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>7 ⋅ 8 = 56 implies that 56/8 = 7</p>
</li>
<li>
<p>12 ⋅ 2 = 24 implies that 24/12 = 2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And so on.
We can use this as the definition of division to help us.
Note that like in normal math, you cannot divide by 0.</p>
</div>
<div class="paragraph">
<p>In <em>F</em><sub>19</sub>, we know that:</p>
</div>
<ul class="simplelist">
<li>3⋅<sub><em>f</em></sub>7 = 21%19 = 2 implies that 2/<sub><em>f</em></sub>7 = 3</li>
<li>9⋅<sub><em>f</em></sub>5 = 45%19 = 7 implies that 7/<sub><em>f</em></sub>5 = 9</li>
</ul>
<div class="paragraph">
<p>This is very unintuitive, as we generally think of 2/<sub><em>f</em></sub>7 or 7/<sub><em>f</em></sub>5 as fractions, not nice finite field elements.
Yet that is one of the remarkable things about finite fields: finite fields are <em>closed</em> under division.
That is, dividing any two numbers where the denominator is not 0 will result in another finite field element.</p>
</div>
<div class="paragraph">
<p>The question you might be asking yourself is, how do I calculate 2/<sub><em>f</em></sub>7 if I don&#8217;t know beforehand that 3⋅<sub><em>f</em></sub>7 = 2?
This is indeed a very good question; to answer it, we&#8217;ll have to use the result from Exercise 7.</p>
</div>
<div class="paragraph">
<p>In case you didn&#8217;t get it, the answer is that <em>n</em><sup>(<em>p</em>–1)</sup> is always 1 for every <em>p</em> that is prime and every <em>n</em> &gt; 0.
This is a beautiful result from number theory called Fermat&#8217;s little theorem.
Essentially, the theorem says:</p>
</div>
<ul class="simplelist">
<li><em>n</em><sup>(<em>p</em>–1)</sup>%<em>p</em> = 1 </li>
</ul>
<div class="paragraph">
<p>where <em>p</em> is prime.</p>
</div>
<div class="paragraph">
<p>Since we are operating in prime fields, this will always be true.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Fermat&#8217;s Little Theorem</div>
<div class="paragraph">
<p>There are many proofs of this theorem, but perhaps the simplest is using what we saw in Exercise 5—namely, that these sets are equal:</p>
</div>
<ul class="simplelist">
<li>{1, 2, 3, ... <em>p</em>–2, <em>p</em>–1} = {<em>n</em>%<em>p</em>, 2<em>n</em>%<em>p</em>, 3<em>n</em>%<em>p</em> (<em>p</em>–2)<em>n</em>%<em>p</em>, (<em>p</em>–1)<em>n</em>%<em>p</em>}</li>
</ul>
<div class="paragraph">
<p>The resulting numbers might not be in the right order, but the same numbers are in both sets. We can then multiply every element in both sets to get this equality:</p>
</div>
<ul class="simplelist">
<li>1 ⋅ 2 ⋅ 3 ⋅ ... ⋅ (<em>p</em>–2) ⋅ (<em>p</em>–1) % <em>p</em> = <em>n</em> ⋅ 2<em>n</em> ⋅ 3<em>n</em> ⋅ ... ⋅ (<em>p</em>–2)<em>n</em> ⋅ (<em>p</em>–1)<em>n</em> % <em>p</em></li>
</ul>
<div class="paragraph">
<p>The left side is the same as (<em>p</em>–1)! % <em>p</em> where ! is the factorial (e.g.,
5! = 5 ⋅ 4 ⋅ 3 ⋅ 2 ⋅ 1). On the right side, we can gather up all the <em>n</em>&#8217;s and get:</p>
</div>
<ul class="simplelist">
<li>(<em>p</em>–1)! ⋅ <em>n</em><sup>(p–1)</sup> % <em>p</em></li>
</ul>
<div class="paragraph">
<p>Thus:</p>
</div>
<ul class="simplelist">
<li>(<em>p</em>–1)! % <em>p</em> = (<em>p</em>–1)! ⋅ <em>n</em><sup>(p–1)</sup> % <em>p</em></li>
</ul>
<div class="paragraph">
<p>The (<em>p</em>–1)! on both sides cancel, giving us:</p>
</div>
<ul class="simplelist">
<li>1 = <em>n</em><sup>(p–1)</sup> % <em>p</em></li>
</ul>
<div class="paragraph">
<p>This proves Fermat&#8217;s little theorem.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Because division is the inverse of multiplication, we know:</p>
</div>
<ul class="simplelist">
<li><em>a</em>/<em>b</em> = <em>a</em>⋅<sub><em>f</em></sub>(1/<em>b</em>) = <em>a</em>⋅<sub><em>f</em></sub><em>b</em><sup>–1</sup></li>
</ul>
<div class="paragraph">
<p>We can reduce the division problem to a multiplication problem as long as we can figure out what <em>b</em><sup>–1</sup> is.
This is where Fermat&#8217;s little theorem comes into play.
We know:</p>
</div>
<ul class="simplelist">
<li><em>b</em><sup>(<em>p</em>–1)</sup> = 1</li>
</ul>
<div class="paragraph">
<p>because <em>p</em> is prime. Thus:</p>
</div>
<ul class="simplelist">
<li><em>b</em><sup>–1</sup> = <em>b</em><sup>–1</sup>⋅<sub><em>f</em></sub>1=<em>b</em><sup>–1</sup>⋅<sub><em>f</em></sub><em>b</em><sup>(<em>p</em>–1)</sup> = <em>b</em><sup>(<em>p</em>–2)</sup></li>
</ul>
<div class="paragraph">
<p>or:</p>
</div>
<ul class="simplelist">
<li><em>b</em><sup>–1</sup> = <em>b</em><sup>(<em>p</em>–2)</sup></li>
</ul>
<div class="paragraph">
<p>In <em>F</em><sub>19</sub>, this means practically that <em>b</em><sup>18</sup> = 1 , which means that <em>b</em><sup>–1</sup> = <em>b</em><sup>17</sup> for all <em>b</em> &gt; 0.</p>
</div>
<div class="paragraph">
<p>So in other words, we can calculate the inverse using the exponentiation operator.
In <em>F</em><sub>19</sub>:</p>
</div>
<ul class="simplelist">
<li>2/7 = 2⋅7<sup>(19 – 2)</sup> = 2⋅7<sup>17</sup>=465261027974414%19 = 3</li>
<li> 7/5 = 7⋅5<sup>(19 – 2)</sup> = 7⋅5<sup>17</sup>=5340576171875%19 = 9</li>
</ul>
<div class="paragraph">
<p>This is a relatively expensive calculation as exponentiating grows very fast.
Division is the most expensive operation for that reason.
To lessen the expense, we can use the <code>pow</code> function in Python, which does exponentiation.
In Python, <code>pow(7,17)</code> does the same thing as <code>7<strong>17</code>.
The <code>pow</code> function, however, has an optional third argument that makes our calculation more efficient.
Specifically, <code>pow</code> will modulo by the third argument.
Thus, <code>pow(7,17,19)</code> will give the same result as <code>7</strong>17%19</code> but do so faster because the modulo function is done after each round of multiplication.</p>
</div>
<div class="sect3">
<h4 id="_exercise_8">Exercise 8</h4>
<div class="paragraph">
<p>Solve the following equations in <em>F</em><sub>31</sub>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>3 / 24</p>
</li>
<li>
<p>17<sup>–3</sup></p>
</li>
<li>
<p>4<sup>–4</sup> ⋅ 11</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_9">Exercise 9</h4>
<div class="paragraph">
<p>Write the corresponding <code><em>truediv</em></code> method that defines the division of two field elements.</p>
</div>
<div class="paragraph">
<p>Note that in Python 3, division is separated into <code><em>truediv</em></code> and <code><em>floordiv</em></code>. The first does normal division and the second does integer division.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_redefining_exponentiation">Redefining Exponentiation</h3>
<div class="paragraph">
<p>One last thing that we need to take care of before we leave this chapter is the <code><em>pow</em></code> method, which needs to handle negative exponents.
For example, <em>a</em><sup>–3</sup> needs to be a finite field element, but the current code does not take care of this case.
We want, for example, something like this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement
&gt;&gt;&gt; a = FieldElement(7, 13)
&gt;&gt;&gt; b = FieldElement(8, 13)
&gt;&gt;&gt; print(a**-3==b)
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately, the way we&#8217;ve defined <code><em>pow</em></code> simply doesn&#8217;t handle negative exponents, because the second parameter of the built-in Python function <code>pow</code> is required to be positive.</p>
</div>
<div class="paragraph">
<p>Thankfully, we can use some math we already know to solve this. We know from <span class="keep-together">Fermat's</span> little theorem that:</p>
</div>
<ul class="simplelist">
<li><em>a</em><sup><em>p</em>–1</sup> = 1</li>
</ul>
<div class="paragraph">
<p>This fact means that we can multiply by <em>a</em><sup><em>p</em>–1</sup> as many times as we want.
So, for <em>a</em><sup>–3</sup>, we can do:</p>
</div>
<ul class="simplelist">
<li><em>a</em><sup>–3</sup> = <em>a</em><sup>–3</sup> ⋅ <em>a</em><sup><em>p</em>–1</sup> = <em>a</em><sup><em>p</em>–4</sup></li>
</ul>
<div class="paragraph">
<p>This is a way we can do negative exponents.
A naive implementation would do something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:
...
    def __pow__(self, exponent):
	n = exponent
	while n &lt; 0:
	    n += self.prime - 1 # <b class="conum">(1)</b>
        num = pow(self.num, n, self.prime) # <b class="conum">(2)</b>
        return self.__class__(num, self.prime)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We add until we get a positive exponent.</p>
</li>
<li>
<p>We use the Python built-in <code>pow</code> to make this more efficient.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Thankfully, we can do even better.
We already know how to force a number out of being negative, using our familiar friend <code>%</code>!
As a bonus, we can also reduce very large exponents at the same time given that <em>a</em><sup><em>p</em>–1</sup> = 1.
This will make the <code>pow</code> function not work as hard:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:
...
    def __pow__(self, exponent):
        n = exponent % (self.prime - 1)  # <b class="conum">(1)</b>
        num = pow(self.num, n, self.prime)
        return self.__class__(num, self.prime)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Make the exponent into something within the 0 to <em>p</em>–2 range, inclusive.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">Conclusion</h3>
<div class="paragraph">
<p>In this chapter we learned about finite fields and how to implement them in Python.
We&#8217;ll be using finite fields in <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a> for elliptic curve cryptography.
We turn next to the other mathematical component that we need for elliptic curve cryptography: elliptic curves.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_elliptic_curves">Elliptic Curves</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>In this chapter we&#8217;re going to learn about elliptic curves.
In <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>, we will combine elliptic curves with finite fields to make elliptic curve cryptography.</p>
</div>
<div class="paragraph">
<p>Like finite fields, elliptic curves can look intimidating if you haven&#8217;t seen them before.
But again, the actual math isn&#8217;t very difficult.
Most of what you need to know about elliptic curves could have been taught to you after algebra.
In this chapter, we&#8217;ll explore what these curves are and what we can do with them.</p>
</div>
<div class="sect2">
<h3 id="_definition">Definition</h3>
<div class="paragraph">
<p>Elliptic curves are like many equations you&#8217;ve seen since pre-algebra.
They have <em>y</em> on one side and <em>x</em> on the other, in some form.
elliptic curves have a form like this:</p>
</div>
<ul class="simplelist">
<li><em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em></li>
</ul>
<div class="paragraph">
<p>You&#8217;ve worked with other equations that look similar.
For example, you probably learned the linear equation back in pre-algebra:</p>
</div>
<ul class="simplelist">
<li><em>y</em> = <em>mx</em> + <em>b</em></li>
</ul>
<div class="paragraph">
<p>You may even remember that <em>m</em> here has the name <em>slope</em> and <em>b</em> is the <em>y-intercept</em>.
You can also graph linear equations, as shown in <a href="#linear_equation">Linear equation</a>.</p>
</div>
<div id="linear_equation" class="imageblock">
<div class="content">
<img src="./images/prbc_0201.png" alt="Linear equation">
</div>
<div class="title">Figure 8. Linear equation</div>
</div>
<div class="paragraph">
<p>Similarly, you&#8217;re probably familiar with the quadratic equation and its graph (<a href="#quadratic_equation">Quadratic equation</a>):</p>
</div>
<ul class="simplelist">
<li><em>y</em> = <em>ax</em><sup>2</sup> + <em>bx</em> + <em>c</em></li>
</ul>
<div class="paragraph">
<p>And sometime around algebra, you did even higher orders of <em>x</em>—something called the cubic equation and its graph (<a href="#cubic_equation">Cubic equation</a>):</p>
</div>
<ul class="simplelist">
<li><em>y</em> = <em>ax</em><sup>3</sup> + <em>bx</em><sup>2</sup> + <em>cx</em> + <em>d</em></li>
</ul>
<div id="quadratic_equation" class="imageblock width-90">
<div class="content">
<img src="./images/prbc_0202.png" alt="Quadratic equation">
</div>
<div class="title">Figure 9. Quadratic equation</div>
</div>
<div id="cubic_equation" class="imageblock width-90">
<div class="content">
<img src="./images/prbc_0203.png" alt="Cubic equation">
</div>
<div class="title">Figure 10. Cubic equation</div>
</div>
<div class="paragraph">
<p>An elliptic curve isn&#8217;t all that different:</p>
</div>
<ul class="simplelist">
<li><em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em></li>
</ul>
<div class="paragraph">
<p>The only real difference between the elliptic curve and the cubic curve in <a href="#cubic_equation">Cubic equation</a> is the <em>y</em><sup>2</sup> term on the left side.
This has the effect of making the graph symmetric over the x-axis, as shown in <a href="#continuous_elliptic_curve">Continuous elliptic curve</a>.</p>
</div>
<div id="continuous_elliptic_curve" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0204.png" alt="Elliptic curve equation">
</div>
<div class="title">Figure 11. Continuous elliptic curve</div>
</div>
<div class="paragraph pagebreak-before">
<p>The elliptic curve is also less steep than the cubic curve.
Again, this is because of the <em>y</em><sup>2</sup> term on the left side.
At times, the curve may even be disjoint, as in <a href="#disjoint_elliptic_curve">Disjoint elliptic curve</a>.</p>
</div>
<div id="disjoint_elliptic_curve" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0205.png" alt="Elliptic curve equation">
</div>
<div class="title">Figure 12. Disjoint elliptic curve</div>
</div>
<div class="paragraph pagebreak-before">
<p>If it helps, an elliptic curve can be thought of as taking a cubic equation graph (<a href="#step_1_a_cubic_equation">Step 1: A cubic equation</a>), flattening out the part above the x-axis (<a href="#step_2_a_cubic_equation">Step 2: Stretched cubic equation</a>), and then mirroring that part below the x-axis (<a href="#step_3_a_cubic_equation">Step 3: Reflected over the x-axis</a>).</p>
</div>
<div id="step_1_a_cubic_equation" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0206.png" alt="Start">
</div>
<div class="title">Figure 13. Step 1: A cubic equation</div>
</div>
<div id="step_2_a_cubic_equation" class="imageblock width-50">
<div class="content">
<img src="./images/prbc_0207.png" alt="Stretch">
</div>
<div class="title">Figure 14. Step 2: Stretched cubic equation</div>
</div>
<div id="step_3_a_cubic_equation" class="imageblock width-50">
<div class="content">
<img src="./images/prbc_0208.png" alt="Symmetric">
</div>
<div class="title">Figure 15. Step 3: Reflected over the x-axis</div>
</div>
<div class="paragraph">
<p>Specifically, the elliptic curve used in Bitcoin is called <em>secp256k1</em> and it uses this particular equation:</p>
</div>
<ul class="simplelist">
<li><em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7</li>
</ul>
<div class="paragraph">
<p>The canonical form is <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>, so the curve is defined by the constants <em>a</em> = 0, <span class="keep-together"><em>b</em> = 7</span>.
It looks like <a href="#secp256k1_curve">secp256k1 curve</a>.</p>
</div>
<div id="secp256k1_curve" class="imageblock">
<div class="content">
<img src="./images/prbc_0209.png" alt="secp256k1 curve">
</div>
<div class="title">Figure 16. secp256k1 curve</div>
</div>
</div>
<div class="sect2">
<h3 id="_coding_elliptic_curves_in_python">Coding Elliptic Curves in Python</h3>
<div class="paragraph">
<p>For a variety of reasons that will be made clear later, we are not interested in the curve itself, but specific points on the curve.
For example, in the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> + 7, we are interested in the coordinate (–1,1).
We are thus going to define the class <code>Point</code> to be a <em>point</em> on a specific curve.
The curve has the form <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>, so we can define the curve with just the two numbers <em>a</em> and <em>b</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:

    def __init__(self, x, y, a, b):
        self.a = a
        self.b = b
        self.x = x
        self.y = y
        if self.y**2 != self.x**3 + a * x + b:  # <b class="conum">(1)</b>
            raise ValueError('({}, {}) is not on the curve'.format(x, y))

    def __eq__(self, other):  # <b class="conum">(2)</b>
        return self.x == other.x and self.y == other.y \
            and self.a == other.a and self.b == other.b</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We check here that the point is actually on the curve.</p>
</li>
<li>
<p>Points are equal if and only if they are on the same curve and have the same coordinates.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can now create <code>Point</code> objects, and we will get an error if the point is not on the curve:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import Point
&gt;&gt;&gt; p1 = Point(-1, -1, 5, 7)
&gt;&gt;&gt; p2 = Point(-1, -2, 5, 7)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "ecc.py", line 143, in __init__
    raise ValueError('({}, {}) is not on the curve'.format(self.x, self.y))
ValueError: (-1, -2) is not on the curve</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, <code><em>init</em></code> will raise an exception when the point is not on the curve.</p>
</div>
<div class="sect3">
<h4 id="_exercise_1_2">Exercise 1</h4>
<div class="paragraph">
<p>Determine which of these points are on the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> + 7:</p>
</div>
<ul class="simplelist">
<li>(2,4), (–1,–1), (18,77), (5,7)</li>
</ul>
</div>
<div class="sect3">
<h4 id="_exercise_2_2">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code><em>ne</em></code> method for <code>Point</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_point_addition">Point Addition</h3>
<div class="paragraph">
<p>Elliptic curves are useful because of something called <em>point addition</em>.
Point addition is where we can do an operation on two of the points on the curve and get a third point, also on the curve.
This is called <em>addition</em> because the operation has a lot of the intuitions we associate with the mathematical operation of addition.
For example, point addition is commutative.
That is, adding point A to point B is the same as adding point B to point A.</p>
</div>
<div class="paragraph">
<p>The way we define point addition is as follows.
It turns out that for every elliptic curve, a line will intersect it at either one point (<a href="#line_intersects_at_only_1_point">Line intersects at only one point</a>) or three points (<a href="#line_intersects_at_3_points">Line intersects at three points</a>), except in a couple of special cases.</p>
</div>
<div id="line_intersects_at_only_1_point" class="imageblock width-50">
<div class="content">
<img src="./images/prbc_0210.png" alt="Line intersecting at one point">
</div>
<div class="title">Figure 17. Line intersects at only one point</div>
</div>
<div id="line_intersects_at_3_points" class="imageblock width-50">
<div class="content">
<img src="./images/prbc_0211.png" alt="Line intersecting at three points">
</div>
<div class="title">Figure 18. Line intersects at three points</div>
</div>
<div class="paragraph pagebreak-before">
<p>The two exceptions are when a line is exactly vertical (<a href="#line_intersects_at_2_points_because_its_vertical">Line intersects at two points because it&#8217;s vertical</a>) and when a line is <em>tangent</em> to the curve (<a href="#line_intersects_at_2_points_because_its_tangent_to_the_curve">Line intersects at two points because it&#8217;s tangent to the curve</a>).</p>
</div>
<div id="line_intersects_at_2_points_because_its_vertical" class="imageblock width-50">
<div class="content">
<img src="./images/prbc_0212.png" alt="Vertical Line">
</div>
<div class="title">Figure 19. Line intersects at two points because it&#8217;s vertical</div>
</div>
<div id="line_intersects_at_2_points_because_its_tangent_to_the_curve" class="imageblock width-50">
<div class="content">
<img src="./images/prbc_0213.png" alt="Tangent Line">
</div>
<div class="title">Figure 20. Line intersects at two points because it&#8217;s tangent to the curve</div>
</div>
<div class="paragraph">
<p>We will come back to these two cases later.</p>
</div>
<div class="paragraph">
<p>We can define point addition using the fact that lines intersect one or three times with the elliptic curve.
Two points define a line, so since that line must intersect the curve one more time, that third point reflected over the x-axis is the result of the point addition.</p>
</div>
<div class="paragraph">
<p>So, for any two points <em>P</em><sub>1</sub> = (<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>) and <em>P</em><sub>2</sub> = (<em>x</em><sub>2</sub>,<em>y</em><sub>2</sub>), we get <em>P</em><sub>1</sub> + <em>P</em><sub>2</sub> as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Find the point intersecting the elliptic curve a third time by drawing a line through <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub>.</p>
</li>
<li>
<p>Reflect the resulting point over the x-axis.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Visually, it looks like <a href="#point_addition">Point addition</a>.</p>
</div>
<div id="point_addition" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0214.png" alt="Point addition">
</div>
<div class="title">Figure 21. Point addition</div>
</div>
<div class="paragraph">
<p>We first draw a line through the two points we&#8217;re adding (<em>A</em> and <em>B</em>).
The third intersection point is <em>C</em>.
We then reflect that point over the x-axis, which puts us at the <em>A</em> + <em>B</em> point in <a href="#point_addition">Point addition</a>.</p>
</div>
<div class="paragraph">
<p>One of the properties that we are going to use is that point addition is not easily predictable.
We can calculate point addition easily enough with a formula, but intuitively, the result of point addition can be almost anywhere given two points on the curve.
Going back to <a href="#point_addition">Point addition</a>, <em>A</em> + <em>B</em> is to the right of both points, <em>A</em> + <em>C</em> would be somewhere between <em>A</em> and <em>C</em> on the x-axis, and <em>B</em> + <em>C</em> would be to the left of both points.
In mathematics parlance, point addition is <em>nonlinear</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_math_of_point_addition">Math of Point Addition</h3>
<div class="paragraph">
<p>Point addition satisfies certain properties that we associate with addition, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identity</p>
</li>
<li>
<p>Commutativity</p>
</li>
<li>
<p>Associativity</p>
</li>
<li>
<p>Invertibility</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Identity</em> here means that there&#8217;s a zero.
That is, there exists some point <em>I</em> that, when added to a point <em>A</em>, results in <em>A</em>:</p>
</div>
<ul class="simplelist">
<li><em>I</em> + <em>A</em> = <em>A</em></li>
</ul>
<div class="paragraph">
<p>We&#8217;ll call this point the <em>point at infinity</em> (reasons for this will become clear in a moment).</p>
</div>
<div class="paragraph">
<p>This is related to <em>invertibility</em>.
For some point <em>A</em>, there&#8217;s some other point –<em>A</em> that results in the identity point.
That is:</p>
</div>
<ul class="simplelist">
<li><em>A</em> + (–<em>A</em>) = <em>I</em></li>
</ul>
<div class="paragraph">
<p>Visually, these points are opposite one another over the x-axis on the curve (see <a href="#vertical_line_intersection">Vertical line intersection</a>).</p>
</div>
<div id="vertical_line_intersection" class="imageblock width-50">
<div class="content">
<img src="./images/prbc_0212.png" alt="Vertical Line">
</div>
<div class="title">Figure 22. Vertical line intersection</div>
</div>
<div class="paragraph">
<p>This is why we call this point the point at infinity.
We have one extra point in the elliptic curve, which makes the vertical line intersect the curve a third time.</p>
</div>
<div class="paragraph">
<p><em>Commutativity</em> means that <em>A</em> + <em>B</em> = <em>B</em> + <em>A</em>.
This is obvious since the line going through <em>A</em> and <em>B</em> will intersect the curve a third time in the same place, no matter the order.</p>
</div>
<div class="paragraph">
<p><em>Associativity</em> means that (<em>A</em> + <em>B</em>) + <em>C</em> = <em>A</em> + (<em>B</em> + <em>C</em>).
This isn&#8217;t obvious and is the reason for flipping over the x-axis. This is shown in Figures <a data-type="xref" href="#a_b_c_case_1" data-xrefstyle="select:labelnumber">#a_b_c_case_1</a> and
<a data-type="xref" href="#a_b_c_case_2" data-xrefstyle="select:labelnumber">#a_b_c_case_2</a>.</p>
</div>
<div class="paragraph">
<p>You can see that in both <a href="#a_b_c_case_1">(A + B) + C</a> and <a href="#a_b_c_case_2">A + (B + C)</a>, the final point is the same.
In other words, we have good reason to believe that (<em>A</em> + <em>B</em>) + <em>C</em> = <em>A</em> + (<em>B</em> + <em>C</em>).
While this doesn&#8217;t prove the associativity of point addition, the visual should at least give you the intuition that this is true.</p>
</div>
<div id="a_b_c_case_1" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0216.png" alt="Case 1">
</div>
<div class="title">Figure 23. (A + B) + C</div>
</div>
<div id="a_b_c_case_2" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0217.png" alt="Case 2">
</div>
<div class="title">Figure 24. A + (B + C)</div>
</div>
<div class="paragraph">
<p>To code point addition, we&#8217;re going to split it up into three steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Where the points are in a vertical line or using the identity point</p>
</li>
<li>
<p>Where the points are not in a vertical line, but are different</p>
</li>
<li>
<p>Where the two points are the same</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_coding_point_addition">Coding Point Addition</h3>
<div class="paragraph">
<p>We first handle the identity point, or point at infinity.
Since we can&#8217;t easily use infinity in Python, we&#8217;ll use the <code>None</code> value instead.
What we want is this to work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import Point
&gt;&gt;&gt; p1 = Point(-1, -1, 5, 7)
&gt;&gt;&gt; p2 = Point(-1, 1, 5, 7)
&gt;&gt;&gt; inf = Point(None, None, 5, 7)
&gt;&gt;&gt; print(p1 + inf)
Point(-1,-1)_5_7
&gt;&gt;&gt; print(inf + p2)
Point(-1,1)_5_7
&gt;&gt;&gt; print(p1 + p2)
Point(infinity)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this work, we have to do two things. First, we have to adjust the <code><em>init</em></code> method slightly so it doesn&#8217;t check that the curve equation is satisfied when we have the point at infinity.
Second, we have to overload the addition operator or <code><em>add</em></code> as we did with the <code>FieldElement</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:

    def __init__(self, x, y, a, b):
        self.a = a
        self.b = b
        self.x = x
        self.y = y
        if self.x is None and self.y is None:  # <b class="conum">(1)</b>
            return
        if self.y**2 != self.x**3 + a * x + b:
            raise ValueError('({}, {}) is not on the curve'.format(x, y))

    def __add__(self, other):  # <b class="conum">(2)</b>
        if self.a != other.a or self.b != other.b:
            raise TypeError('Points {}, {} are not on the same curve'.format
            (self, other))

        if self.x is None:  # <b class="conum">(3)</b>
            return other
        if other.x is None:  # <b class="conum">(4)</b>
            return self</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <em>x</em> coordinate and <em>y</em> coordinate being <code>None</code> is how we signify the point at infinity.
Note that the next if statement will fail if we don&#8217;t return here.</p>
</li>
<li>
<p>We overload the <code>+</code> operator here.</p>
</li>
<li>
<p><code>self.x</code> being <code>None</code> means that <code>self</code> is the point at infinity, or the additive identity.
Thus, we return <code>other</code>.</p>
</li>
<li>
<p><code>other.x</code> being <code>None</code> means that <code>other</code> is the point at infinity, or the additive identity.
Thus, we return <code>self</code>.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_3_2">Exercise 3</h4>
<div class="paragraph">
<p>Handle the case where the two points are additive inverses (that is, they have the same <code>x</code> but a different <code>y</code>, causing a vertical line). This should return the point at infinity.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_point_addition_for_when_x1x2">Point Addition for When x<sub>1</sub>≠x<sub>2</sub></h3>
<div class="paragraph">
<p>Now that we&#8217;ve covered the vertical line, let&#8217;s examine when the points are different.
When we have points where the `x&#8217;s differ, we can add using a fairly simple formula.
To help with intuition, we&#8217;ll first find the slope created by the two points.
We can figure this out using a formula from pre-algebra:</p>
</div>
<ul class="simplelist">
<li><em>P</em><sub>1</sub> = (<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>), <em>P</em><sub>2</sub> = (<em>x</em><sub>2</sub>,<em>y</em><sub>2</sub>), <em>P</em><sub>3</sub> = (<em>x</em><sub>3</sub>,<em>y</em><sub>3</sub>)</li>
<li><em>P</em><sub>1</sub> + <em>P</em><sub>2</sub> = <em>P</em><sub>3</sub></li>
<li><em>s</em> = (<em>y</em><sub>2</sub> – <em>y</em><sub>1</sub>)/(<em>x</em><sub>2</sub> – <em>x</em><sub>1</sub>)</li>
</ul>
<div class="paragraph">
<p>This is the <em>slope</em>, and we can use the slope to calculate <em>x</em><sub>3</sub>.
Once we know <em>x</em><sub>3</sub>, we can calculate <em>y</em><sub>3</sub>.
<em>P</em><sub>3</sub> can be derived using this formula:</p>
</div>
<ul class="simplelist">
<li><em>x</em><sub>3</sub> = <em>s</em><sup>2</sup> – <em>x</em><sub>1</sub> – <em>x</em><sub>2</sub></li>
<li><em>y</em><sub>3</sub> = <em>s</em>(<em>x</em><sub>1</sub> – <em>x</em><sub>3</sub>) – <em>y</em><sub>1</sub></li>
</ul>
<div class="paragraph">
<p>Remember that <em>y</em><sub>3</sub> is the reflection over the x-axis.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Deriving the Point Addition Formula</div>
<div class="paragraph">
<p>Supposing:</p>
</div>
<ul class="simplelist">
<li><em>P</em><sub>1</sub> = (<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>), <em>P</em><sub>2</sub> = (<em>x</em><sub>2</sub>,<em>y</em><sub>2</sub>), <em>P</em><sub>3</sub> = (<em>x</em><sub>3</sub>,<em>y</em><sub>3</sub>)</li>
<li><em>P</em><sub>1</sub> + <em>P</em><sub>2</sub> = <em>P</em><sub>3</sub></li>
</ul>
<div class="paragraph">
<p>We want to know what <em>P</em><sub>3</sub> is.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with the fact that the line goes through <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub>, and has this formula:</p>
</div>
<ul class="simplelist">
<li><em>s</em> = (<em>y</em><sub>2</sub> – <em>y</em><sub>1</sub>)/(<em>x</em><sub>2</sub> – <em>x</em><sub>1</sub>)</li>
<li><em>y</em> = <em>s</em>(<em>x</em> – <em>x</em><sub>1</sub>) + <em>y</em><sub>1</sub></li>
</ul>
<div class="paragraph">
<p>The second formula is the equation of the line that intersects at both <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub>.
Using this formula and plugging it into the elliptic curve equation, we get:</p>
</div>
<ul class="simplelist">
<li><em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em></li>
<li><em>y</em><sup>2</sup> = (<em>s</em>(<em>x</em> – <em>x</em><sub>1</sub>) + <em>y</em><sub>1</sub>)<sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em></li>
</ul>
<div class="paragraph">
<p>Gathering all the terms, we have this polynomial equation:</p>
</div>
<ul class="simplelist">
<li><em>x</em><sup>3</sup> – <em>s</em><sup>2</sup><em>x</em><sup>2</sup> + (<em>a</em> + 2<em>s</em><sup>2</sup><em>x</em><sub>1</sub> – 2<em>sy</em><sub>1</sub>)<em>x</em> + <em>b</em> – <em>s</em><sup>2</sup><em>x</em><sub>1</sub><sup>2</sup> + 2<em>sx</em><sub>1</sub><em>y</em><sub>1</sub> – <em>y</em><sub>1</sub><sup>2</sup> = 0</li>
</ul>
<div class="paragraph">
<p>We also know that <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, and <em>x</em><sub>3</sub> are solutions to this equation, thus:</p>
</div>
<ul class="simplelist">
<li>(<em>x</em> – <em>x</em><sub>1</sub>)(<em>x</em> – <em>x</em><sub>2</sub>)(<em>x</em> – <em>x</em><sub>3</sub>) = 0</li>
<li><em>x</em><sup>3</sup> – (<em>x</em><sub>1</sub> + <em>x</em><sub>2</sub> + <em>x</em><sub>3</sub>)<em>x</em><sup>2</sup> + (<em>x</em><sub>1</sub><em>x</em><sub>2</sub> + <em>x</em><sub>1</sub><em>x</em><sub>3</sub> + <em>x</em><sub>2</sub><em>x</em><sub>3</sub>)<em>x</em> – <em>x</em><sub>1</sub><em>x</em><sub>2</sub><em>x</em><sub>3</sub> = 0</li>
</ul>
<div class="paragraph">
<p>From earlier, we know that:</p>
</div>
<ul class="simplelist">
<li><em>x</em><sup>3</sup> – <em>s</em><sup>2</sup><em>x</em><sup>2</sup> + (<em>a</em> + 2<em>s</em><sup>2</sup><em>x</em><sub>1</sub> – 2<em>sy</em>~1~)<em>x</em> + <em>b</em> – <em>s</em><sup>2</sup><em>x</em><sub>1</sub><sup>2</sup> + 2<em>sx</em><sub>1</sub><em>y</em><sub>1</sub> – <em>y</em><sub>1</sub><sup>2</sup> = 0</li>
</ul>
<div class="paragraph">
<p>There&#8217;s a result from what&#8217;s called <a href="http://bit.ly/2HXJtMp">Vieta&#8217;s formula</a>, which states that the coefficients have to equal each other if the roots are the same.
The first coefficient that&#8217;s interesting is the coefficient in front of <em>x</em><sup>2</sup>:</p>
</div>
<ul class="simplelist">
<li>–<em>s</em><sup>2</sup> = –(<em>x</em><sub>1</sub> + <em>x</em><sub>2</sub> + <em>x</em><sub>3</sub>)</li>
</ul>
<div class="paragraph">
<p>We can use this to derive the formula for <em>x</em><sub>3</sub>:</p>
</div>
<ul class="simplelist">
<li><em>x</em><sub>3</sub> = <em>s</em><sup>2</sup> – <em>x</em><sub>1</sub> – <em>x</em><sub>2</sub></li>
</ul>
<div class="paragraph">
<p>We can plug this into the formula for the line above:</p>
</div>
<ul class="simplelist">
<li><em>y</em> = <em>s</em>(<em>x</em> – <em>x</em><sub>1</sub>) + <em>y</em><sub>1</sub></li>
</ul>
<div class="paragraph">
<p>But we have to reflect over the x-axis, so the right side has to be negated:</p>
</div>
<ul class="simplelist">
<li><em>y</em><sub>3</sub> = –(<em>s</em>(<em>x</em><sub>3</sub> – <em>x</em><sub>1</sub>) + <em>y</em><sub>1</sub>) = <em>s</em>(<em>x</em><sub>1</sub> – <em>x</em><sub>3</sub>) – <em>y</em><sub>1</sub></li>
</ul>
<div class="paragraph">
<p>QED.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_2">Exercise 4</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> + 7, what is (2,5) + (–1,–1)?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coding_point_addition_for_when_x1x2">Coding Point Addition for When x<sub>1</sub>≠x<sub>2</sub></h3>
<div class="paragraph">
<p>We now code this into our library.
That means we have to adjust the <code><em>add</em></code> method to handle the case where <em>x</em><sub>1</sub>≠<em>x</em><sub>2</sub>.
We have the formulas:</p>
</div>
<ul class="simplelist">
<li><em>s</em> = (<em>y</em><sub>2</sub> – <em>y</em><sub>1</sub>)/(<em>x</em><sub>2</sub> – <em>x</em><sub>1</sub>)</li>
<li><em>x</em><sub>3</sub> = <em>s</em><sup>2</sup> – <em>x</em><sub>1</sub> – <em>x</em><sub>2</sub></li>
<li><em>y</em><sub>3</sub> = <em>s</em>(<em>x</em><sub>1</sub> – <em>x</em><sub>3</sub>) – <em>y</em><sub>1</sub></li>
</ul>
<div class="paragraph">
<p>At the end of the method, we return an instance of the class <code>Point</code> using <code>self.<em>class</em></code> to make subclassing easier.</p>
</div>
<div class="sect3">
<h4 id="_exercise_5_2">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code><em>add</em></code> method where <em>x</em><sub>1</sub> ≠ <em>x</em><sub>2</sub>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_point_addition_for_when_p1_p2">Point Addition for When P<sub>1</sub> = P<sub>2</sub></h3>
<div class="paragraph">
<p>When the <em>x</em> coordinates are the same and the <em>y</em> coordinate is different, we have the situation where the points are opposite each other over the x-axis.
We know that this means:</p>
</div>
<ul class="simplelist">
<li><em>P</em><sub>1</sub> = –<em>P</em><sub>2</sub> or <em>P</em><sub>1</sub> + <em>P</em><sub>2</sub> = <em>I</em></li>
</ul>
<div class="paragraph">
<p>We&#8217;ve already handled this in Exercise 3.</p>
</div>
<div class="paragraph">
<p>What happens when <em>P</em><sub>1</sub> = <em>P</em><sub>2</sub>?
Visually, we have to calculate the line that&#8217;s <em>tangent</em> to the curve at <em>P</em><sub>1</sub> and find the point at which the line intersects the curve.
The situation looks like <a href="#line_thats_tangent_to_the_curve">Line that&#8217;s tangent to the curve</a>, as we saw before.</p>
</div>
<div id="line_thats_tangent_to_the_curve" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0213.png" alt="Tangent Line">
</div>
<div class="title">Figure 25. Line that&#8217;s tangent to the curve</div>
</div>
<div class="paragraph">
<p>Once again, we&#8217;ll find the slope of the tangent point:</p>
</div>
<ul class="simplelist">
<li><em>P</em><sub>1</sub> = (<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>), <em>P</em><sub>3</sub> = (<em>x</em><sub>3</sub>,<em>y</em><sub>3</sub>)</li>
<li><em>P</em><sub>1</sub> + <em>P</em><sub>1</sub> = <em>P</em><sub>3</sub></li>
<li><em>s</em> = (3<em>x</em><sub>1</sub><sup>2</sup> + <em>a</em>)/(2<em>y</em><sub>1</sub>)</li>
</ul>
<div class="paragraph">
<p>The rest of the formula goes through as before, except <em>x</em><sub>1</sub> = <em>x</em><sub>2</sub>, so we can combine them:</p>
</div>
<ul class="simplelist">
<li><em>x</em><sub>3</sub> = <em>s</em><sup>2</sup> – 2<em>x</em><sub>1</sub></li>
<li><em>y</em><sub>3</sub> = <em>s</em>(<em>x</em><sub>1</sub> – <em>x</em><sub>3</sub>) – <em>y</em><sub>1</sub></li>
</ul>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Deriving the Slope Tangent to the Curve</div>
<div class="paragraph">
<p>We can derive the slope of the tangent line using some slightly more advanced math: calculus.
We know that the slope at a given point is:</p>
</div>
<ul class="simplelist">
<li><em>dy</em>/<em>dx</em></li>
</ul>
<div class="paragraph">
<p>To get this, we need to take the derivative of both sides of the elliptic curve equation:</p>
</div>
<ul class="simplelist">
<li><em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em></li>
</ul>
<div class="paragraph">
<p>Taking the derivative of both sides, we get:</p>
</div>
<ul class="simplelist">
<li>2<em>y dy</em> = (3<em>x</em><sup>2</sup> + <em>a</em>) <em>dx</em></li>
</ul>
<div class="paragraph">
<p>Solving for <em>dy</em>/<em>dx</em>, we get:</p>
</div>
<ul class="simplelist">
<li><em>dy</em>/<em>dx</em> = (3<em>x</em><sup>2</sup> + <em>a</em>)/(2<em>y</em>)</li>
</ul>
<div class="paragraph">
<p>That&#8217;s how we arrive at the slope formula.
The rest of the results from the point addition formula derivation hold.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_exercise_6_2">Exercise 6</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> + 7, what is (–1,–1) + (–1,–1)?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coding_point_addition_for_when_p1_p2">Coding Point Addition for When P<sub>1</sub> = P<sub>2</sub></h3>
<div class="paragraph">
<p>We adjust the <code><em>add</em></code> method to account for this particular case.
We have the formulas, and now we implement them:</p>
</div>
<ul class="simplelist">
<li><em>s</em> = (3<em>x</em><sub>1</sub><sup>2</sup> + <em>a</em>)/(2<em>y</em><sub>1</sub>)</li>
<li><em>x</em><sub>3</sub> = <em>s</em><sup>2</sup> – 2<em>x</em><sub>1</sub></li>
<li><em>y</em><sub>3</sub> = <em>s</em>(<em>x</em><sub>1</sub> – <em>x</em><sub>3</sub>) – <em>y</em><sub>1</sub></li>
</ul>
<div class="sect3">
<h4 id="_exercise_7_2">Exercise 7</h4>
<div class="paragraph">
<p>Write the <code><em>add</em></code> method when <em>P</em><sub>1</sub> = <em>P</em><sub>2</sub>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coding_one_more_exception">Coding One More Exception</h3>
<div class="paragraph">
<p>There is one more exception, and this involves the case where the tangent line is vertical (<a href="#vertical_and_tangent_to_the_curve">Vertical and tangent to the curve</a>).</p>
</div>
<div id="vertical_and_tangent_to_the_curve" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0219.png" alt="Tangent Vertical">
</div>
<div class="title">Figure 26. Vertical and tangent to the curve</div>
</div>
<div class="paragraph">
<p>This can only happen if <em>P</em><sub>1</sub> = <em>P</em><sub>2</sub> and the <em>y</em> coordinate is 0, in which case the slope calculation will end up with a 0 in the denominator.</p>
</div>
<div class="paragraph">
<p>We handle this with a special case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:
    ...
    def __add__(self, other):
    	...
	if self == other and self.y == 0 * self.x:  # <b class="conum">(1)</b>
	    return self.__class__(None, None, self.a, self.b)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If the two points are equal and the <em>y</em> coordinate is 0, we return the point at <span class="keep-together">infinity</span>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_2">Conclusion</h3>
<div class="paragraph">
<p>We&#8217;ve covered what elliptic curves are, how they work, and how to do point addition.
We&#8217;ll now combine the concepts from the first two chapters to learn elliptic curve cryptography in <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>The previous two chapters covered some fundamental math.
We learned how finite fields work and what an elliptic curve is.
In this chapter, we&#8217;re going to combine the two concepts to learn elliptic curve cryptography.
Specifically, we&#8217;re going to build the primitives needed to sign and verify messages, which is at the heart of what Bitcoin does.</p>
</div>
<div class="sect2">
<h3 id="_elliptic_curves_over_reals">Elliptic Curves over Reals</h3>
<div class="paragraph">
<p>We discussed in <a href="#chapter_elliptic_curves">Elliptic Curves</a> what an elliptic curve looks like visually because we were plotting the curve over <em>real</em> numbers.
Specifically, it&#8217;s not just integers or even rational numbers, but all real numbers.
Pi, <em>sqrt</em>(2), <em>e</em>+7th root of 19, and the like are all real numbers.</p>
</div>
<div class="paragraph">
<p>This worked because real numbers are also a field.
Unlike a <em>finite</em> field, there are an <em>infinite</em> number of real numbers, but otherwise the same properties hold:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If <em>a</em> and <em>b</em> are in the set, <em>a</em> + <em>b</em> and <em>a</em> ⋅ <em>b</em> are in the set.</p>
</li>
<li>
<p>0 exists and has the property <em>a</em> + 0 = <em>a</em>.</p>
</li>
<li>
<p>1 exists and has the property <em>a</em> ⋅ 1 = <em>a</em>.</p>
</li>
<li>
<p>If <em>a</em> is in the set, <em>–a</em> is in the set, which is defined as the value that makes <em>a</em> + (–<em>a</em>) = 0.</p>
</li>
<li>
<p>If <em>a</em> is in the set and is not 0, <em>a</em><sup>–1</sup> is in the set, which is defined as the value that makes <em>a</em> ⋅ <em>a</em><sup>–1</sup> = 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Clearly, all of these are true: normal addition and multiplication apply for the first part, the additive and multiplicative identities 0 and 1 exist, –<em>x</em> is the additive inverse, and 1/<em>x</em> is the multiplicative inverse.</p>
</div>
<div class="paragraph">
<p>Real numbers are easy to plot on a graph.
For example, <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 can be plotted like <a href="#secp256k1_over_real_numbers">secp256k1 over real numbers</a>.</p>
</div>
<div id="secp256k1_over_real_numbers" class="imageblock">
<div class="content">
<img src="./images/prbc_0209.png" alt="secp256k1 Curve">
</div>
<div class="title">Figure 27. secp256k1 over real numbers</div>
</div>
<div class="paragraph">
<p>It turns out we can use the point addition equations over any field, including the finite fields we learned about in <a href="#chapter_finite_fields">Finite Fields</a>.
The only difference is that we have to use the addition/subtraction/multiplication/division as defined in <a href="#chapter_finite_fields">Finite Fields</a>, not the "normal" versions that the real numbers use.</p>
</div>
</div>
<div class="sect2">
<h3 id="_elliptic_curves_over_finite_fields">Elliptic Curves over Finite Fields</h3>
<div class="paragraph">
<p>So what does an elliptic curve over a finite field look like?
Let&#8217;s look at the equation <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>103</sub>.
We can verify that the point (17,64) is on the curve by calculating both sides of the equation:</p>
</div>
<ul class="simplelist">
<li><em>y</em><sup>2</sup> = 64<sup>2</sup> % 103 = 79</li>
<li><em>x</em><sup>3</sup> + 7 = (17<sup>3</sup>+7) % 103 = 79</li>
</ul>
<div class="paragraph">
<p>We&#8217;ve verified that the point is on the curve using finite field math.</p>
</div>
<div class="paragraph pagebreak-before">
<p>Because we&#8217;re evaluating the equation over a finite field, the plot of the equation looks vastly different (<a href="#elliptic_curve_over_a_finite_field">Elliptic curve over a finite field</a>).</p>
</div>
<div id="elliptic_curve_over_a_finite_field" class="imageblock">
<div class="content">
<img src="./images/prbc_0302.png" alt="Elliptic curve over a finite field">
</div>
<div class="title">Figure 28. Elliptic curve over a finite field</div>
</div>
<div class="paragraph">
<p>As you can see, it&#8217;s very much a scattershot of points and there&#8217;s no smooth curve here.
This is not surprising since the points are discrete.
About the only pattern is that the curve is symmetric right around the middle, because of the <em>y</em><sup>2</sup> term.
The graph is not symmetric over the x-axis as in the curve over reals, but about halfway up the y-axis due to there not being negative numbers in a finite field.</p>
</div>
<div class="paragraph">
<p>What&#8217;s amazing is that we can use the same point addition equations with the addition, subtraction, multiplication, division, and exponentiation as we defined them for finite fields, and everything still works.
This may seem surprising, but abstract math has regularities like this despite being different from the traditional modes of calculation you may be familiar with.</p>
</div>
<div class="sect3">
<h4 id="_exercise_1_3">Exercise 1</h4>
<div class="paragraph">
<p>Evaluate whether these points are on the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>:</p>
</div>
<ul class="simplelist">
<li>(192,105), (17,56), (200,119), (1,193), (42,99)</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_coding_elliptic_curves_over_finite_fields">Coding Elliptic Curves over Finite Fields</h3>
<div class="paragraph">
<p>Because we defined an elliptic curve point and defined the <code>+</code>, <code>-</code> ,<code>*</code> and <code>/</code> operators for finite fields, we can combine the two classes to create elliptic curve points over a finite field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement, Point
&gt;&gt;&gt; a = FieldElement(num=0, prime=223)
&gt;&gt;&gt; b = FieldElement(num=7, prime=223)
&gt;&gt;&gt; x = FieldElement(num=192, prime=223)
&gt;&gt;&gt; y = FieldElement(num=105, prime=223)
&gt;&gt;&gt; p1 = Point(x, y, a, b)
&gt;&gt;&gt; print(p1)
Point(192,105)_0_7 FieldElement(223)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When initializing <code>Point</code>, we will run through this part of the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:

    def __init__(self, x, y, a, b):
        self.a = a
        self.b = b
        self.x = x
        self.y = y
        if self.x is None and self.y is None:
            return
        if self.y**2 != self.x**3 + a * x + b:
            raise ValueError('({}, {}) is not on the curve'.format(x, y))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The addition (<code>+</code>), multiplication (<code><strong></code>), exponentiation (<code></strong>*</code>), and not equals (<code>!=</code>) operators here use the <code><em>add</em></code>, <code><em>mul</em></code>, <code><em>pow</em></code>, and <code><em>ne</em></code> methods from <code>FiniteField</code>, respectively, and <em>not</em> the integer equivalents.
Being able to do the same equation but with different definitions for the basic arithmetic operators is how we construct an elliptic curve cryptography library.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve already coded the two classes that we need to implement elliptic curve points over a finite field.
However, to check our work, it will be useful to create a test suite.
We will do this using the results of Exercise 1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class ECCTest(TestCase):

    def test_on_curve(self):
        prime = 223
        a = FieldElement(0, prime)
        b = FieldElement(7, prime)
        valid_points = ((192, 105), (17, 56), (1, 193))
        invalid_points = ((200, 119), (42, 99))
        for x_raw, y_raw in valid_points:
            x = FieldElement(x_raw, prime)
            y = FieldElement(y_raw, prime)
            Point(x, y, a, b)  # <b class="conum">(1)</b>
        for x_raw, y_raw in invalid_points:
            x = FieldElement(x_raw, prime)
            y = FieldElement(y_raw, prime)
            with self.assertRaises(ValueError):
                Point(x, y, a, b)  # <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We pass in <code>FieldElement</code> objects to the <code>Point</code> class for initialization.
This will, in turn, use all the overloaded math operations in <code>FieldElement</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can now run this test like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; import ecc
&gt;&gt;&gt; from helper import run  # <b class="conum">(1)</b>
&gt;&gt;&gt; run(ecc.ECCTest('test_on_curve'))
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>helper</code> is a module with some very useful utility functions, including the ability to run unit tests individually.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_point_addition_over_finite_fields">Point Addition over Finite Fields</h3>
<div class="paragraph">
<p>We can use all the same equations over finite fields, including the linear equation:</p>
</div>
<ul class="simplelist">
<li><em>y</em> = <em>mx</em> + <em>b</em></li>
</ul>
<div class="paragraph">
<p>It turns out that a "line" in a finite field is not quite what you&#8217;d expect (<a href="#line_over_a_finite_field">Line over a finite field</a>).</p>
</div>
<div id="line_over_a_finite_field" class="imageblock">
<div class="content">
<img src="./images/prbc_0303.png" alt="Line over a finite field">
</div>
<div class="title">Figure 29. Line over a finite field</div>
</div>
<div class="paragraph">
<p>The equation nevertheless works, and we can calculate what <em>y</em> should be for a given <em>x</em>.</p>
</div>
<div class="paragraph">
<p>Remarkably, point addition works over finite fields as well.
This is because elliptic curve point addition works over all fields!
The same exact formulas we used to calculate point addition over reals work over finite fields.
Specifically, when <em>x</em><sub>1</sub> ≠ <em>x</em><sub>2</sub>:</p>
</div>
<ul class="simplelist">
<li><em>P</em><sub>1</sub> = (<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>), <em>P</em><sub>2</sub> = (<em>x</em><sub>2</sub>,<em>y</em><sub>2</sub>), <em>P</em><sub>3</sub> = (<em>x</em><sub>3</sub>,<em>y</em><sub>3</sub>)</li>
<li><em>P</em><sub>1</sub> + <em>P</em><sub>2</sub> = <em>P</em><sub>3</sub></li>
<li><em>s</em> = (<em>y</em><sub>2</sub> – <em>y</em><sub>1</sub>)/(<em>x</em><sub>2</sub> – <em>x</em><sub>1</sub>)</li>
<li><em>x</em><sub>3</sub> = <em>s</em><sup>2</sup> – <em>x</em><sub>1</sub> – <em>x</em><sub>2</sub></li>
<li><em>y</em><sub>3</sub> = <em>s</em>(<em>x</em><sub>1</sub> – <em>x</em><sub>3</sub>) – <em>y</em><sub>1</sub></li>
</ul>
<div class="paragraph">
<p>And when <em>P</em><sub>1</sub> = <em>P</em><sub>2</sub>:</p>
</div>
<ul class="simplelist">
<li><em>P</em><sub>1</sub> = (<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>), <em>P</em><sub>3</sub> = (<em>x</em><sub>3</sub>,<em>y</em><sub>3</sub>)</li>
<li><em>P</em><sub>1</sub> + <em>P</em><sub>1</sub> = <em>P</em><sub>3</sub></li>
<li><em>s</em> = (3<em>x</em><sub>1</sub><sup>2</sup> + <em>a</em>)/(2<em>y</em><sub>1</sub>)</li>
<li><em>x</em><sub>3</sub> = <em>s</em><sup>2</sup> – 2<em>x</em><sub>1</sub></li>
<li><em>y</em><sub>3</sub> = <em>s</em>(<em>x</em><sub>1</sub> – <em>x</em><sub>3</sub>) – <em>y</em><sub>1</sub></li>
</ul>
<div class="paragraph">
<p>All of the equations for elliptic curves work over finite fields, which sets us up to create some cryptographic primitives.</p>
</div>
</div>
<div class="sect2">
<h3 id="_coding_point_addition_over_finite_fields">Coding Point Addition over Finite Fields</h3>
<div class="paragraph">
<p>Because we coded FieldElement in such a way as to define <code><em>add</em></code>, <code><em>sub</em></code>, <code><em>mul</em></code>, <code><em>truediv</em></code>, <code><em>pow</em></code>, <code><em>eq</em></code>, and <code><em>ne</em></code>, we can simply initialize <code>Point</code> with <code>FieldElement</code> objects and point addition will work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement, Point
&gt;&gt;&gt; prime = 223
&gt;&gt;&gt; a = FieldElement(num=0, prime=prime)
&gt;&gt;&gt; b = FieldElement(num=7, prime=prime)
&gt;&gt;&gt; x1 = FieldElement(num=192, prime=prime)
&gt;&gt;&gt; y1 = FieldElement(num=105, prime=prime)
&gt;&gt;&gt; x2 = FieldElement(num=17, prime=prime)
&gt;&gt;&gt; y2 = FieldElement(num=56, prime=prime)
&gt;&gt;&gt; p1 = Point(x1, y1, a, b)
&gt;&gt;&gt; p2 = Point(x2, y2, a, b)
&gt;&gt;&gt; print(p1+p2)
Point(170,142)_0_7 FieldElement(223)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_3">Exercise 2</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>, find:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(170,142) + (60,139)</p>
</li>
<li>
<p>(47,71) + (17,56)</p>
</li>
<li>
<p>(143,98) + (76,66)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_3">Exercise 3</h4>
<div class="paragraph">
<p>Extend <code>ECCTest</code> to test for the additions from the previous exercise. Call this <code>test_add</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scalar_multiplication_for_elliptic_curves">Scalar Multiplication for Elliptic Curves</h3>
<div class="paragraph">
<p>Because we can add a point to itself, we can introduce some new notation:</p>
</div>
<ul class="simplelist">
<li>(170,142) + (170,142) = 2 ⋅ (170,142)</li>
</ul>
<div class="paragraph">
<p>Similarly, because we have associativity, we can actually add the point again:</p>
</div>
<ul class="simplelist">
<li>2 ⋅ (170,142) + (170,142) = 3 ⋅ (170, 142)</li>
</ul>
<div class="paragraph">
<p>We can do this as many times as we want.
This is what we call <em>scalar multiplication</em>.
That is, we have a <em>scalar</em> number in front of the point.
We can do this because we have defined point addition and point addition is associative.</p>
</div>
<div class="paragraph">
<p>One property of scalar multiplication is that it&#8217;s really hard to predict without calculating (see <a href="#scalar_multiplication_results_for_y_2_x_3_7">Scalar multiplication results for y<sup>2</sup> = x<sup>3</sup> + 7 over F<sub>223</sub> for point (170,142)</a>).</p>
</div>
<div id="scalar_multiplication_results_for_y_2_x_3_7" class="imageblock">
<div class="content">
<img src="./images/prbc_0304.png" alt="Scalar Multiplication Results">
</div>
<div class="title">Figure 30. Scalar multiplication results for y<sup>2</sup> = x<sup>3</sup> + 7 over F<sub>223</sub> for point (170,142)</div>
</div>
<div class="paragraph">
<p>Each point is labeled by how many times we&#8217;ve added the point.
You can see that this is a complete scattershot.
This is because point addition is nonlinear and not easy to calculate.
Performing scalar multiplication is straightforward, but doing the opposite, point division, is not.</p>
</div>
<div class="paragraph">
<p>This is called the <em>discrete log problem</em> and is the basis of elliptic curve cryptography.</p>
</div>
<div class="paragraph">
<p>Another property of scalar multiplication is that at a certain multiple, we get to the point at infinity (remember, the point at infinity is the additive identity or 0).
If we imagine a point <em>G</em> and scalar-multiply until we get the point at infinity, we end up with a set:</p>
</div>
<ul class="simplelist">
<li>{ <em>G</em>, 2<em>G</em>, 3<em>G</em>, 4<em>G</em>, ... <em>nG</em> } where <em>nG</em> = 0</li>
</ul>
<div class="paragraph">
<p>It turns out that this set is called a <em>group</em>, and because <em>n</em> is finite, we have a <em>finite group</em> (or more specifically, a <em>finite cyclic group</em>).
Groups are interesting mathematically because they behave well with respect to addition:</p>
</div>
<ul class="simplelist">
<li><em>G</em> + 4<em>G</em> = 5<em>G</em> or <em>aG</em> + <em>bG</em> = (<em>a</em> + <em>b</em>)<em>G</em></li>
</ul>
<div class="paragraph">
<p>When we combine the fact that scalar multiplication is easy to do in one direction but hard in the other and the mathematical properties of a group, we have exactly what we need for elliptic curve cryptography.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Why Is This Called the Discrete Log Problem?</div>
<div class="paragraph">
<p>You may be wondering why the problem of reversing scalar <em>multiplication</em> is referred to as the discrete <em>log</em> problem.</p>
</div>
<div class="paragraph">
<p>We called the operation between the points "addition," but we could easily have called it a point "operation."
Typically, a new operation that you define in math is denoted with the dot operator (⋅).
The dot operator is also used for multiplication, and it sometimes helps to think that way:</p>
</div>
<ul class="simplelist">
<li><em>P</em><sub>1</sub> ⋅ <em>P</em><sub>2</sub> = <em>P</em><sub>3</sub></li>
</ul>
<div class="paragraph">
<p>When you do lots of multiplying, that&#8217;s the same as exponentiation.
Scalar multiplication when we called it "point addition" becomes scalar exponentiation when thinking "point multiplication":</p>
</div>
<ul class="simplelist">
<li><em>P</em><sup>7</sup> = <em>Q</em></li>
</ul>
<div class="paragraph">
<p>The discrete log problem in this context is the ability to reverse this equation, which ends up being:</p>
</div>
<ul class="simplelist">
<li>log<sub>P</sub><em>Q</em> = 7</li>
</ul>
<div class="paragraph">
<p>The log equation on the left has no analytically calculable algorithm.
That is, there is no known formula that you can plug in to get the answer generally.
This is all a bit confusing, but it&#8217;s fair to say that we could call the problem the "discrete point division" problem instead of the discrete log problem.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_3">Exercise 4</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>, find:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2 ⋅ (192,105)</p>
</li>
<li>
<p>2 ⋅ (143,98)</p>
</li>
<li>
<p>2 ⋅ (47,71)</p>
</li>
<li>
<p>4 ⋅ (47,71)</p>
</li>
<li>
<p>8 ⋅ (47,71)</p>
</li>
<li>
<p>21 ⋅ (47,71)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scalar_multiplication_redux">Scalar Multiplication Redux</h3>
<div class="paragraph">
<p>Scalar multiplication is adding the same point to itself some number of times.
The key to making scalar multiplication into public key cryptography is using the fact that scalar multiplication on elliptic curves is very hard to reverse.
Note the previous exercise.
Most likely, you calculated the point <em>s</em> ⋅ (47,71) in <em>F</em><sub>223</sub> for <em>s</em> from 1 until 21.
Here are the results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement, Point
&gt;&gt;&gt; prime = 223
&gt;&gt;&gt; a = FieldElement(0, prime)
&gt;&gt;&gt; b = FieldElement(7, prime)
&gt;&gt;&gt; x = FieldElement(47, prime)
&gt;&gt;&gt; y = FieldElement(71, prime)
&gt;&gt;&gt; p = Point(x, y, a, b)
&gt;&gt;&gt; for s in range(1,21):
...     result = s*p
...     print('{}*(47,71)=({},{})'.format(s,result.x.num,result.y.num))
1*(47,71)=(47,71)
2*(47,71)=(36,111)
3*(47,71)=(15,137)
4*(47,71)=(194,51)
5*(47,71)=(126,96)
6*(47,71)=(139,137)
7*(47,71)=(92,47)
8*(47,71)=(116,55)
9*(47,71)=(69,86)
10*(47,71)=(154,150)
11*(47,71)=(154,73)
12*(47,71)=(69,137)
13*(47,71)=(116,168)
14*(47,71)=(92,176)
15*(47,71)=(139,86)
16*(47,71)=(126,127)
17*(47,71)=(194,172)
18*(47,71)=(15,86)
19*(47,71)=(36,112)
20*(47,71)=(47,152)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you look closely at the numbers, there&#8217;s no real discernible pattern to the scalar multiplication.
The <em>x</em> coordinates don&#8217;t always increase or decrease, and neither do the <em>y</em> coordinates.
About the only pattern is that between 10 and 11, the <em>x</em> coordinates are equal (10 and 11 have the same <em>x</em>, as do 9 and 12, 8 and 13, and so on).
This is due to the fact that 21 ⋅ (47,71) = 0.</p>
</div>
<div class="paragraph pagebreak-before">
<p>Scalar multiplication looks really random, and that&#8217;s what gives this equation <em>asymmetry</em>.
An <em>asymmetric</em> problem is one that&#8217;s easy to calculate in one direction, but hard to reverse.
For example, it&#8217;s easy enough to calculate 12 ⋅ (47,71).
But if we were presented with this:</p>
</div>
<ul class="simplelist">
<li><em>s</em> ⋅ (47,71) = (194,172)</li>
</ul>
<div class="paragraph">
<p>would we be able to solve for <em>s</em>?
We can look up the results shown earlier, but that&#8217;s because we have a small group.
We&#8217;ll see in <a href="#definingCurveBC">Defining the Curve for Bitcoin</a> that when we have numbers that are a lot larger, discrete log becomes an intractable problem.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mathematical_groups">Mathematical Groups</h3>
<div class="paragraph">
<p>The preceding math (finite fields, elliptic curves, combining the two) was really to bring us to this point.
What we actually want to generate for the purposes of public key cryptography are finite cyclic groups, and it turns out that if we take a generator point from an elliptic curve over a finite field, we can generate a finite cyclic group.</p>
</div>
<div class="paragraph">
<p>Unlike fields, groups have only a single operation.
In our case, point addition is the operation.
Groups also have a few other properties, like closure, invertibility, commutativity, and associativity.
Lastly, we need the identity.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at each property, starting with that last one.</p>
</div>
<div class="sect3">
<h4 id="_identity">Identity</h4>
<div class="paragraph">
<p>If you haven&#8217;t guessed by now, the identity is defined as the point at infinity, which is guaranteed to be in the group since we generate the group when we get to the point at infinity.
So:</p>
</div>
<ul class="simplelist">
<li>0 + <em>A</em> = <em>A</em></li>
</ul>
<div class="paragraph">
<p>We call 0 the point at infinity because visually, it&#8217;s the point that exists to help the math work out (<a href="#vertical_line_intersects_a_third_time">Vertical line "intersects" a third time at the point at infinity</a>).</p>
</div>
<div id="vertical_line_intersects_a_third_time" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0212.png" alt="Vertical Line">
</div>
<div class="title">Figure 31. Vertical line "intersects" a third time at the point at infinity</div>
</div>
</div>
<div class="sect3">
<h4 id="_closure">Closure</h4>
<div class="paragraph">
<p>This is perhaps the easiest property to prove since we generated the group in the first place by adding <em>G</em> over and over.
Thus, if we have two different elements that look like this:</p>
</div>
<ul class="simplelist">
<li><em>aG</em> + <em>bG</em></li>
</ul>
<div class="paragraph">
<p>We know that the result is going to be:</p>
</div>
<ul class="simplelist">
<li>(<em>a</em> + <em>b</em>)<em>G</em></li>
</ul>
<div class="paragraph">
<p>How do we know if this element is in the group?
If <em>a+b &lt; n</em> (where <em>n</em> is the order of the group), then we know it&#8217;s in the group by definition.
If <em>a</em>+<em>b</em> &gt;= <em>n</em>, then we know <em>a</em> &lt; <em>n</em> and <em>b</em> &lt; <em>n</em>, so <em>a</em>+<em>b</em> &lt; 2<em>n</em>, so <em>a</em>+<em>b</em>–<em>n</em> &lt; <em>n</em>:</p>
</div>
<ul class="simplelist">
<li>(<em>a</em> + <em>b</em> – <em>n</em>)<em>G</em> = <em>aG</em> + <em>bG</em> – <em>nG</em> = <em>aG</em> + <em>bG</em> – 0 = <em>aG</em> + <em>bG</em></li>
</ul>
<div class="paragraph">
<p>More generally, (<em>a</em> + <em>b</em>)<em>G</em> = ((<em>a</em> + <em>b</em>) % <em>n</em>)<em>G</em>, where <em>n</em> is the order of the group.</p>
</div>
<div class="paragraph">
<p>So we know that this element is in the group, proving closure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_invertibility">Invertibility</h4>
<div class="paragraph">
<p>Invertibility is easy to depict (<a href="#each_point_is_invertible_by_taking_the_reflection_over_the_x_axis">Each point is invertible by taking the reflection over the x-axis</a>).</p>
</div>
<div id="each_point_is_invertible_by_taking_the_reflection_over_the_x_axis" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0212.png" alt="Vertical Line">
</div>
<div class="title">Figure 32. Each point is invertible by taking the reflection over the x-axis</div>
</div>
<div class="paragraph">
<p>Mathematically, we know that if <em>aG</em> is in the group, (<em>n</em> – <em>a</em>)<em>G</em> is also in the group.
You can add them together to get <em>aG</em> + (<em>n</em> – <em>a</em>)<em>G</em> = (<em>a</em> + <em>n</em> – <em>a</em>)<em>G</em> = <em>nG</em> = 0.</p>
</div>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_commutativity">Commutativity</h4>
<div class="paragraph">
<p>We know from point addition that <em>A</em> + <em>B</em> = <em>B</em> + <em>A</em> (<a href="#the_line_through_the_points_doesnt_change">The line through the points doesn&#8217;t change</a>).</p>
</div>
<div id="the_line_through_the_points_doesnt_change" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0214.png" alt="Point addition">
</div>
<div class="title">Figure 33. The line through the points doesn&#8217;t change</div>
</div>
<div class="paragraph">
<p>This means that <em>aG</em> + <em>bG</em> = <em>bG</em> + <em>aG</em>, which proves commutativity.</p>
</div>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_associativity">Associativity</h4>
<div class="paragraph">
<p>We know from point addition that <em>A</em> + (<em>B</em> + <em>C</em>) = (<em>A</em> + <em>B</em>) + <em>C</em> (see Figures <a data-type="xref" data-xrefstyle="select:labelnumber"  href="#a_b_c_case_one">#a_b_c_case_one</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#a_b_c_case_two">#a_b_c_case_two</a>).</p>
</div>
<div id="a_b_c_case_one" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0216.png" alt="Case 1">
</div>
<div class="title">Figure 34. (A + B) + C: A + B is computed first before C is added</div>
</div>
<div id="a_b_c_case_two" class="imageblock width-75">
<div class="content">
<img src="./images/prbc_0217.png" alt="Case 2">
</div>
<div class="title">Figure 35. A + (B + C): B + C is added first before adding A (note that this results in the same point as in <a href="#a_b_c_case_one">(A + B) + C: A + B is computed first before C is added</a>)</div>
</div>
<div class="paragraph">
<p>Thus, <em>aG</em> + (<em>bG</em> + <em>cG</em>) = (<em>aG</em> + <em>bG</em>) + <em>cG</em>, proving associativity.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_3">Exercise 5</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>, find the order of the group generated by (15,86).</p>
</div>
</div>
</div>
<div class="sect2 pagebreak-before">
<h3 id="_coding_scalar_multiplication">Coding Scalar Multiplication</h3>
<div class="paragraph">
<p>What we&#8217;re trying to do with Exercise 5 is this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement, Point
&gt;&gt;&gt; prime = 223
&gt;&gt;&gt; a = FieldElement(0, prime)
&gt;&gt;&gt; b = FieldElement(7, prime)
&gt;&gt;&gt; x = FieldElement(15, prime)
&gt;&gt;&gt; y = FieldElement(86, prime)
&gt;&gt;&gt; p = Point(x, y, a, b)
&gt;&gt;&gt; print(7*p)
Point(infinity)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We want to be able to scalar-multiply the point with some number.
Thankfully, there&#8217;s a method in Python called <code><em>rmul</em></code> that can be used to override the front multiplication.
A naive implementation looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:
    ...
    def __rmul__(self, coefficient):
        product = self.__class__(None, None, self.a, self.b) # <b class="conum">(1)</b>
        for _ in range(coefficient): # <b class="conum">(2)</b>
            product += self
        return product</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We start the <code>product</code> at 0, which in the case of point addition is the point at infinity.</p>
</li>
<li>
<p>We loop <code>coefficient</code> times and add the point each time.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is fine for small coefficients, but what if we have a very large coefficient—that is, a number that&#8217;s so large that we won&#8217;t be able to get out of this loop in a reasonable amount of time?
For example, a coefficient of 1 trillion is going to take a really long time.</p>
</div>
<div class="paragraph">
<p>There&#8217;s a cool technique called <em>binary expansion</em> that allows us to perform multiplication in log<sub>2</sub>(<em>n</em>) loops, which dramatically reduces the calculation time for large numbers.
For example, 1 trillion is 40 bits in binary, so we only have to loop 40 times for a number that&#8217;s generally considered very large:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:
    ...
    def __rmul__(self, coefficient):
        coef = coefficient
        current = self  # <b class="conum">(1)</b>
        result = self.__class__(None, None, self.a, self.b)  # <b class="conum">(2)</b>
        while coef:
            if coef &amp; 1:  # <b class="conum">(3)</b>
                result += current
            current += current  # <b class="conum">(4)</b>
            coef &gt;&gt;= 1  # <b class="conum">(5)</b>
        return result</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>current</code> represents the point that&#8217;s at the current bit.
The first time through the loop it represents 1 &#xd7; self; the second time it will be 2 &#xd7; self, the third time 4 &#xd7; self, then 8 &#xd7; self, and so on.
We double the point each time.
In binary the coefficients are 1, 10, 100, 1000, 10000, etc.</p>
</li>
<li>
<p>We start the result at 0, or the point at infinity.</p>
</li>
<li>
<p>We are looking at whether the rightmost bit is a 1.
If it is, then we add the value of the current bit.</p>
</li>
<li>
<p>We need to double the point until we&#8217;re past how big the coefficient can be.</p>
</li>
<li>
<p>We bit-shift the coefficient to the right.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is an advanced technique. If you don&#8217;t understand bitwise operators, think of representing the coefficient in binary and only adding the point where there are 1&#8217;s.</p>
</div>
<div class="paragraph">
<p>With <code><em>add</em></code> and <code><em>rmul</em></code>, we can start defining some more complicated elliptic curves.</p>
</div>
</div>
<div class="sect2">
<h3 id="definingCurveBC">Defining the Curve for Bitcoin</h3>
<div class="paragraph">
<p>While we&#8217;ve been using relatively small primes for the sake of examples, we are not restricted to such small numbers.
Small primes mean that we can use a computer to search through the entire group.
If the group has a size of 301, the computer can easily do 301 computations to reverse scalar multiplication or break discrete log.</p>
</div>
<div class="paragraph">
<p>But what if we made the prime larger?
It turns out that we can choose much larger primes than we&#8217;ve been using.
The security of elliptic curve cryptography depends on computers <em>not</em> being able to go through an appreciable fraction of the group.</p>
</div>
<div class="paragraph">
<p>An elliptic curve for public key cryptography is defined with the following <span class="keep-together">parameters</span>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We specify the <em>a</em> and <em>b</em> of the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>.</p>
</li>
<li>
<p>We specify the prime of the finite field, <em>p</em>.</p>
</li>
<li>
<p>We specify the <em>x</em> and <em>y</em> coordinates of the generator point <em>G</em>.</p>
</li>
<li>
<p>We specify the order of the group generated by <em>G</em>, <em>n</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These numbers are known publicly and together form the cryptographic curve.
There are many cryptographic curves and they have different security/convenience trade-offs, but the one we&#8217;re most interested in is the one Bitcoin uses: secp256k1.
The parameters for secp256k1 are these:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>a</em> = 0, <em>b</em> = 7, making the equation <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7</p>
</li>
<li>
<p><em>p</em> = 2<sup>256</sup> – 2<sup>32</sup> – 977</p>
</li>
<li>
<p><em>G<sub>x</sub></em> = <br/>0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</p>
</li>
<li>
<p><em>G<sub>y</sub></em> = <br/>0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</p>
</li>
<li>
<p><em>n</em> = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>G<sub>x</sub></em> refers to the <em>x</em> coordinate of the point <em>G</em> and <em>G<sub>y</sub></em> the <em>y</em> coordinate.
The numbers starting with 0x are hexadecimal numbers.</p>
</div>
<div class="paragraph">
<p>There are a few things to notice about this curve. First, the equation is relatively simple.
Many curves have <em>a</em> and <em>b</em> values that are much bigger.</p>
</div>
<div class="paragraph">
<p>Second, <em>p</em> is extremely close to 2<sup>256</sup>.
This means that most numbers under 2<sup>256</sup> are in the prime field, and thus any point on the curve has <em>x</em> and <em>y</em> coordinates that are expressible in 256 bits each.
<em>n</em> is also very close to 2<sup>256</sup>.
This means any scalar multiple can also be expressed in 256 bits.</p>
</div>
<div class="paragraph">
<p>Third, 2<sup>256</sup> is a huge number (see sidebar).
Amazingly, any number below 2<sup>256</sup> can be stored in 32 bytes.
This means that we can store the private key relatively easily.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">How Big is 2<sup>256</sup>?</div>
<div class="paragraph">
<p>2<sup>256</sup> doesn&#8217;t seem that big because we can express it succinctly, but in reality, it is an enormous number.
To give you an idea, here are some relative scales:</p>
</div>
<dl><dt class="plain">2<sup>256</sup> ~ 10<sup>77</sup></dt>
<dd>
<ul>
<li>Number of atoms in and on Earth ~ 10<sup>50</sup></li>
<li>Number of atoms in the solar system ~ 10<sup>57</sup></li>
<li>Number of atoms in the Milky Way ~ 10<sup>68</sup></li>
<li>Number of atoms in the universe ~ 10<sup>80</sup></li></ul>
</dd></dl>
<div class="paragraph">
<p>A trillion (10<sup>12</sup>) computers doing a trillion computations every trillionth (10<sup>–12</sup>) of a second for a trillion years is still less than 10<sup>56</sup> computations.</p>
</div>
<div class="paragraph">
<p>Think of finding a private key this way: there are as many possible private keys in Bitcoin as there are atoms in a billion galaxies.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_secp256k1">Working with secp256k1</h4>
<div class="paragraph">
<p>Since we know all of the parameters for secp256k1, we can verify in Python whether the generator point, <em>G</em>, is on the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
&gt;&gt;&gt; gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
&gt;&gt;&gt; p = 2**256 - 2**32 - 977
&gt;&gt;&gt; print(gy**2 % p == (gx**3 + 7) % p)
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, we can verify in Python whether the generator point, <em>G</em>, has the order <em>n</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement, Point
&gt;&gt;&gt; gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
&gt;&gt;&gt; gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
&gt;&gt;&gt; p = 2**256 - 2**32 - 977
&gt;&gt;&gt; n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
&gt;&gt;&gt; x = FieldElement(gx, p)
&gt;&gt;&gt; y = FieldElement(gy, p)
&gt;&gt;&gt; seven = FieldElement(7, p)
&gt;&gt;&gt; zero = FieldElement(0, p)
&gt;&gt;&gt; G = Point(x, y, zero, seven)
&gt;&gt;&gt; print(n*G)
Point(infinity)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since we know the curve we will work in, this is a good time to create a subclass in Python to work exclusively with the parameters for secp256k1.
We&#8217;ll define the equivalent <code>FieldElement</code> and <code>Point</code> objects, but specific to the secp256k1 curve.
Let&#8217;s start by defining the field we&#8217;ll be working in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">P = 2**256 - 2**32 - 977
...
class S256Field(FieldElement):

    def __init__(self, num, prime=None):
        super().__init__(num=num, prime=P)

    def __repr__(self):
        return '{:x}'.format(self.num).zfill(64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re subclassing the <code>FieldElement</code> class so we don&#8217;t have to pass in <em>P</em> all the time.
We also want to display a 256-bit number consistently by filling 64 characters so we can see any leading zeros.</p>
</div>
<div class="paragraph">
<p>Similarly, we can define a point on the secp256k1 curve and call it <code>S256Point</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">A = 0
B = 7
...
class S256Point(Point):

    def __init__(self, x, y, a=None, b=None):
        a, b = S256Field(A), S256Field(B)
        if type(x) == int:
            super().__init__(x=S256Field(x), y=S256Field(y), a=a, b=b)
        else:
            super().__init__(x=x, y=y, a=a, b=b)  # <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>In case we initialize with the point at infinity, we need to let <em>x</em> and <em>y</em> through directly instead of using the <code>S256Field</code> class.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We now have an easier way to initialize a point on the secp256k1 curve, without having to define a and b every time like we have to with the <code>Point</code> class.</p>
</div>
<div class="paragraph">
<p>We can also define <code><em>rmul</em></code> a bit more efficiently, since we know the order of the group, <em>n</em>.
Since we&#8217;re coding Python, we&#8217;ll name this with a capital <code>N</code> to make it clear that <code>N</code> is a constant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
...
class S256Point(Point):
    ...
    def __rmul__(self, coefficient):
        coef = coefficient % N  # <b class="conum">(1)</b>
        return super().__rmul__(coef)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We can mod by <em>n</em> because <em>nG</em> = 0.
That is, every <em>n</em> times we cycle back to zero or the point at infinity.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can now define <em>G</em> directly and keep it around since we&#8217;ll be using it a lot going forward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">G = S256Point(
    0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
    0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now checking that the order of <em>G</em> is <em>n</em> is trivial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import G, N
&gt;&gt;&gt; print(N*G)
S256Point(infinity)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_public_key_cryptography">Public Key Cryptography</h3>
<div class="paragraph">
<p>At last, we have the tools that we need to do public key cryptography operations.
The key operation that we need is <em>P</em> = <em>eG</em>, which is an asymmetric equation.
We can easily compute <em>P</em> when we know <em>e</em> and <em>G</em>, but we cannot easily compute <em>e</em> when we know <em>P</em> and <em>G</em>.
This is the discrete log problem described earlier.</p>
</div>
<div class="paragraph">
<p>The difficulty of discrete log will be essential to understanding signing and verification algorithms.</p>
</div>
<div class="paragraph">
<p>Generally, we call <em>e</em> the <em>private key</em> and <em>P</em> the <em>public key</em>.
Note here that the private key is a single 256-bit number and the public key is a coordinate (<em>x</em>,<em>y</em>), where <em>x</em> and <em>y</em> are <em>each</em> 256-bit numbers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_signing_and_verification">Signing and Verification</h3>
<div class="paragraph">
<p>To set up the motivation for why signing and verification exists, imagine this scenario.
You want to prove that you are a really good archer, like at the level where you can hit any target you want within 500 yards as opposed to being able to hit any particular target.</p>
</div>
<div class="paragraph">
<p>Now, if someone could observe you and interact with you, proving this would be easy.
Perhaps they would position your son 400 yards away with an apple on his head and challenge you to hit that apple with an arrow.
You, being a very good archer, could do this and prove your expertise.
The target, if specified by the challenger, makes your archery skill easy to verify.</p>
</div>
<div class="paragraph">
<p>Unfortunately, this doesn&#8217;t scale very well.
If, for example you wanted to prove this to 10 people, you would have to shoot 10 different arrows at 10 different targets from 10 different challenges.
You could try to do something like have 10 people watch you shoot a single arrow, but since they can&#8217;t all choose the target, they can never be sure that you&#8217;re not just good at hitting one particular target instead of an arbitrary target.
What we want is something that you can do once, that requires no interaction back and forth with the verifiers, but that still proves that you are indeed, a good archer that can hit <em>any</em> target.</p>
</div>
<div class="paragraph">
<p>If, for example, you simply shot an arrow into a target of your choosing, the people observing afterward wouldn&#8217;t necessarily be convinced.
After all, you might have painted the target around wherever your arrow happened to land.
So what can you do?</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a very clever thing you can do.
Inscribe the tip of the arrow with the position of the target that you&#8217;re hitting ("apple on top of my son&#8217;s head") and then hit that target with your arrow.
Now anyone seeing the target can take an X-ray machine and look at the tip of the embedded arrow and see that the tip indeed says exactly where it was going to hit.
The tip clearly had to be inscribed before the arrow was shot, so this can prove you are actually  a good archer (provided the actual target isn&#8217;t just one that you&#8217;ve practiced hitting over and over).</p>
</div>
<div class="paragraph">
<p>This is the same technique we&#8217;re using with signing and verification, except what we&#8217;re proving isn&#8217;t that we&#8217;re good archers, but that we know a secret number.
We want to prove possession of the secret without revealing the secret itself.
We do this by putting the target into our calculation and hitting that target.</p>
</div>
<div class="paragraph">
<p>Ultimately this is going to be used in transactions, which will prove that the rightful owners of the secrets are spending the bitcoins.</p>
</div>
<div class="sect3">
<h4 id="_inscribing_the_target">Inscribing the Target</h4>
<div class="paragraph">
<p>The inscribing of the target depends on the <em>signature algorithm</em>, and in our case that algorithm is called the Elliptic Curve Digital Signature Algorithm, or ECDSA for short.</p>
</div>
<div class="paragraph">
<p>The secret in our case is <em>e</em> satisfying the following:</p>
</div>
<ul class="simplelist">
<li><em>eG</em> = <em>P</em></li>
</ul>
<div class="paragraph">
<p>where <em>P</em> is the public key and <em>e</em> is the private key.</p>
</div>
<div class="paragraph">
<p>The target that we&#8217;re going to aim at is a random 256-bit number, <em>k</em>.
We then do this:</p>
</div>
<ul class="simplelist">
<li><em>kG</em> = <em>R</em></li>
</ul>
<div class="paragraph">
<p><em>R</em> is now the target that we&#8217;re aiming for.
In fact, we&#8217;re only going to care about the <em>x</em> coordinate of <em>R</em>, which we&#8217;ll call <em>r</em>.
You may have guessed already that <em>r</em> here stands for <em>random</em>.</p>
</div>
<div class="paragraph">
<p>We claim at this point that the following equation is equivalent to the discrete log problem:</p>
</div>
<ul class="simplelist">
<li><em>uG</em> + <em>vP</em> = <em>kG</em></li>
</ul>
<div class="paragraph">
<p>where <em>k</em> was chosen randomly, <em>u</em>,<em>v</em> ≠ 0 can be chosen by the signer, and <em>G</em> and <em>P</em> are known. This is due to the fact that:</p>
</div>
<ul class="simplelist">
<li><em>uG</em> + <em>vP</em> = <em>kG</em> implies <em>vP</em> = (<em>k</em> – <em>u</em>)<em>G</em></li>
</ul>
<div class="paragraph">
<p>Since <em>v</em> ≠ 0, we can divide by the scalar multiple <em>v</em>:</p>
</div>
<ul class="simplelist">
<li><em>P</em> = ((<em>k</em> – <em>u</em>)/<em>v</em>)<em>G</em></li>
</ul>
<div class="paragraph">
<p>If we know <em>e</em>, we have:</p>
</div>
<ul class="simplelist">
<li><em>eG</em> = ((<em>k</em> – <em>u</em>)/<em>v</em>)<em>G</em> or <em>e</em> = (<em>k</em> – <em>u</em>)/<em>v</em></li>
</ul>
<div class="paragraph">
<p>This means that any (<em>u</em>,<em>v</em>) combination that satisfies the preceding equation will suffice.</p>
</div>
<div class="paragraph">
<p>Now suppose we don&#8217;t know <em>e</em>, but we can solve <em>uG + vP = kG</em> with some (<em>u</em>,<em>v</em>) combination.
Then <em>e = (k–u)/v</em> gives a solution to <em>P</em> = <em>eG</em> while knowing only <em>P</em> and <em>G</em>.
In other words, we&#8217;d have broken the discrete log problem.</p>
</div>
<div class="paragraph">
<p>This means to provide a correct <em>u</em> and <em>v</em>, we either have to break the discrete log problem or know the secret <em>e</em>.
Since we assume discrete log is hard, we can say <em>e</em> is assumed to be known by the one who came up with <em>u</em> and <em>v</em>.</p>
</div>
<div class="paragraph">
<p>One subtle thing that we haven&#8217;t talked about is that we have to incorporate the purpose of our shooting.
This is a contract that gets fulfilled as a result of shooting at the target.
William Tell, for example, was shooting so that he could save his son (shoot the target and you get to save your son).
You can imagine there would be other reasons to hit the target and other "rewards" that the person hitting the target would receive.
This has to be incorporated into our equations.</p>
</div>
<div class="paragraph">
<p>In signature/verification parlance, this is called the <em>signature hash</em>.
A hash is a deterministic function that takes arbitrary data into data of fixed size.
This is a fingerprint of the message containing the intent of the shooter, which anyone verifying the message already knows.
We denote this with the letter <em>z</em>.
This is incorporated into our <em>uG</em> + <em>vP</em> calculation this way:</p>
</div>
<ul class="simplelist">
<li><em>u</em> = <em>z</em>/<em>s</em>, <em>v</em> = <em>r</em>/<em>s</em></li>
</ul>
<div class="paragraph">
<p>Since <em>r</em> is used in the calculation of <em>v</em>, we now have the tip of the arrow inscribed.
We also have the intent of the shooter incorporated into <em>u</em>, so both the reason for shooting and the target that is being aimed at are now part of the equation.</p>
</div>
<div class="paragraph">
<p>To make the equation work, we can calculate <em>s</em>:</p>
</div>
<ul class="simplelist">
<li><em>uG</em> + <em>vP</em> = <em>R</em> = <em>kG</em></li>
<li><em>uG</em> + <em>veG</em> = <em>kG</em></li>
<li><em>u</em> + <em>ve</em> = <em>k</em></li>
<li><em>z</em>/<em>s</em> + <em>re</em>/<em>s</em> = <em>k</em></li>
<li>(<em>z</em> + <em>re</em>)/<em>s</em> = <em>k</em></li>
<li><em>s</em> = (<em>z</em> + <em>re</em>)/<em>k</em></li>
</ul>
<div class="paragraph">
<p>This is the basis of the signature algorithm, and the two numbers in a signature are <em>r</em> and <em>s</em>.</p>
</div>
<div class="paragraph">
<p>Verification is straightforward:</p>
</div>
<ul class="simplelist">
<li><em>uG</em> + <em>vP</em> where <em>u</em>,<em>v</em> ≠ 0</li>
<li><em>uG</em> + <em>vP</em> = (<em>z</em>/<em>s</em>)<em>G</em> + (<em>re</em>/<em>s</em>)<em>G</em> = ((<em>z</em> + <em>re</em>)/<em>s</em>)<em>G</em> = ((<em>z</em> + <em>re</em>)/((<em>z</em> + <em>re</em>)/<em>k</em>))<em>G</em> = <em>kG</em> = (<em>r</em>,<em>y</em>)</li>
</ul>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Why We Don&#8217;t Reveal <code>k</code></div>
<div class="paragraph">
<p>At this point, you might be wondering why we don&#8217;t reveal <em>k</em> and instead reveal the <em>x</em> coordinate of <em>R</em>, or <em>r</em>.
If we were to reveal <em>k</em>, then:</p>
</div>
<ul class="simplelist">
<li><em>uG</em> + <em>vP</em> = <em>R</em></li>
<li><em>uG</em> + <em>veG</em> = <em>kG</em></li>
<li><em>kG</em> – <em>uG</em> = <em>veG</em></li>
<li>(<em>k</em> – <em>u</em>)<em>G</em> = <em>veG</em></li>
<li>(<em>k</em> – <em>u</em>) = <em>ve</em></li>
<li>(<em>k</em> – <em>u</em>)/<em>v</em> = <em>e</em></li>
</ul>
<div class="paragraph">
<p>means that our secret would be revealed, which would defeat the whole purpose of the signature.
We can, however, reveal <em>R</em>.</p>
</div>
<div class="paragraph">
<p>It&#8217;s worth mentioning again: make sure you&#8217;re using truly random numbers for <em>k</em>, as even accidentally revealing <em>k</em> for a known signature is the equivalent of revealing your secret and losing your funds!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_verification_in_depth">Verification in Depth</h4>
<div class="paragraph">
<p>Signatures sign some fixed-length value (our "contract")—in our case, something that&#8217;s 32 bytes.
The fact that 32 bytes is 256 bits is not a coincidence, as the thing we&#8217;re signing will be a scalar for <em>G</em>.</p>
</div>
<div class="paragraph">
<p>To guarantee that the thing we&#8217;re signing is 32 bytes, we hash the document first.
In Bitcoin, the hashing function is hash256, or two rounds of sha256.
This guarantees the thing that we&#8217;re signing is exactly 32 bytes.
We will call the result of the hash the <em>signature hash</em>, or <em>z</em>.</p>
</div>
<div class="paragraph">
<p>The signature that we are verifying has two components, (<em>r</em>,<em>s</em>).
<em>r</em> is the <em>x</em> coordinate of some point <em>R</em> that we&#8217;ll come back to.
The formula for <em>s</em> is as above:</p>
</div>
<ul class="simplelist">
<li><em>s</em> = (<em>z</em>+<em>re</em>)/<em>k</em></li>
</ul>
<div class="paragraph">
<p>Keep in mind that we know <em>e</em> (<em>P</em> = <em>eG</em>, or what we&#8217;re proving we know in the first place), we know <em>k</em> (<em>kG</em> = <em>R</em>, remember?), and we know <em>z</em>.</p>
</div>
<div class="paragraph">
<p>We will now construct <em>R</em> = <em>uG</em> + <em>vP</em> by defining <em>u</em> and <em>v</em> this way:</p>
</div>
<ul class="simplelist">
<li><em>u</em> = <em>z</em>/<em>s</em></li>
<li><em>v</em> = <em>r</em>/<em>s</em></li>
</ul>
<div class="paragraph">
<p>Thus:</p>
</div>
<ul class="simplelist">
<li><em>uG</em> + <em>vP</em> = (<em>z</em>/<em>s</em>)<em>G</em> + (<em>r</em>/<em>s</em>)<em>P</em> = (<em>z</em>/<em>s</em>)<em>G</em> + (<em>re</em>/<em>s</em>)<em>G</em> = ((<em>z</em> + <em>re</em>)/<em>s</em>)<em>G</em></li>
</ul>
<div class="paragraph">
<p>We know <em>s</em> = (<em>z</em> + <em>re</em>)/<em>k</em>, so:</p>
</div>
<ul class="simplelist">
<li><em>uG</em> + <em>vP</em> = ((<em>z</em> + <em>re</em>) / ((<em>z</em> + <em>re</em>)/<em>k</em>))<em>G</em> = <em>kG</em> = <em>R</em></li>
</ul>
<div class="paragraph">
<p>We&#8217;ve successfully chosen <em>u</em> and <em>v</em> in such a way as to generate <em>R</em> as we intended.
Furthermore, we used <em>r</em> in the calculation of <em>v</em>, proving we knew what <em>R</em> would be.
The only way we can know the details of <em>R</em> beforehand is if we know <em>e</em>.</p>
</div>
<div class="paragraph">
<p>To wit, here are the steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We are given (<em>r</em>,<em>s</em>) as the signature, <em>z</em> as the hash of the thing being signed, and <em>P</em> as the public key (or public point) of the signer.</p>
</li>
<li>
<p>We calculate <em>u</em> = <em>z</em>/<em>s</em>, <em>v</em> = <em>r</em>/<em>s</em>.</p>
</li>
<li>
<p>We calculate <em>uG</em> + <em>vP</em> = <em>R</em>.</p>
</li>
<li>
<p>If <em>R</em>'s <em>x</em> coordinate equals <em>r</em>, the signature is valid.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Why Two Rounds of sha256?</div>
<div class="paragraph">
<p>The calculation of <em>z</em> requires two rounds of sha256, or hash256.
You may be wondering why there are two rounds when only one is necessary to get a 256-bit number.
The reason is for security.</p>
</div>
<div class="paragraph">
<p>There is a well-known hash collision attack on SHA-1 called a <em>birthday attack</em> that makes finding collisions much easier.
<a href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html">Google found a SHA-1 collision</a> using some modifications of a birthday attack and a lot of other things in 2017.
Using SHA-1 twice, or <em>double SHA-1</em>, is the way to defeat or slow down some forms of this attack.</p>
</div>
<div class="paragraph">
<p>Two rounds of sha256 don&#8217;t necessarily prevent all possible attacks, but doing two rounds is a defense against some potential <span class="keep-together">weaknesses</span>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_verifying_a_signature">Verifying a Signature</h4>
<div class="paragraph">
<p>We can now verify a signature using some of the primitives that we have:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import S256Point, G, N
&gt;&gt;&gt; z = 0xbc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423
&gt;&gt;&gt; r = 0x37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6
&gt;&gt;&gt; s = 0x8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec
&gt;&gt;&gt; px = 0x04519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574
&gt;&gt;&gt; py = 0x82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4
&gt;&gt;&gt; point = S256Point(px, py)
&gt;&gt;&gt; s_inv = pow(s, N-2, N)  # <b class="conum">(1)</b>
&gt;&gt;&gt; u = z * s_inv % N  # <b class="conum">(2)</b>
&gt;&gt;&gt; v = r * s_inv % N  # <b class="conum">(3)</b>
&gt;&gt;&gt; print((u*G + v*point).x.num == r)  # <b class="conum">(4)</b>
True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Note that we use Fermat&#8217;s little theorem for 1/<em>s</em>, since <em>n</em> is prime.</p>
</li>
<li>
<p><em>u</em> = <em>z</em>/<em>s</em>.</p>
</li>
<li>
<p><em>v</em> = <em>r</em>/<em>s</em>.</p>
</li>
<li>
<p><em>uG</em> + <em>vP</em> = (<em>r</em>,<em>y</em>).
We need to check that the <em>x</em> coordinate is <em>r</em>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_3">Exercise 6</h4>
<div class="paragraph">
<p>Verify whether these signatures are valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>P = (0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c,
     0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34)

# signature 1
z = 0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60
r = 0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395
s = 0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4

# signature 2
z = 0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d
r = 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c
s = 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_programming_signature_verification">Programming Signature Verification</h4>
<div class="paragraph">
<p>We already have a class <code>S256Point</code>, which is the public point for the private key.
We create a <code>Signature</code> class that houses the <em>r</em> and <em>s</em> values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Signature:

    def __init__(self, r, s):
        self.r = r
        self.s = s

    def __repr__(self):
        return 'Signature({:x},{:x})'.format(self.r, self.s)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will be doing more with this class in <a href="#chapter_serialization">Serialization</a>.</p>
</div>
<div class="paragraph">
<p>We can now write the <code>verify</code> method on <code>S256Point</code> based on this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class S256Point(Point):
    ...
    def verify(self, z, sig):
        s_inv = pow(sig.s, N - 2, N)  # <b class="conum">(1)</b>
        u = z * s_inv % N  # <b class="conum">(2)</b>
        v = sig.r * s_inv % N  # <b class="conum">(3)</b>
        total = u * G + v * self  # <b class="conum">(4)</b>
        return total.x.num == sig.r  # <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>s_inv</code> (1/<em>s</em>) is calculated using Fermat&#8217;s little theorem on the order of the group, <em>n</em>, which is prime.</p>
</li>
<li>
<p><em>u</em> = <em>z</em>/<em>s</em>.
Note that we can mod by <em>n</em> as that&#8217;s the order of the group.</p>
</li>
<li>
<p><em>v</em> = <em>r</em>/<em>s</em>.
Note that we can mod by <em>n</em> as that&#8217;s the order of the group.</p>
</li>
<li>
<p><em>uG</em> + <em>vP</em> should be <em>R</em>.</p>
</li>
<li>
<p>We check that the <em>x</em> coordinate is <em>r</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So, given a public key that is a point on the secp256k1 curve and a signature hash, <em>z</em>, we can verify whether a signature is valid or not.</p>
</div>
</div>
<div class="sect3">
<h4 id="_signing_in_depth">Signing in Depth</h4>
<div class="paragraph">
<p>Given that we know how verification should work, signing is straightforward.
The only missing step is figuring out what <em>k</em>, and thus <em>R</em> = <em>kG</em>, to use.
We do this by choosing a random <em>k</em>.</p>
</div>
<div class="paragraph">
<p>The signing procedure is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We are given <em>z</em> and know <em>e</em> such that <em>eG</em> = <em>P</em>.</p>
</li>
<li>
<p>Choose a random <em>k</em>.</p>
</li>
<li>
<p>Calculate <em>R</em> = <em>kG</em> and <em>r</em> = <em>x</em> coordinate of <em>R</em>.</p>
</li>
<li>
<p>Calculate <em>s</em> = (<em>z</em> + <em>re</em>)/<em>k</em>.</p>
</li>
<li>
<p>Signature is (<em>r</em>,<em>s</em>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that the public key (pubkey) <em>P</em> has to be transmitted to whoever wants to verify it, and <em>z</em> must be known by the verifier.
We&#8217;ll see later that <em>z</em> is computed and <em>P</em> is sent along with the signature.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_signature">Creating a Signature</h4>
<div class="paragraph">
<p>We can now create a signature.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Be Careful with Random Number Generation</div>
<div class="paragraph">
<p>Note that using something like the <code>random</code> library from Python to do cryptography is generally not a good idea.
This library is for teaching purposes only, so please don&#8217;t use any of the code explained to you here for production purposes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We do this using some of the primitives that we have:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from ecc import S256Point, G, N
&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; e = int.from_bytes(hash256(b'my secret'), 'big')  # <b class="conum">(1)</b>
&gt;&gt;&gt; z = int.from_bytes(hash256(b'my message'), 'big')  # <b class="conum">(2)</b>
&gt;&gt;&gt; k = 1234567890  # <b class="conum">(3)</b>
&gt;&gt;&gt; r = (k*G).x.num  # <b class="conum">(4)</b>
&gt;&gt;&gt; k_inv = pow(k, N-2, N)
&gt;&gt;&gt; s = (z+r*e) * k_inv % N  # <b class="conum">(5)</b>
&gt;&gt;&gt; point = e*G  # <b class="conum">(6)</b>
&gt;&gt;&gt; print(point)
S256Point(028d003eab2e428d11983f3e97c3fa0addf3b42740df0d211795ffb3be2f6c52, \
0ae987b9ec6ea159c78cb2a937ed89096fb218d9e7594f02b547526d8cd309e2)
&gt;&gt;&gt; print(hex(z))
0x231c6f3d980a6b0fb7152f85cee7eb52bf92433d9919b9c5218cb08e79cce78
&gt;&gt;&gt; print(hex(r))
0x2b698a0f0a4041b77e63488ad48c23e8e8838dd1fb7520408b121697b782ef22
&gt;&gt;&gt; print(hex(s))
0xbb14e602ef9e3f872e25fad328466b34e6734b7a0fcd58b1eb635447ffae8cb9</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is an example of a "brain wallet," which is a way to keep the private key in your head without having to memorize something too difficult.
Please don&#8217;t use this for a real secret.</p>
</li>
<li>
<p>This is the signature hash, or hash of the message that we&#8217;re signing.</p>
</li>
<li>
<p>We&#8217;re going to use a fixed <em>k</em> here for demonstration purposes.</p>
</li>
<li>
<p><em>kG</em> = (<em>r</em>,<em>y</em>), so we take the <em>x</em> coordinate only.</p>
</li>
<li>
<p><em>s</em> = (<em>z</em> + <em>re</em>)/<em>k</em>.
We can mod by <em>n</em> because we know this is a cyclical group of order <em>n</em>.</p>
</li>
<li>
<p>The public point needs to be known by the verifier.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_3">Exercise 7</h4>
<div class="paragraph">
<p>Sign the following message with the secret:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>e = 12345
z = int.from_bytes(hash256('Programming Bitcoin!'), 'big')</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_programming_message_signing">Programming Message Signing</h4>
<div class="paragraph">
<p>To program message signing, we now create a <code>PrivateKey</code> class, which will house our secret:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class PrivateKey:

    def __init__(self, secret):
        self.secret = secret
        self.point = secret * G  # <b class="conum">(1)</b>

    def hex(self):
        return '{:x}'.format(self.secret).zfill(64)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We keep around the public key, <code>self.point</code>, for convenience.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We then create the <code>sign</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from random import randint
...
class PrivateKey:
...
    def sign(self, z):
        k = randint(0, N)  # <b class="conum">(1)</b>
        r = (k*G).x.num  # <b class="conum">(2)</b>
        k_inv = pow(k, N-2, N)  # <b class="conum">(3)</b>
        s = (z + r*self.secret) * k_inv % N  # <b class="conum">(4)</b>
        if s &gt; N/2:  # <b class="conum">(5)</b>
            s = N - s
        return Signature(r, s) # <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>randint</code> chooses a random integer from [0,__n__).
Please don&#8217;t use this function in production, because the random number from this library is not nearly random enough.</p>
</li>
<li>
<p><em>r</em> is the <em>x</em> coordinate of <em>kG</em>.</p>
</li>
<li>
<p>We use Fermat&#8217;s little theorem again, and <em>n</em>, which is prime.</p>
</li>
<li>
<p><em>s</em> = (<em>z</em> + <em>re</em>)/<em>k</em>.</p>
</li>
<li>
<p>It turns out that using the low-<em>s</em> value will get nodes to relay our transactions.
This is for malleability reasons.</p>
</li>
<li>
<p>We return a <code>Signature</code> object from the class defined earlier.</p>
</li>
</ol>
</div>
<div class="sidebarblock pagebreak-before less_space">
<div class="content">
<div class="title">Importance of a Unique <code>k</code></div>
<div class="paragraph">
<p>There&#8217;s an important rule in signatures that utilize a random component like we have here: the <em>k</em> needs to be unique per signature.
That is, it cannot get reused.
In fact, a <em>k</em> that&#8217;s reused will result in you revealing your secret!
Why?</p>
</div>
<div class="paragraph">
<p>If our secret is <em>e</em> and we are reusing <em>k</em> to sign <em>z</em><sub>1</sub> and <em>z</em><sub>2</sub>:</p>
</div>
<ul class="simplelist">
<li><em>kG</em> = (<em>r</em>,<em>y</em>)</li>
<li><em>s</em><sub>1</sub> = (<em>z</em><sub>1</sub> + <em>re</em>) / <em>k</em>, <em>s</em><sub>2</sub> = (<em>z</em><sub>2</sub> + <em>re</em>) / <em>k</em></li>
<li><em>s</em><sub>1</sub>/<em>s</em><sub>2</sub> = (<em>z</em><sub>1</sub> + <em>re</em>) / (<em>z</em><sub>2</sub> + <em>re</em>)</li>
<li><em>s</em><sub>1</sub>(<em>z</em><sub>2</sub> + <em>re</em>) = <em>s</em><sub>2</sub>(<em>z</em><sub>1</sub> + <em>re</em>)</li>
<li><em>s</em><sub>1</sub><em>z</em><sub>2</sub> + <em>s</em><sub>1</sub><em>re</em> = <em>s</em><sub>2</sub><em>z</em><sub>1</sub> + <em>s</em><sub>2</sub><em>re</em></li>
<li><em>s</em><sub>1</sub><em>re</em> – <em>s</em><sub>2</sub><em>re</em> = <em>s</em><sub>2</sub><em>z</em><sub>1</sub> – <em>s</em><sub>1</sub><em>z</em><sub>2</sub></li>
<li><em>e</em> = (<em>s</em><sub>2</sub><em>z</em><sub>1</sub> – <em>s</em><sub>1</sub><em>z</em><sub>2</sub>) / (<em>rs</em><sub>1</sub> – <em>rs</em><sub>2</sub>)</li>
</ul>
<div class="paragraph">
<p>If anyone sees both signatures, they can use this formula and find our secret!
The <a href="https://arstechnica.com/gaming/2010/12/ps3-hacked-through-poor-implementation-of-cryptography/">PlayStation 3 hack</a> back in 2010 was due to the reuse of the <em>k</em> value in multiple signatures.</p>
</div>
<div class="paragraph">
<p>To combat this, there is a deterministic <em>k</em> generation standard that uses the secret and <em>z</em> to create a unique, deterministic <em>k</em> every time.
The specification is in <a href="https://tools.ietf.org/html/rfc6979">RFC 6979</a> and the code changes to look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class PrivateKey:
...
    def sign(self, z):
        k = self.deterministic_k(z)  # <b class="conum">(1)</b>
        r = (k * G).x.num
        k_inv = pow(k, N - 2, N)
        s = (z + r * self.secret) * k_inv % N
        if s &gt; N / 2:
            s = N - s
        return Signature(r, s)

    def deterministic_k(self, z):
        k = b'\x00' * 32
        v = b'\x01' * 32
        if z &gt; N:
            z -= N
        z_bytes = z.to_bytes(32, 'big')
        secret_bytes = self.secret.to_bytes(32, 'big')
        s256 = hashlib.sha256
        k = hmac.new(k, v + b'\x00' + secret_bytes + z_bytes, s256).digest()
        v = hmac.new(k, v, s256).digest()
        k = hmac.new(k, v + b'\x01' + secret_bytes + z_bytes, s256).digest()
        v = hmac.new(k, v, s256).digest()
        while True:
            v = hmac.new(k, v, s256).digest()
            candidate = int.from_bytes(v, 'big')
            if candidate &gt;= 1 and candidate &lt; N:
                return candidate  # <b class="conum">(2)</b>
            k = hmac.new(k, v + b'\x00', s256).digest()
            v = hmac.new(k, v, s256).digest()</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are using the deterministic <em>k</em> instead of a random one.
Everything else about <code>sign</code> remains the same.</p>
</li>
<li>
<p>This algorithm returns a candidate that&#8217;s suitable.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A deterministic <em>k</em> will be unique with very high probability.
This is because sha256 is collision-resistant, and no collisions have been found to date.</p>
</div>
<div class="paragraph">
<p>Another benefit from a testing perspective is that the signature for a given <em>z</em> and the same private key will be the same every time.
This makes debugging much easier and unit tests a lot easier to write.
In addition, transactions that use deterministic <em>k</em> will create the same transaction every time, as the signature will not change.
This makes transactions less malleable (more on that in <a href="#chapter_segwit">Segwit</a>).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_3">Conclusion</h3>
<div class="paragraph">
<p>We&#8217;ve covered elliptic curve cryptography and can now prove that we know a secret by signing something. We can also verify that the person with the secret actually signed a message.
Even if you don&#8217;t read another page in this book, you&#8217;ve learned to implement what was once considered <a href="https://en.wikipedia.org/wiki/Export_of_cryptography_from_the_United_States">"weapons-grade munitions"</a>.
This is a major step in your journey and will be essential for the rest of the book!</p>
</div>
<div class="paragraph">
<p>We now turn to serializing a lot of these structures so that we can store them on disk and send them over the network.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_serialization">Serialization</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>We&#8217;ve created a lot of classes thus far, including <code>PrivateKey</code>, <code>S256Point</code>, and <code>Signature</code>.
We now need to start thinking about how to transmit these objects to other computers on the network, or even to disk.
This is where serialization comes into play.
We want to communicate or store a <code>S256Point</code> or a <code>Signature</code> or a <code>PrivateKey</code>.
Ideally, we want to do this efficiently, for reasons we&#8217;ll see in <a href="#chapter_networking">Networking</a>.</p>
</div>
<div class="sect2">
<h3 id="_uncompressed_sec_format">Uncompressed SEC Format</h3>
<div class="paragraph">
<p>We&#8217;ll start with the <code>S256Point</code> class, which is the public key class.
Recall that the public key in elliptic curve cryptography is really a coordinate in the form of (<em>x</em>,<em>y</em>).
How can we serialize this data?</p>
</div>
<div class="paragraph">
<p>It turns out there&#8217;s already a standard for serializing ECDSA public keys, called <em>Standards for Efficient Cryptography</em> (SEC)—and as the word "Efficient" in the name suggests, it has minimal overhead.
There are two forms of SEC format that we need to be concerned with: uncompressed and compressed. We&#8217;ll begin with the former, and look at the compressed format in the next section.</p>
</div>
<div class="paragraph">
<p>Here is how the uncompressed SEC format for a given point <em>P</em> = (<em>x</em>,<em>y</em>) is generated:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start with the prefix byte, which is <code>0x04</code>.</p>
</li>
<li>
<p>Next, append the <em>x</em> coordinate in 32 bytes as a big-endian integer.</p>
</li>
<li>
<p>Next, append the <em>y</em> coordinate in 32 bytes as a big-endian integer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The uncompressed SEC format is shown in <a href="#uncompressed_sec_format">Uncompressed SEC format</a>.</p>
</div>
<div id="uncompressed_sec_format" class="imageblock">
<div class="content">
<img src="./images/prbc_0401.png" alt="Uncompressed SEC format">
</div>
<div class="title">Figure 36. Uncompressed SEC format</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Big- and Little-Endian</div>
<div class="paragraph">
<p>The motivation for big- and little-endian encodings is storing a number on disk.
A number under 256 is easy enough to encode, as a single byte (2<sup>8</sup>) is enough to hold it.
When it&#8217;s bigger than 256, how do we serialize the number to bytes?</p>
</div>
<div class="paragraph">
<p>Arabic numerals are read left to right.
A number like 123 is 100 + 20 + 3 and not 1 + 20 + 300.
This is what we call big-endian, because the "big end" starts first.</p>
</div>
<div class="paragraph">
<p>Computers can sometimes be more efficient using the opposite order, or little-endian—that is, starting with the little end first.</p>
</div>
<div class="paragraph">
<p>Since computers work in bytes, which have 8 bits, we have to think in base 256.
This means that a number like 500 looks like <code>01f4</code> in big-endian—that is, 500 = 1 &#xd7; 256 + 244 (<code>f4</code> in hexadecimal).
The same number looks like <code>f401</code> in little-endian.</p>
</div>
<div class="paragraph">
<p>Unfortunately, some serializations in Bitcoin (like the SEC format <em>x</em> and <em>y</em> coordinates) are big-endian, while others (like the transaction version number in <a href="#chapter_tx_parsing">Transactions</a>) are little-endian.
This book will let you know which ones are big- versus little-endian.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Creating the uncompressed SEC format serialization is pretty straightforward.
The trickiest part is converting a 256-bit number into 32 bytes, big-endian.
Here&#8217;s how this is done in code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class S256Point(Point):
...
    def sec(self):
        '''returns the binary version of the SEC format'''
	return b'\x04' + self.x.num.to_bytes(32, 'big') \
            + self.y.num.to_bytes(32, 'big')  # <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>In Python 3, you can convert a number to bytes using the <code>to_bytes</code> method.
The first argument is how many bytes it should take up and the second argument is the endianness (see the preceding note).</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_1_4">Exercise 1</h4>
<div class="paragraph">
<p>Find the uncompressed SEC format for the public key where the private key secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5,000</p>
</li>
<li>
<p>2,018<sup>5</sup></p>
</li>
<li>
<p>0xdeadbeef12345</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compressed_sec_format">Compressed SEC Format</h3>
<div class="paragraph">
<p>Recall that for any <em>x</em> coordinate, there are at most two <em>y</em> coordinates due to the <em>y</em><sup>2</sup> term in the elliptic curve equation (<a href="#the_two_possible_values_for_y_are_where_this_vertical_line_intersects_the_curve">The two possible values for y are where this vertical line intersects the curve</a>).</p>
</div>
<div id="the_two_possible_values_for_y_are_where_this_vertical_line_intersects_the_curve" class="imageblock width-90">
<div class="content">
<img src="./images/prbc_0212.png" alt="Elliptic Curve Vertical Line">
</div>
<div class="title">Figure 37. The two possible values for y are where this vertical line intersects the curve</div>
</div>
<div class="paragraph">
<p>It turns out that even over a finite field, we have the same symmetry.</p>
</div>
<div class="paragraph">
<p>This is because for any (<em>x</em>,<em>y</em>) that satisfies <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>, (<em>x</em>,–<em>y</em>) also satisfies the equation.
Furthermore, in a finite field, –<em>y</em> % <em>p</em> = (<em>p</em> – <em>y</em>) % <em>p</em>.
Or, more accurately, if (<em>x</em>,<em>y</em>) satisfies the elliptic curve equation, (<em>x</em>,<em>p</em> – <em>y</em>) also satisfies the equation.
These are the only two solutions for a given <em>x</em>, as shown, so if we know <em>x</em>, we know the <em>y</em> coordinate has to be either <em>y</em> or <em>p</em> – <em>y</em>.</p>
</div>
<div class="paragraph">
<p>Since <em>p</em> is a prime number greater than 2, we know that <em>p</em> is odd.
Thus, if <em>y</em> is even, <span class="keep-together"><em>p</em> – <em>y</em></span> (odd minus even) will be odd.
If <em>y</em> is odd, <em>p</em> – <em>y</em> will be even.
In other words, between <em>y</em> and <em>p</em> – <em>y</em>, exactly one will be even and one will be odd.
This is something we can use to our advantage to shorten the uncompressed SEC format: we can provide the <em>x</em> coordinate and the evenness of the <em>y</em> coordinate.
We call this the <em>compressed SEC format</em> because of how the <em>y</em> coordinate is compressed into a single byte (namely, whether it&#8217;s even or odd).</p>
</div>
<div class="paragraph">
<p>Here is the serialization of the compressed SEC format for a given point <em>P</em> = (<em>x</em>,<em>y</em>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start with the prefix byte.
If <em>y</em> is even, it&#8217;s <code>0x02</code>; otherwise, it&#8217;s <code>0x03</code>.</p>
</li>
<li>
<p>Next, append the <em>x</em> coordinate in 32 bytes as a big-endian integer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The compressed SEC format is shown in <a href="#compressed_sec_format">Compressed SEC format</a>.</p>
</div>
<div id="compressed_sec_format" class="imageblock">
<div class="content">
<img src="./images/prbc_0403.png" alt="Compressed SEC format">
</div>
<div class="title">Figure 38. Compressed SEC format</div>
</div>
<div class="paragraph">
<p>Again, the procedure is pretty straightforward.
We can update the <code>sec</code> method to handle compressed SEC keys:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class S256Point(Point):
...
    def sec(self, compressed=True):
        '''returns the binary version of the SEC format'''
        if compressed:
            if self.y.num % 2 == 0:
                return b'\x02' + self.x.num.to_bytes(32, 'big')
            else:
                return b'\x03' + self.x.num.to_bytes(32, 'big')
        else:
            return b'\x04' + self.x.num.to_bytes(32, 'big') + \
                self.y.num.to_bytes(32, 'big')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The big advantage of the compressed SEC format is that it only takes up 33 bytes instead of 65 bytes.
This is a big savings when amortized over millions of transactions.</p>
</div>
<div class="paragraph">
<p>At this point, you may be wondering how you can analytically calculate <em>y</em> given the <em>x</em> coordinate.
This requires us to calculate a square root in a finite field.</p>
</div>
<div class="paragraph">
<p>Stated mathematically:</p>
</div>
<ul class="simplelist">
<li>Find <em>w</em> such that <em>w</em><sup>2</sup> = <em>v</em> when we know <em>v</em>.</li>
</ul>
<div class="paragraph">
<p>It turns out that if the finite field prime <em>p</em> % 4 = 3, we can do this rather easily.
Here&#8217;s how.</p>
</div>
<div class="paragraph">
<p>First, we know:</p>
</div>
<ul class="simplelist">
<li><em>p</em> % 4 = 3</li>
</ul>
<div class="paragraph">
<p>which implies:</p>
</div>
<ul class="simplelist">
<li>(<em>p</em> + 1) % 4 = 0</li>
</ul>
<div class="paragraph">
<p>That is, (<em>p</em> + 1)/4 is an integer.</p>
</div>
<div class="paragraph">
<p>By definition:</p>
</div>
<ul class="simplelist">
<li><em>w</em><sup>2</sup> = <em>v</em></li>
</ul>
<div class="paragraph">
<p>We are looking for a formula to calculate <em>w</em>.
From Fermat&#8217;s little theorem:</p>
</div>
<ul class="simplelist">
<li><em>w</em><sup><em>p</em>–1</sup> % <em>p</em> = 1</li>
</ul>
<div class="paragraph">
<p>which means:</p>
</div>
<ul class="simplelist">
<li><em>w</em><sup>2</sup> = <em>w</em><sup>2</sup> ⋅ 1 = <em>w</em><sup>2</sup> ⋅ <em>w</em><sup><em>p</em>–1</sup> = <em>w</em><sup>(<em>p</em>+1)</sup></li>
</ul>
<div class="paragraph">
<p>Since <em>p</em> is odd (recall <em>p</em> is prime), we know we can divide (<em>p</em>+1) by 2 and still get an integer, implying:</p>
</div>
<ul class="simplelist">
<li><em>w</em> = <em>w</em><sup>(<em>p</em>+1)/2</sup></li>
</ul>
<div class="paragraph">
<p>Now we can use (<em>p</em>+1)/4 being an integer this way:</p>
</div>
<ul class="simplelist">
<li><em>w</em> = <em>w</em><sup>(<em>p</em>+1)/2</sup> = <em>w</em><sup>2(<em>p</em>+1)/4</sup> = (<em>w</em><sup>2</sup>)<sup>(<em>p</em>+1)/4</sup> = <em>v</em><sup>(<em>p</em>+1)/4</sup></li>
</ul>
<div class="paragraph">
<p>So our formula for finding the square root becomes:</p>
</div>
<ul class="simplelist">
<li>if <em>w</em><sup>2</sup> = <em>v</em> and <em>p</em> % 4 = 3, <em>w</em> = <em>v</em><sup>(<em>p</em>+1)/4</sup></li>
</ul>
<div class="paragraph">
<p>It turns out that the <em>p</em> used in secp256k1 is such that <em>p</em> % 4 == 3, so we can use this formula:</p>
</div>
<ul class="simplelist">
<li><em>w</em><sup>2</sup> = <em>v</em></li>
<li><em>w</em> = <em>v</em><sup>(<em>p</em>+1)/4</sup></li>
</ul>
<div class="paragraph">
<p>That will be one of the two possible <em>w</em>'s; the other will be <em>p</em> – <em>w</em>.
This is due to taking the square root means that both the positive and negative will work.</p>
</div>
<div class="paragraph">
<p>We can add this as a general method in the S256Field class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class S256Field(FieldElement):
...
    def sqrt(self):
        return self**((P + 1) // 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we get a serialized SEC pubkey, we can write a <code>parse</code> method to figure out which <em>y</em> we need:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class S256Point:
...
    @classmethod
    def parse(self, sec_bin):
        '''returns a Point object from a SEC binary (not hex)'''
        if sec_bin[0] == 4:  # <b class="conum">(1)</b>
            x = int.from_bytes(sec_bin[1:33], 'big')
            y = int.from_bytes(sec_bin[33:65], 'big')
            return S256Point(x=x, y=y)
        is_even = sec_bin[0] == 2  # <b class="conum">(2)</b>
        x = S256Field(int.from_bytes(sec_bin[1:], 'big'))
        # right side of the equation y^2 = x^3 + 7
        alpha = x**3 + S256Field(B)
        # solve for left side
        beta = alpha.sqrt()  # <b class="conum">(3)</b>
        if beta.num % 2 == 0:  # <b class="conum">(4)</b>
            even_beta = beta
            odd_beta = S256Field(P - beta.num)
        else:
            even_beta = S256Field(P - beta.num)
            odd_beta = beta
        if is_even:
            return S256Point(x, even_beta)
        else:
            return S256Point(x, odd_beta)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The uncompressed SEC format is pretty straightforward.</p>
</li>
<li>
<p>The evenness of the <em>y</em> coordinate is given in the first byte.</p>
</li>
<li>
<p>We take the square root of the right side of the elliptic curve equation to get <em>y</em>.</p>
</li>
<li>
<p>We determine evenness and return the correct point.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_2_4">Exercise 2</h4>
<div class="paragraph">
<p>Find the compressed SEC format for the public key where the private key secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5,001</p>
</li>
<li>
<p>2,019<sup>5</sup></p>
</li>
<li>
<p>0xdeadbeef54321</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_der_signatures">DER Signatures</h3>
<div class="paragraph">
<p>Another class that we need to learn to serialize is <code>Signature</code>.
Much like the SEC format, it needs to encode two different numbers, <code>r</code> and <code>s</code>.
Unfortunately, unlike <code>S256Point</code>, <code>Signature</code> cannot be compressed as <code>s</code> cannot be derived solely from <code>r</code>.</p>
</div>
<div class="paragraph">
<p>The standard for serializing signatures (and lots of other things, for that matter) is called Distinguished Encoding Rules (DER) format. DER format was used by Satoshi to serialize signatures.
This was most likely because the standard was already defined in 2008, was supported in the OpenSSL library (used in Bitcoin at the time), and was easy enough to adopt, rather than creating a new standard.</p>
</div>
<div class="paragraph">
<p>DER signature format is defined like this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start with the <code>0x30</code> byte.</p>
</li>
<li>
<p>Encode the length of the rest of the signature (usually <code>0x44</code> or <code>0x45</code>) and append.</p>
</li>
<li>
<p>Append the marker byte, <code>0x02</code>.</p>
</li>
<li>
<p>Encode <code>r</code> as a big-endian integer, but prepend it with the <code>0x00</code> byte if <code>r&#8217;s first byte &ge; `0x80</code>.
Prepend the resulting length to <code>r</code>.
Add this to the result.</p>
</li>
<li>
<p>Append the marker byte, <code>0x02</code>.</p>
</li>
<li>
<p>Encode <code>s</code> as a big-endian integer, but prepend with the <code>0x00</code> byte if <code>s&#8217;s first byte &ge; `0x80</code>.
Prepend the resulting length to <code>s</code>.
Add this to the result.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The rules for #4 and #6 with the first byte starting with something greater than or equal to <code>0x80</code> are because DER is a general encoding and allows for negative numbers to be encoded.
The first bit being 1 means that the number is negative.
All numbers in an ECDSA signature are positive, so we have to prepend with <code>0x00</code> if the first bit is 1, which is equivalent to first byte &ge; <code>0x80</code>.</p>
</div>
<div class="paragraph">
<p>The DER format is shown in <a href="#der_format">DER format</a>.</p>
</div>
<div id="der_format" class="imageblock">
<div class="content">
<img src="./images/prbc_0404.png" alt="DER format">
</div>
<div class="title">Figure 39. DER format</div>
</div>
<div class="paragraph">
<p>Because we know <code>r</code> is a 256-bit integer, <code>r</code> will be at most 32 bytes expressed as big-endian.
It&#8217;s also possible the first byte could be &ge; 0x80, so #4 can be at most 33 bytes.
However, if <code>r</code> is a relatively small number, it could be less than 32 bytes.
The same goes for <code>s</code> and #6.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how this is coded in Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Signature:
...
    def der(self):
        rbin = self.r.to_bytes(32, byteorder='big')
        # remove all null bytes at the beginning
        rbin = rbin.lstrip(b'\x00')
        # if rbin has a high bit, add a \x00
        if rbin[0] &amp; 0x80:
            rbin = b'\x00' + rbin
        result = bytes([2, len(rbin)]) + rbin  # <b class="conum">(1)</b>
        sbin = self.s.to_bytes(32, byteorder='big')
        # remove all null bytes at the beginning
        sbin = sbin.lstrip(b'\x00')
        # if sbin has a high bit, add a \x00
        if sbin[0] &amp; 0x80:
            sbin = b'\x00' + sbin
        result += bytes([2, len(sbin)]) + sbin
        return bytes([0x30, len(result)]) + result</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>In Python 3, you can convert a list of numbers to the byte equivalents using <code>bytes([some_integer1, some_integer2])</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Overall, this is an inefficient way to encode <code>r</code> and <code>s</code> as there are at least 6 bytes that aren&#8217;t strictly necessary.</p>
</div>
<div class="sect3">
<h4 id="_exercise_3_4">Exercise 3</h4>
<div class="paragraph">
<p>Find the DER format for a signature whose <code>r</code> and <code>s</code> values are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>r = 0x37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6

s = 0x8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_base58">Base58</h3>
<div class="paragraph">
<p>In the early days of Bitcoin, bitcoins were assigned to public keys specified in SEC format (uncompressed) and then were redeemed using DER signatures.
For reasons we&#8217;ll get to in <a href="#chapter_script">Script</a>, using this particular very simple script turned out to be both wasteful for storing unspent transaction outputs (UTXOs) and a little less secure than the scripts in more prominent use now.
For now, we&#8217;ll go through what addresses are and how they are encoded.</p>
</div>
<div class="sect3">
<h4 id="_transmitting_your_public_key">Transmitting Your Public Key</h4>
<div class="paragraph">
<p>In order for Alice to pay Bob, she has to know where to send the money.
This is true not just in Bitcoin, but for any method of payment.
Since Bitcoin is a digital bearer instrument, the address can be something like a public key in a public key cryptography scheme.
Unfortunately, SEC format, especially uncompressed, is a bit long (65 or 33 bytes).
Furthermore, the 65 or 33 bytes are in binary format—not something that&#8217;s easy to read, at least raw.</p>
</div>
<div class="paragraph">
<p>There are three major considerations.
The first is that the public key be readable (easy to hand-write and not too difficult to mistake, say, over the phone).
The second is that it&#8217;s short (not so long that it&#8217;s cumbersome).
The third is that it&#8217;s secure (so it&#8217;s harder to make mistakes).</p>
</div>
<div class="paragraph">
<p>So how do we get readability, compression, and security?
If we express the SEC format in hexadecimal (4 bits per character), it&#8217;s double the length (130 or 66 characters).
Can we do better?</p>
</div>
<div class="paragraph">
<p>We can use something like Base64, which can express 6 bits per character. This results in 87 characters for uncompressed SEC and 44 characters for compressed SEC.
Unfortunately, Base64 is prone to mistakes, as a lot of letters and numbers look similar (<code>0</code> and <code>O</code>, <code>l</code> and <code>I</code>, <code>-</code> and <code>_</code>).
If we remove these characters, we can achieve a result that has good readability and decent compression (around 5.86 bits per character).
Lastly, we can add a checksum at the end to ensure that mistakes are easy to detect.</p>
</div>
<div class="paragraph">
<p>This construction is called <em>Base58</em>.
Instead of hexadecimal (base 16) or Base64, we&#8217;re encoding numbers in Base58.</p>
</div>
<div class="paragraph">
<p>The actual mechanics of doing the Base58 encoding are as follows.</p>
</div>
<div class="paragraph">
<p>All numbers, uppercase letters, and lowercase letters are utilized, except for the aforementioned <code>0/O</code> and <code>l/I</code>.
That leaves us with 10 + 26 + 26 – 4 = 58.
Each of these characters represents a digit in Base58.
We can encode with a function that does exactly this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
...
def encode_base58(s):
    count = 0
    for c in s:  # <b class="conum">(1)</b>
        if c == 0:
            count += 1
        else:
            break
    num = int.from_bytes(s, 'big')
    prefix = '1' * count
    result = ''
    while num &gt; 0:  # <b class="conum">(2)</b>
        num, mod = divmod(num, 58)
        result = BASE58_ALPHABET[mod] + result
    return prefix + result  # <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The purpose of this loop is to determine how many of the bytes at the front are 0 bytes.
We want to add them back at the end.</p>
</li>
<li>
<p>This is the loop that figures out what Base58 digit to use.</p>
</li>
<li>
<p>Finally, we prepend all the zeros that we counted at the front, because otherwise they wouldn&#8217;t show up as prefixed ones.
This annoyingly happens with pay-to-pubkey-hash (p2pkh); more on that in <a href="#chapter_script">Script</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This function will take any bytes in Python 3 and convert them to Base58.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Why Base58 Is on the Way Out</div>
<div class="paragraph">
<p>Base58 has been used for a long time, and while it does make it somewhat easier than something like Base64 to communicate, it&#8217;s not really that convenient.
Most people prefer to copy and paste the addresses, and if you&#8217;ve ever tried to communicate a Base58 address vocally, you know it can be a nightmare.</p>
</div>
<div class="paragraph">
<p>What&#8217;s much better is the new Bech32 standard, which is defined in BIP0173.
Bech32 uses a 32-character alphabet that&#8217;s just numbers and lowercase letters, except <code>1</code>, <code>b</code>, <code>i</code>, and <code>o</code>.
Thus far, it&#8217;s only used for Segwit (<a href="#chapter_segwit">Segwit</a>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_exercise_4_4">Exercise 4</h4>
<div class="paragraph">
<p>Convert the following hex values to binary and then to Base58:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d</code></p>
</li>
<li>
<p><code>eff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c</code></p>
</li>
<li>
<p><code>c7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_address_format">Address Format</h4>
<div class="paragraph">
<p>The 264 bits from compressed SEC format are still a bit too long, not to mention a bit less secure (see <a href="#chapter_script">Script</a>).
To both shorten the address and increase security, we can use the ripemd160 hash.</p>
</div>
<div class="paragraph">
<p>By not using the SEC format directly, we can go from 33 bytes to 20 bytes, shortening the address significantly.
Here is how a Bitcoin address is created:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For mainnet addresses, start with the prefix <code>0x00</code>, for testnet <code>0x6f</code>.</p>
</li>
<li>
<p>Take the SEC format (compressed or uncompressed) and do a sha256 operation followed by the ripemd160 hash operation, the combination of which is called a hash160 operation.</p>
</li>
<li>
<p>Combine the prefix from #1 and resulting hash from #2.</p>
</li>
<li>
<p>Do a hash256 of the result from #3 and get the first 4 bytes.</p>
</li>
<li>
<p>Take the combination of #3 and #4 and encode it in Base58.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The result of step 4 of this process is called the <em>checksum</em>.
We can do steps 4 and 5 in one go this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def encode_base58_checksum(b):
    return encode_base58(b + hash256(b)[:4])</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">What Is Testnet?</div>
<div class="paragraph">
<p>Testnet is a parallel Bitcoin network that&#8217;s meant to be used by developers.
The coins on there are not worth anything and the proof-of-work required to find a block is relatively easy.
The mainnet chain as of this writing has around 550,000 blocks, while testnet has significantly more (around 1,450,000 blocks).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can implement the hash160 operation in <em>helper.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def hash160(s):
    '''sha256 followed by ripemd160'''
    return hashlib.new('ripemd160', hashlib.sha256(s).digest()).digest()  # <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Note that <code>hashlib.sha256(s).digest</code> does the sha256 and the wrapper around it does the ripemd160.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can also update <code>S256Point</code> with <code>hash160</code> and <code>address</code> methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class S256Point:
...
    def hash160(self, compressed=True):
        return hash160(self.sec(compressed))

    def address(self, compressed=True, testnet=False):
        '''Returns the address string'''
        h160 = self.hash160(compressed)
        if testnet:
            prefix = b'\x6f'
        else:
            prefix = b'\x00'
        return encode_base58_checksum(prefix + h160)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_4">Exercise 5</h4>
<div class="paragraph">
<p>Find the addresses corresponding to the public keys whose private key secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5002 (use uncompressed SEC on testnet)</p>
</li>
<li>
<p>2020<sup>5</sup> (use compressed SEC on testnet)</p>
</li>
<li>
<p>0x12345deadbeef (use compressed SEC on mainnet)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_wif_format">WIF Format</h4>
<div class="paragraph">
<p>The private key in our case is a 256-bit number.
Generally, we are not going to need to serialize our secret that often, as it doesn&#8217;t get broadcast (that would be a bad idea!).
That said, there are instances where you may want to transfer your private key from one wallet to another—for example, from a paper wallet to a software wallet.</p>
</div>
<div class="paragraph">
<p>For this purpose, you can use Wallet Import Format (WIF).
WIF is a serialization of the private key that&#8217;s meant to be human-readable.
WIF uses the same Base58 encoding that addresses use.</p>
</div>
<div class="paragraph">
<p>Here is how the WIF format is created:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For mainnet private keys, start with the prefix <code>0x80</code>, for testnet <code>0xef</code>.</p>
</li>
<li>
<p>Encode the secret in 32-byte big-endian.</p>
</li>
<li>
<p>If the SEC format used for the public key address was compressed, add a suffix of <code>0x01</code>.</p>
</li>
<li>
<p>Combine the prefix from #1, serialized secret from #2, and suffix from #3.</p>
</li>
<li>
<p>Do a hash256 of the result from #4 and get the first 4 bytes.</p>
</li>
<li>
<p>Take the combination of #4 and #5 and encode it in Base58.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can now create the <code>wif</code> method on the <code>PrivateKey</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class PrivateKey
...
    def wif(self, compressed=True, testnet=False):
        secret_bytes = self.secret.to_bytes(32, 'big')
        if testnet:
            prefix = b'\xef'
        else:
            prefix = b'\x80'
        if compressed:
            suffix = b'\x01'
        else:
            suffix = b''
        return encode_base58_checksum(prefix + secret_bytes + suffix)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_4">Exercise 6</h4>
<div class="paragraph">
<p>Find the WIF for the private key whose secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5003 (compressed, testnet)</p>
</li>
<li>
<p>2021<sup>5</sup> (uncompressed, testnet)</p>
</li>
<li>
<p>0x54321deadbeef (compressed, mainnet)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_big_and_little_endian_redux">Big- and Little-Endian Redux</h3>
<div class="paragraph">
<p>It will be very useful to know how big- and little-endian are done in Python, as the next few chapters will be parsing and serializing numbers to and from big-/little-endian quite a bit.
In particular, Satoshi used a lot of little-endian for Bitcoin and unfortunately, there&#8217;s no easy-to-learn rule for where little-endian is used and where big-endian is used.
Recall that SEC format uses big-endian encoding, as do addresses and WIF.
From <a href="#chapter_tx_parsing">Transactions</a> onward, we will use little-endian encoding a lot more.
For this reason, we turn to the next two exercises.
The last exercise of this section is to create a testnet address for yourself.</p>
</div>
<div class="sect3">
<h4 id="_exercise_7_4">Exercise 7</h4>
<div class="paragraph">
<p>Write a function <code>little_endian_to_int</code> that takes Python bytes, interprets those bytes in little-endian, and returns the number.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_8_2">Exercise 8</h4>
<div class="paragraph">
<p>Write a function <code>int_to_little_endian</code> that does the reverse of the last exercise.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_9_2">Exercise 9</h4>
<div class="paragraph">
<p>Create a testnet address for yourself using a long secret that only you know. This is important as there are bots on testnet trying to steal testnet coins. Make sure you write this secret down somewhere! You will be using it later to sign transactions.</p>
</div>
<div class="paragraph">
<p>Go to a <a href="https://faucet.programmingbitcoin.com">testnet faucet</a> and send some testnet coins to that address (it should start with <code>m</code> or <code>n</code>, or else something is wrong).
If you succeeded, congrats!
You&#8217;re now the proud owner of some testnet coins!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_4">Conclusion</h3>
<div class="paragraph">
<p>In this chapter we learned how to serialize a lot of different structures that we created in the previous chapters.
We now turn to parsing and understanding transactions.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_tx_parsing">Transactions</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>Transactions are at the heart of Bitcoin.
Transactions, simply put, are value transfers from one entity to another.
We&#8217;ll see in <a href="#chapter_script">Script</a> how "entities" in this case are really smart contracts—but we&#8217;re getting ahead of ourselves.
Let&#8217;s first look at what transactions in Bitcoin are, what they look like, and how they are parsed.</p>
</div>
<div class="sect2">
<h3 id="_transaction_components">Transaction Components</h3>
<div class="paragraph">
<p>At a high level, a transaction really only has four components.
They are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Version</p>
</li>
<li>
<p>Inputs</p>
</li>
<li>
<p>Outputs</p>
</li>
<li>
<p>Locktime</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A general overview of these fields might be helpful.
The version indicates what additional features the transaction uses, inputs define what bitcoins are being spent, outputs define where the bitcoins are going, and locktime defines when this transaction starts being valid.
We&#8217;ll go through each component in depth.</p>
</div>
<div class="paragraph">
<p><a href="#transaction_components_version_inputs_output_locktime">Transaction components: version, inputs, outputs, and locktime</a> shows a hexadecimal dump of a typical transaction that shows which parts are which.</p>
</div>
<div id="transaction_components_version_inputs_output_locktime" class="imageblock">
<div class="content">
<img src="./images/prbc_0501.png" alt="Transaction Version Inputs Outputs and Locktime">
</div>
<div class="title">Figure 40. Transaction components: version, inputs, outputs, and locktime</div>
</div>
<div class="paragraph">
<p>The differently highlighted parts represent the version, inputs, outputs, and locktime, respectively.</p>
</div>
<div class="paragraph">
<p>With this in mind, we can start constructing the transaction class, which we&#8217;ll call <code>Tx</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:

    def __init__(self, version, tx_ins, tx_outs, locktime, testnet=False):
        self.version = version
        self.tx_ins = tx_ins  # <b class="conum">(1)</b>
        self.tx_outs = tx_outs
        self.locktime = locktime
        self.testnet = testnet  # <b class="conum">(2)</b>

    def __repr__(self):
        tx_ins = ''
        for tx_in in self.tx_ins:
            tx_ins += tx_in.__repr__() + '\n'
        tx_outs = ''
        for tx_out in self.tx_outs:
            tx_outs += tx_out.__repr__() + '\n'
        return 'tx: {}\nversion: {}\ntx_ins:\n{}tx_outs:\n{}locktime: {}'.format(
            self.id(),
            self.version,
            tx_ins,
            tx_outs,
            self.locktime,
        )

    def id(self):  # <b class="conum">(3)</b>
        '''Human-readable hexadecimal of the transaction hash'''
        return self.hash().hex()

    def hash(self):  # <b class="conum">(4)</b>
        '''Binary hash of the legacy serialization'''
        return hash256(self.serialize())[::-1]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Input and output are very generic terms, so we specify what kind of inputs they are.
We&#8217;ll define the specific object types later.</p>
</li>
<li>
<p>We need to know which network this transaction is on to be able to validate it fully.</p>
</li>
<li>
<p>The <code>id</code> is what block explorers use for looking up transactions.
It&#8217;s the hash256 of the transaction in hexadecimal format.</p>
</li>
<li>
<p>The hash is the hash256 of the serialization in little-endian.
Note we don&#8217;t have the <code>serialize</code> method yet; so until we do, this won&#8217;t work.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The rest of this chapter will be concerned with parsing transactions.
We could, at this point, write code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
    ...

    @classmethod  # <b class="conum">(1)</b>
    def parse(cls, serialization):
        version = serialization[0:4]  # <b class="conum">(2)</b>
	...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This method has to be a class method as the serialization will return a new instance of a <code>Tx</code> object.</p>
</li>
<li>
<p>We assume here that the variable <code>serialization</code> is a byte array.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This could definitely work, but the transaction may be very large.
Ideally, we want to be able to parse from a <em>stream</em> instead.
This will allow us to not need the entire serialized transaction before we start parsing, and that allows us to fail early and be more efficient.
Thus, the code for parsing a transaction will look more like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
    ...

    @classmethod
    def parse(cls, stream):
        serialized_version = stream.read(4)  # <b class="conum">(1)</b>
	...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>read</code> method will allow us to parse on the fly as we won&#8217;t have to wait on I/O.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is advantageous from an engineering perspective as the stream can be a socket connection on the network or a file handle.
We can start parsing the stream right away instead of waiting for the whole thing to be transmitted or read first.
Our method will be able to handle any sort of stream and return the <code>Tx</code> object that we need.</p>
</div>
</div>
<div class="sect2">
<h3 id="_version">Version</h3>
<div class="paragraph">
<p>When you see a version number in something (<a href="#version_chap_five">Version</a> shows an example), it&#8217;s meant to give the receiver information about what the versioned thing is supposed to represent.
If, for example, you are running Windows 3.1, that&#8217;s a version number that&#8217;s very different than Windows 8 or Windows 10.
You could specify just "Windows," but specifying the version number after the operating system helps you know what features it has and what APIs you can program against.</p>
</div>
<div id="version_chap_five" class="imageblock">
<div class="content">
<img src="./images/prbc_0502.png" alt="Version">
</div>
<div class="title">Figure 41. Version</div>
</div>
<div class="paragraph">
<p>Similarly, Bitcoin transactions have version numbers.
In Bitcoin&#8217;s case, the transaction version is generally 1, but there are cases where it can be 2 (transactions using an opcode called <code>OP_CHECKSEQUENCEVERIFY</code> as defined in BIP0112 require use of version &gt; 1).</p>
</div>
<div class="paragraph">
<p>You may notice here that the actual value in hexadecimal is <code>01000000</code>, which doesn&#8217;t look like 1.
Interpreted as a little-endian integer, however, this number is actually 1 (recall the discussion from <a href="#chapter_serialization">Serialization</a>).</p>
</div>
<div class="sect3">
<h4 id="_exercise_1_5">Exercise 1</h4>
<div class="paragraph">
<p>Write the version parsing part of the <code>parse</code> method that we&#8217;ve defined. To do this properly, you&#8217;ll have to convert 4 bytes into a little-endian integer.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inputs">Inputs</h3>
<div class="paragraph">
<p>Each input points to an output of a previous transaction (see <a href="#inputs_chap_five">Inputs</a>).
This fact requires more explanation, as it&#8217;s not intuitively obvious at first.</p>
</div>
<div id="inputs_chap_five" class="imageblock">
<div class="content">
<img src="./images/prbc_0503.png" alt="Inputs">
</div>
<div class="title">Figure 42. Inputs</div>
</div>
<div class="paragraph">
<p>Bitcoin&#8217;s inputs are spending outputs of a previous transaction.
That is, you need to have received bitcoins first to spend something.
This makes intuitive sense.
You cannot spend money unless you&#8217;ve received money first.
The inputs refer to bitcoins that belong to you. Each input needs two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A reference to bitcoins you received previously</p>
</li>
<li>
<p>Proof that these are yours to spend</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The second part uses ECDSA (<a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>).
You don&#8217;t want people to be able to forge this, so most inputs contain signatures that only the owner(s) of the private key(s) can produce.</p>
</div>
<div class="paragraph">
<p>The inputs field can contain more than one input.
This is analogous to using either a single $100 bill to pay for a $70 meal, or a $50 and a $20.
The former only requires one input ("bill"); the latter requires two.
There are situations where there could be even more inputs.
In our analogy, we could pay for a $70 meal with 14 $5 bills, or even 7,000 pennies.
This would be analogous to 14 inputs or 7,000 inputs.</p>
</div>
<div class="paragraph">
<p>The number of inputs is the next part of the transaction, as highlighted in <a href="#number_of_inputs">Number of inputs</a>.</p>
</div>
<div id="number_of_inputs" class="imageblock">
<div class="content">
<img src="./images/prbc_0504.png" alt="Inputs">
</div>
<div class="title">Figure 43. Number of inputs</div>
</div>
<div class="paragraph">
<p>We can see that the byte is actually <code>01</code>, which means that this transaction has one input.
It may be tempting here to assume that it&#8217;s always a single byte, but it&#8217;s not.
A single byte has 8 bits, so anything over 255 inputs will not be expressible in a single byte.</p>
</div>
<div class="paragraph">
<p>This is where <em>varints</em> come in.
Varint is shorthand for <em>variable integer</em>, which is a way to encode an integer into bytes that range from 0 to 2<sup>64</sup> – 1.
We could, of course, always reserve 8 bytes for the number of inputs, but that would be a lot of wasted space if we expect the number of inputs to be relatively small (say, under 200).
This is the case with the number of inputs in a normal transaction, so using varints helps to save space.
You can see how they work in the following sidebar.</p>
</div>
<div class="sidebarblock pagebreak-before less_space">
<div class="content">
<div class="title">Varints</div>
<div class="paragraph">
<p>Variable integers work by these rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the number is below 253, encode that number as a single byte (e.g., 100 &#8594; <code>0x64</code>).</p>
</li>
<li>
<p>If the number is between 253 and 2<sup>16</sup> – 1, start with the 253 byte (<code>fd</code>) and then encode the number in 2 bytes in little-endian (e.g., 255 &#8594; <code>0xfdff00</code>, 555 &#8594; <code>0xfd2b02</code>).</p>
</li>
<li>
<p>If the number is between 2<sup>16</sup> and 2<sup>32</sup> – 1, start with the 254 byte (<code>fe</code>) and then encode the number in 4 bytes in little-endian (e.g., 70015 &#8594; <code>0xfe7f110100</code>).</p>
</li>
<li>
<p>If the number is between 2<sup>32</sup> and 2<sup>64</sup> – 1, start with the 255 byte (<code>ff</code>) and then encode the number in 8 bytes in little-endian (e.g., 18005558675309 &#8594; <code>0xff6dc7ed3e60100000</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Two functions from <em>helper.py</em> will be used to parse and serialize varint fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def read_varint(s):
    '''read_varint reads a variable integer from a stream'''
    i = s.read(1)[0]
    if i == 0xfd:
        # 0xfd means the next two bytes are the number
        return little_endian_to_int(s.read(2))
    elif i == 0xfe:
        # 0xfe means the next four bytes are the number
        return little_endian_to_int(s.read(4))
    elif i == 0xff:
        # 0xff means the next eight bytes are the number
        return little_endian_to_int(s.read(8))
    else:
        # anything else is just the integer
        return i


def encode_varint(i):
    '''encodes an integer as a varint'''
    if i &lt; 0xfd:
        return bytes([i])
    elif i &lt; 0x10000:
        return b'\xfd' + int_to_little_endian(i, 2)
    elif i &lt; 0x100000000:
        return b'\xfe' + int_to_little_endian(i, 4)
    elif i &lt; 0x10000000000000000:
        return b'\xff' + int_to_little_endian(i, 8)
    else:
        raise ValueError('integer too large: {}'.format(i))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>read_varint</code> will read from a stream and return the integer that was encoded.
<code>encode_varint</code> will do the opposite, which is to take an integer and return the varint byte representation.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Each input contains four fields.
The first two fields point to the previous transaction output and the last two fields define how the previous transaction output can be spent.
The fields are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Previous transaction ID</p>
</li>
<li>
<p>Previous transaction index</p>
</li>
<li>
<p>ScriptSig</p>
</li>
<li>
<p>Sequence</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As just explained, each input has a reference to a previous transaction&#8217;s output.
The previous transaction ID is the hash256 of the previous transaction&#8217;s contents.
This uniquely defines the previous transaction, as the probability of a hash collision is impossibly low.</p>
</div>
<div class="paragraph">
<p>As we&#8217;ll see, each transaction has to have at least one output, but may have many.
Thus, we need to define exactly which output <em>within a transaction</em> we&#8217;re spending, which is captured in the previous transaction index.</p>
</div>
<div class="paragraph">
<p>Note that the previous transaction ID is 32 bytes and that the previous transaction index is 4 bytes.
Both are in little-endian.</p>
</div>
<div class="paragraph">
<p>The ScriptSig has to do with Bitcoin&#8217;s smart contract language, Script, discussed more thoroughly in <a href="#chapter_script">Script</a>.
For now, think of the ScriptSig as opening a locked box—something that can only be done by the owner of the transaction output.
The ScriptSig field is a variable-length field, not a fixed-length field like most of what we&#8217;ve seen so far.
A variable-length field requires us to define exactly how long the field will be, which is why the field is preceded by a varint telling us how long it is.</p>
</div>
<div class="paragraph">
<p>The sequence was originally intended as a way to do what Satoshi called "high-frequency trades" with the locktime field (see <a href="#sequence_and_locktime">Sequence and Locktime</a>), but is currently used with Replace-By-Fee (RBF) and <code>OP_CHECKSEQUENCEVERIFY</code>.
The sequence is also in little-endian and takes up 4 bytes.</p>
</div>
<div class="paragraph">
<p>The fields of the input look like <a href="#the_fields_of_an_input_previous_tx_previous_index_scriptsig_and_sequence">The fields of an input: previous transaction ID, previous index, ScriptSig, and sequence</a>.</p>
</div>
<div id="the_fields_of_an_input_previous_tx_previous_index_scriptsig_and_sequence" class="imageblock">
<div class="content">
<img src="./images/prbc_0505.png" alt="Input Fields">
</div>
<div class="title">Figure 44. The fields of an input: previous transaction ID, previous index, ScriptSig, and sequence</div>
</div>
<div id="sequence_and_locktime" class="sidebarblock">
<div class="content">
<div class="title">Sequence and Locktime</div>
<div class="paragraph">
<p>Originally, Satoshi wanted the sequence and locktime fields to be used for something called "high-frequency trades."
What Satoshi envisioned was a way to do payments back and forth with another party without making lots of on-chain transactions.
For example, if Alice pays Bob <em>x</em> bitcoins for something and then Bob pays Alice <em>y</em> bitcoins for something else (say, if <em>x</em> &gt; <em>y</em>), then Alice can just pay Bob <em>x</em> – <em>y</em>, instead of there being two separate transactions on-chain.
We could do the same thing if Alice and Bob had 100 transactions between them—that is, compress a bunch of transactions into a single transaction.</p>
</div>
<div class="paragraph">
<p>That&#8217;s the idea that Satoshi had: a continuously updating mini-ledger between the two parties involved that gets settled on-chain.
Satoshi&#8217;s intent was to use the sequence and locktime fields to update the high-frequency trade transaction every time a new payment between the two parties occurred.
The trade transaction would have two inputs (one from Alice and one from Bob) and two outputs (one to Alice and one to Bob).
The trade transaction would start with sequence at 0 and with a far-away locktime (say, 500 blocks from now, so valid in 500 blocks).
This would be the base transaction where Alice and Bob get the same amounts as they put in.</p>
</div>
<div class="paragraph">
<p>After the first transaction, where Alice pays Bob <em>x</em> bitcoins, the sequence of each input would be 1.
After the second transaction, where Bob pays Alice <em>y</em> bitcoins, the sequence of each input would be 2.
Using this method, we could have lots of payments compressed into a single on-chain transaction as long as they happened before the locktime became valid.</p>
</div>
<div class="paragraph">
<p>Unfortunately, as clever as this is, it turns out that it&#8217;s quite easy for a miner to cheat.
In our example, Bob could be a miner; he could ignore the updated trade transaction with sequence number 2 and mine the trade transaction with sequence number 1, cheating Alice out of <em>y</em> bitcoins.</p>
</div>
<div class="paragraph">
<p>A much better design was created later with "payment channels," which is the basis for the Lightning Network.</p>
</div>
</div>
</div>
<div class="paragraph pagebreak-before">
<p>Now that we know what the fields are, we can start creating a <code>TxIn</code> class in Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class TxIn:
    def __init__(self, prev_tx, prev_index, script_sig=None, sequence=0xffffffff):
        self.prev_tx = prev_tx
        self.prev_index = prev_index
        if script_sig is None:  # <b class="conum">(1)</b>
            self.script_sig = Script()
        else:
            self.script_sig = script_sig
        self.sequence = sequence

    def __repr__(self):
        return '{}:{}'.format(
            self.prev_tx.hex(),
            self.prev_index,
        )</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We default to an empty ScriptSig.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There are a couple things to note here.
First, the amount of each input is not specified.
We have no idea how much is being spent unless we look it up in the blockchain for the transaction(s) that we&#8217;re spending.
Furthermore, we don&#8217;t even know if the transaction is unlocking the right box, so to speak, without knowing about the previous transaction.
Every node must verify that this transaction unlocks the right box and that it doesn&#8217;t spend nonexistent bitcoins.
How we do that is further discussed in <a href="#chapter_tx">Transaction Creation and Validation</a>.</p>
</div>
<div class="sect3">
<h4 id="_parsing_script">Parsing Script</h4>
<div class="paragraph">
<p>We&#8217;ll delve more deeply into how Script is parsed in <a href="#chapter_script">Script</a>, but for now, here&#8217;s how you get a <code>Script</code> object from hexadecimal in Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from script import Script  # <b class="conum">(1)</b>
&gt;&gt;&gt; script_hex = ('6b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccf\
cf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8\
e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278\
a')
&gt;&gt;&gt; stream = BytesIO(bytes.fromhex(script_hex))
&gt;&gt;&gt; script_sig = Script.parse(stream)
&gt;&gt;&gt; print(script_sig)
3045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f0220\
7a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01 0349fc4e631\
e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278a</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>Script</code> class will be more thoroughly explored in <a href="#chapter_script">Script</a>.
For now, please trust that the <code>Script.parse</code> method will create the object that we need.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_5">Exercise 2</h4>
<div class="paragraph">
<p>Write the inputs parsing part of the <code>parse</code> method in <code>Tx</code> and the <code>parse</code> method for <code>TxIn</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_outputs">Outputs</h3>
<div class="paragraph">
<p>As hinted in the previous section, outputs define where the bitcoins are going.
Each transaction must have one or more outputs.
Why would anyone have more than one output?
An exchange may batch transactions, for example, and pay out to a lot of people at once instead of generating a single transaction for every single person that requests bitcoins.</p>
</div>
<div class="paragraph">
<p>Like with inputs, output serialization starts with how many outputs there are as a varint, as shown in <a href="#number_of_outputs">Number of outputs</a>.</p>
</div>
<div id="number_of_outputs" class="imageblock">
<div class="content">
<img src="./images/prbc_0506.png" alt="Outputs">
</div>
<div class="title">Figure 45. Number of outputs</div>
</div>
<div class="paragraph">
<p>Each output has two fields: amount and ScriptPubKey.
The amount is the amount of bitcoins being assigned and is specified in satoshis, or 1/100,000,000ths of a bitcoin.
This allows us to divide bitcoins very finely, down to 1/300th of a penny in USD terms as of this writing.
The absolute maximum for the amount is the asymptotic limit of 21 million bitcoins in satoshis, which is 2,100,000,000,000,000 (2,100 trillion) satoshis.
This number is greater than 2<sup>32</sup> (4.3 billion or so) and is thus stored in 64 bits, or 8 bytes.
The amount is serialized in little-endian.</p>
</div>
<div class="paragraph">
<p>The ScriptPubKey, like the ScriptSig, has to do with Bitcoin&#8217;s smart contract language, Script.
Think of the ScriptPubKey as the locked box that can only be opened by the holder of the key.
It&#8217;s like a one-way safe that can receive deposits from anyone, but can only be opened by the owner of the safe.
We&#8217;ll explore this in more detail in <a href="#chapter_script">Script</a>.
Like ScriptSig, ScriptPubKey is a variable-length field and is preceded by the length of the field in a varint.</p>
</div>
<div class="paragraph">
<p>A complete output looks like <a href="#output_fields_amount_and_scriptpubkey_this_one_is_at_index_0">A complete output field, showing the amount and ScriptPubKey—this one is at index 0</a>.</p>
</div>
<div id="output_fields_amount_and_scriptpubkey_this_one_is_at_index_0" class="imageblock">
<div class="content">
<img src="./images/prbc_0507.png" alt="Output Fields">
</div>
<div class="title">Figure 46. A complete output field, showing the amount and ScriptPubKey—this one is at index 0</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">UTXO Set</div>
<div class="paragraph">
<p>UTXO stands for <em>unspent transaction output</em>.
The entire set of unspent transaction outputs at any given moment is called the <em>UTXO set</em>.
The reason why UTXOs are important is because at any moment in time, they represent all the bitcoins that are available to be spent.
In other words, these are the bitcoins that are in circulation.
Full nodes on the network must keep track of the UTXO set, and keeping the UTXO set indexed makes validating new transactions much faster.</p>
</div>
<div class="paragraph">
<p>For example, it&#8217;s easy to enforce a no-double-spending rule by looking up the previous transaction output in the UTXO set.
If the input of a new transaction is using a transaction output that&#8217;s not in the UTXO set, that&#8217;s an attempt at a double-spend or a nonexistent output and thus invalid.
Keeping the UTXO set handy is also very useful for validating transactions.
As we&#8217;ll see in <a href="#chapter_script">Script</a>, we need to look up the amount and ScriptPubKey from the previous transaction output to validate transactions, so having these UTXOs handy can speed up transaction validation.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We can now start coding the <code>TxOut</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class TxOut:

    def __init__(self, amount, script_pubkey):
        self.amount = amount
        self.script_pubkey = script_pubkey

    def __repr__(self):
        return '{}:{}'.format(self.amount, self.script_pubkey)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_5">Exercise 3</h4>
<div class="paragraph">
<p>Write the outputs parsing part of the <code>parse</code> method in <code>Tx</code> and the <code>parse</code> method for <code>TxOut</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_locktime">Locktime</h3>
<div class="paragraph">
<p>Locktime is a way to time-delay a transaction.
A transaction with a locktime of 600,000 cannot go into the blockchain until block 600,001.
This was originally construed as a way to do high-frequency trades (see <a href="#sequence_and_locktime">Sequence and Locktime</a>), which turned out to be insecure.
If the locktime is greater than or equal to 500,000,000, it&#8217;s a Unix timestamp.
If it&#8217;s less than 500,000,000, it&#8217;s a block number.
This way, transactions can be signed but unspendable until a certain point in Unix time or block height is reached.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">When Locktime Is Ignored</div>
<div class="paragraph">
<p>Note that locktime is ignored if the sequence numbers for every input are <code>ffffffff</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The serialization is in little-endian and 4 bytes (<a href="#locktime">Locktime</a>).</p>
</div>
<div id="locktime" class="imageblock">
<div class="content">
<img src="./images/prbc_0508.png" alt="Locktime">
</div>
<div class="title">Figure 47. Locktime</div>
</div>
<div class="paragraph">
<p>The main problem with using locktime is that the recipient of the transaction has no certainty that the transaction will be good when the locktime comes.
This is similar to a postdated bank check, which has the possibility of bouncing.
The sender can spend the inputs prior to the locktime transaction getting into the blockchain, thus invalidating the transaction at locktime.</p>
</div>
<div class="paragraph">
<p>The uses before BIP0065 were limited.
BIP0065 introduced <code>OP_CHECKLOCKTIMEVERIFY</code>, which makes locktime more useful by making an output unspendable until a certain locktime.</p>
</div>
<div class="sect3">
<h4 id="_exercise_4_5">Exercise 4</h4>
<div class="paragraph">
<p>Write the locktime parsing part of the <code>parse</code> method in <code>Tx</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_5">Exercise 5</h4>
<div class="paragraph">
<p>What are the ScriptSig of the second input, the ScriptPubKey of the first output, and the amount of the second output for this transaction?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>010000000456919960ac691763688d3d3bcea9ad6ecaf875df5339e148a1fc61c6ed7a069e0100
00006a47304402204585bcdef85e6b1c6af5c2669d4830ff86e42dd205c0e089bc2a821657e951
c002201024a10366077f87d6bce1f7100ad8cfa8a064b39d4e8fe4ea13a7b71aa8180f012102f0
da57e85eec2934a82a585ea337ce2f4998b50ae699dd79f5880e253dafafb7feffffffeb8f51f4
038dc17e6313cf831d4f02281c2a468bde0fafd37f1bf882729e7fd3000000006a473044022078
99531a52d59a6de200179928ca900254a36b8dff8bb75f5f5d71b1cdc26125022008b422690b84
61cb52c3cc30330b23d574351872b7c361e9aae3649071c1a7160121035d5c93d9ac96881f19ba
1f686f15f009ded7c62efe85a872e6a19b43c15a2937feffffff567bf40595119d1bb8a3037c35
6efd56170b64cbcc160fb028fa10704b45d775000000006a47304402204c7c7818424c7f7911da
6cddc59655a70af1cb5eaf17c69dadbfc74ffa0b662f02207599e08bc8023693ad4e9527dc42c3
4210f7a7d1d1ddfc8492b654a11e7620a0012102158b46fbdff65d0172b7989aec8850aa0dae49
abfb84c81ae6e5b251a58ace5cfeffffffd63a5e6c16e620f86f375925b21cabaf736c779f88fd
04dcad51d26690f7f345010000006a47304402200633ea0d3314bea0d95b3cd8dadb2ef79ea833
1ffe1e61f762c0f6daea0fabde022029f23b3e9c30f080446150b23852028751635dcee2be669c
2a1686a4b5edf304012103ffd6f4a67e94aba353a00882e563ff2722eb4cff0ad6006e86ee20df
e7520d55feffffff0251430f00000000001976a914ab0c0b2e98b1ab6dbf67d4750b0a56244948
a87988ac005a6202000000001976a9143c82d7df364eb6c75be8c80df2b3eda8db57397088ac46
430600</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coding_transactions">Coding Transactions</h3>
<div class="paragraph">
<p>We&#8217;ve parsed the transaction; now we want to do the opposite, which is serializing the transaction.
Let&#8217;s start with <code>TxOut</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class TxOut:
...
    def serialize(self):  # <b class="conum">(1)</b>
        '''Returns the byte serialization of the transaction output'''
        result = int_to_little_endian(self.amount, 8)
        result += self.script_pubkey.serialize()
        return result</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We&#8217;re going to serialize the TxOut object to a bunch of bytes.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can then proceed to <code>TxIn</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class TxIn:
...
    def serialize(self):
        '''Returns the byte serialization of the transaction input'''
        result = self.prev_tx[::-1]
        result += int_to_little_endian(self.prev_index, 4)
        result += self.script_sig.serialize()
        result += int_to_little_endian(self.sequence, 4)
        return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lastly, we can serialize <code>Tx</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def serialize(self):
        '''Returns the byte serialization of the transaction'''
        result = int_to_little_endian(self.version, 4)
        result += encode_varint(len(self.tx_ins))
        for tx_in in self.tx_ins:
            result += tx_in.serialize()
        result += encode_varint(len(self.tx_outs))
        for tx_out in self.tx_outs:
            result += tx_out.serialize()
        result += int_to_little_endian(self.locktime, 4)
        return result</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve used the <code>serialize</code> methods of both <code>TxIn</code> and <code>TxOut</code> to serialize <code>Tx</code>.</p>
</div>
<div class="paragraph">
<p>Note that the transaction fee is not specified anywhere!
This is because the fee is an implied amount, as described in the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_fee">Transaction Fee</h3>
<div class="paragraph">
<p>One of the consensus rules of Bitcoin is that for any non-coinbase transactions (more on coinbase transactions in <a href="#chapter_blocks">Blocks</a>), the sum of the inputs has to be greater than or equal to the sum of the outputs.
You may be wondering why the inputs and outputs can&#8217;t just be forced to be equal.
This is because if every transaction had zero cost, there wouldn&#8217;t be any incentive for miners to include transactions in blocks (see <a href="#chapter_blocks">Blocks</a>).
Fees are a way to incentivize miners to include transactions.
Transactions not in blocks (so-called <em>mempool transactions</em>) are not part of the blockchain and are not final.</p>
</div>
<div class="paragraph">
<p>The transaction fee is simply the sum of the inputs minus the sum of the outputs.
This difference is what the miner gets to keep.
As inputs don&#8217;t have an amount field, we have to look up the amount.
This requires access to the blockchain, specifically the UTXO set.
If you are not running a full node, this can be tricky, as you now need to trust some other entity to provide you with this information.</p>
</div>
<div class="paragraph">
<p>We are creating a new class to handle this, called <code>TxFetcher</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class TxFetcher:
    cache = {}

    @classmethod
    def get_url(cls, testnet=False):
        if testnet:
            return 'http://testnet.programmingbitcoin.com'
        else:
            return 'http://mainnet.programmingbitcoin.com'

    @classmethod
    def fetch(cls, tx_id, testnet=False, fresh=False):
        if fresh or (tx_id not in cls.cache):
            url = '{}/tx/{}.hex'.format(cls.get_url(testnet), tx_id)
            response = requests.get(url)
            try:
                raw = bytes.fromhex(response.text.strip())
            except ValueError:
                raise ValueError('unexpected response: {}'.format(response.text))
            if raw[4] == 0:
                raw = raw[:4] + raw[6:]
                tx = Tx.parse(BytesIO(raw), testnet=testnet)
                tx.locktime = little_endian_to_int(raw[-4:])
            else:
                tx = Tx.parse(BytesIO(raw), testnet=testnet)
            if tx.id() != tx_id:  # <b class="conum">(1)</b>
                raise ValueError('not the same id: {} vs {}'.format(tx.id(),
                                  tx_id))
            cls.cache[tx_id] = tx
        cls.cache[tx_id].testnet = testnet
        return cls.cache[tx_id]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We check that the ID is what we expect it to be.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You may be wondering why we don&#8217;t get just the specific output for the transaction and instead get the entire transaction.
This is because we don&#8217;t want to be trusting a third party!
By getting the entire transaction, we can verify the transaction ID (the hash256 of its contents) and be sure that we are indeed getting the transaction we asked for.
This is impossible unless we receive the entire transaction.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Why We Minimize Trusting Third Parties</div>
<div class="paragraph">
<p>As Nick Szabo eloquently wrote in his seminal essay <a href="https://nakamotoinstitute.org/trusted-third-parties/">"Trusted Third Parties are Security Holes"</a>, trusting third parties to provide correct data is <em>not</em> a good security practice.
The third party may be behaving well now, but you never know when it may get hacked, have an employee go rogue, or start implementing policies that are against your interests.
Part of what makes Bitcoin secure is <em>not</em> trusting, but verifying the data that we&#8217;re given.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can now create the appropriate method in <code>TxIn</code> to fetch the previous transaction and methods to get the previous transaction output&#8217;s amount and ScriptPubKey (the latter to be used in <a href="#chapter_script">Script</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class TxIn:
...
    def fetch_tx(self, testnet=False):
        return TxFetcher.fetch(self.prev_tx.hex(), testnet=testnet)

    def value(self, testnet=False):
        '''Get the output value by looking up the tx hash.
        Returns the amount in satoshi.
        '''
        tx = self.fetch_tx(testnet=testnet)
        return tx.tx_outs[self.prev_index].amount

    def script_pubkey(self, testnet=False):
        '''Get the ScriptPubKey by looking up the tx hash.
        Returns a Script object.
        '''
        tx = self.fetch_tx(testnet=testnet)
        return tx.tx_outs[self.prev_index].script_pubkey</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_calculating_the_fee">Calculating the Fee</h4>
<div class="paragraph">
<p>Now that we have the <code>value</code> method in <code>TxIn</code> that lets us access how many bitcoins are in each transaction input, we can calculate the fee for a transaction.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_5">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>fee</code> method for the <code>Tx</code> class.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_5">Conclusion</h3>
<div class="paragraph">
<p>We&#8217;ve covered exactly how to parse and serialize transactions and defined what the fields mean.
There are two fields that require more explanation, both related to Bitcoin&#8217;s smart contract language, Script.
To that topic we go in <a href="#chapter_script">Script</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_script">Script</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>The ability to lock and unlock coins is the mechanism by which we transfer bitcoin.
<em>Locking</em> is giving some bitcoins to some entity.
<em>Unlocking</em> is spending some bitcoins that you have received.</p>
</div>
<div class="paragraph">
<p>In this chapter we examine this locking/unlocking mechanism, which is often called a <em>smart contract</em>.
Elliptic curve cryptography (<a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>) is used by Script to validate that a transaction was properly authorized (<a href="#chapter_tx_parsing">Transactions</a>).
Script essentially allows people to prove that they have the right to spend certain UTXOs.
We&#8217;re getting a little ahead of ourselves, though, so let&#8217;s start with how Script works and go from there.</p>
</div>
<div class="sect2">
<h3 id="_mechanics_of_script">Mechanics of Script</h3>
<div class="paragraph">
<p>If you are confused about what a smart contract is, don&#8217;t worry.
"Smart contract" is a fancy way of saying "programmable," and the "smart contract language" is simply a programming language.
In Bitcoin, Script is the smart contract language, or the programming language used to express the conditions under which bitcoins are <span class="keep-together">spendable</span>.</p>
</div>
<div class="paragraph">
<p>Bitcoin has the digital equivalent of a contract in Script.
Script is a stack-based language similar to Forth.
It&#8217;s intentionally limited in the sense that it avoids certain features.
Specifically, Script avoids any mechanism for loops and is therefore not Turing complete.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Why Bitcoin Isn&#8217;t Turing Complete</div>
<div class="paragraph">
<p>Turing completeness in a programming language essentially means that the program has the ability to loop.
Loops are a useful construct in programming, so you may be wondering at this point why Script doesn&#8217;t have the ability to loop.</p>
</div>
<div class="paragraph">
<p>There are a lot of reasons for this, but let&#8217;s start with program execution.
Anyone can create a Script program that every full node on the network executes.
If Script were Turing complete, it would be possible for the loop to go on executing forever.
This would cause validating nodes to enter and never leave that loop.
This would be an easy way to attack the network through what would be called a denial-of-service (DoS) attack.
A single Script program with an infinite loop could take down Bitcoin!
This would be a large systematic vulnerability, and protecting against this vulnerability is one of the major reasons why Turing completeness is avoided.
Ethereum, which has Turing completeness in its smart contract language, Solidity, handles this problem by forcing contracts to pay for program execution with something called "gas."
An infinite loop will exhaust whatever gas is in the contract because, by definition, it will run an infinite number of times.</p>
</div>
<div class="paragraph">
<p>Another reason to avoid Turing completeness is because smart contracts with Turing completeness are very difficult to analyze.
A Turing-complete smart contract&#8217;s execution conditions are very difficult to enumerate, and thus it&#8217;s easy to create unintended behavior, causing bugs.
Bugs in a smart contract mean that the coins are vulnerable to being unintentionally spent, which means the contract participants could lose money.
Such bugs are not just theoretical: this was the major problem in the DAO (Decentralized Autonomous Organization), a Turing-complete smart contract that ended with the Ethereum Classic hard fork.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Transactions assign bitcoins to a <em>locking</em> script.
The locking script is what&#8217;s specified in the ScriptPubKey field (see <a href="#chapter_tx_parsing">Transactions</a>).
You can think of this as a lockbox where some money is deposited that only a particular key can open.
The money inside, of course, can only be accessed by the owner who has the key.</p>
</div>
<div class="paragraph">
<p>The unlocking of the lockbox is done in the ScriptSig field (see <a href="#chapter_tx_parsing">Transactions</a>); this proves ownership of the locked box, which authorizes spending of the funds.</p>
</div>
</div>
<div class="sect2 pagebreak-before">
<h3 id="_how_script_works">How Script Works</h3>
<div class="paragraph">
<p>Script is a programming language, and like most programming languages, it processes one command at a time.
The commands operate on a stack of elements.
There are two possible types of commands: elements and operations.</p>
</div>
<div class="paragraph">
<p>Elements are data.
Technically, processing an element pushes that element onto the stack. Elements are byte strings of length 1 to 520.
A typical element might be a DER signature or a SEC pubkey (<a href="#elements_chap_six">Elements</a>).</p>
</div>
<div id="elements_chap_six" class="imageblock">
<div class="content">
<img src="./images/prbc_0601.png" alt="Script Elements">
</div>
<div class="title">Figure 48. Elements</div>
</div>
<div class="paragraph">
<p>Operations do something to the data (<a href="#operations_chap_six">Operations</a>).
They consume zero or more elements from the processing stack and push zero or more elements back to the stack.</p>
</div>
<div id="operations_chap_six" class="imageblock">
<div class="content">
<img src="./images/prbc_0602.png" alt="Script Operations">
</div>
<div class="title">Figure 49. Operations</div>
</div>
<div class="paragraph">
<p>A typical operation is <code>OP_DUP</code> (<a href="#op_dup_duplicates_the_top_element">OP_DUP duplicates the top element</a>), which will duplicate the top element (consuming 0) and push the new element to the stack (pushing 1).</p>
</div>
<div id="op_dup_duplicates_the_top_element" class="imageblock">
<div class="content">
<img src="./images/prbc_0603.png" alt="OP_DUP">
</div>
<div class="title">Figure 50. OP_DUP duplicates the top element</div>
</div>
<div class="paragraph">
<p>After all the commands are evaluated, the top element of the stack must be nonzero for the script to resolve as valid.
Having no elements in the stack or the top element being 0 would resolve as invalid.
Resolving as invalid means that the transaction that includes the unlocking script is not accepted on the network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_operations">Example Operations</h3>
<div class="paragraph">
<p>There are many other operations besides <code>OP_DUP</code>.
<code>OP_HASH160</code> (<a href="#op_hash160_does_a_sha256_followed_by_ripemd160_to_the_top_element">OP_HASH160 does a sha256 followed by ripemd160 to the top element</a>) does a sha256 followed by a ripemd160 (aka a hash160) to the top element of the stack (consuming 1) and pushes a new element to the stack (pushing 1).
Note in the diagram that <code>y = hash160(x)</code>.</p>
</div>
<div id="op_hash160_does_a_sha256_followed_by_ripemd160_to_the_top_element" class="imageblock">
<div class="content">
<img src="./images/prbc_0604.png" alt="OP_HASH160">
</div>
<div class="title">Figure 51. OP_HASH160 does a sha256 followed by ripemd160 to the top element</div>
</div>
<div class="paragraph">
<p>Another very important operation is <code>OP_CHECKSIG</code> (<a href="#op_checksig_checks_if_the_signature_for_the_pubkey_is_valid_or_not">OP_CHECKSIG checks if the signature for the pubkey is valid or not</a>).
<code>OP_CHECKSIG</code> consumes two elements from the stack, the first being the pubkey and the second being a signature, and examines whether the signature is good for the given pubkey.
If so, <code>OP_CHECKSIG</code> pushes a 1 to the stack; otherwise, it pushes a 0 to the stack.</p>
</div>
<div id="op_checksig_checks_if_the_signature_for_the_pubkey_is_valid_or_not" class="imageblock">
<div class="content">
<img src="./images/prbc_0605.png" alt="OP_CHECKSIG">
</div>
<div class="title">Figure 52. OP_CHECKSIG checks if the signature for the pubkey is valid or not</div>
</div>
<div class="sect3">
<h4 id="_coding_opcodes">Coding Opcodes</h4>
<div class="paragraph">
<p>We can now code <code>OP_DUP</code>, given a stack.
<code>OP_DUP</code> simply duplicates the top element of the stack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def op_dup(stack):
    if len(stack) &lt; 1:  # <b class="conum">(1)</b>
        return False
    stack.append(stack[-1])  # <b class="conum">(2)</b>
    return True
...
OP_CODE_FUNCTIONS = {
...
    118: op_dup,  # <b class="conum">(3)</b>
...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We have to have at least one element to duplicate; otherwise, we can&#8217;t execute this opcode.</p>
</li>
<li>
<p>This is how we duplicate the top element of the stack.</p>
</li>
<li>
<p><code>118 = 0x76</code>, which is the code for <code>OP_DUP</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that we return a Boolean with this opcode, as a way to tell whether the operation was successful.
A failed operation automatically fails script evaluation.</p>
</div>
<div class="paragraph pagebreak-after">
<p>Here&#8217;s another one, for <code>OP_HASH256</code>.
This opcode will consume the top element, perform a hash256 operation on it, and push the result onto the stack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def op_hash256(stack):
    if len(stack) &lt; 1:
        return False
    element = stack.pop()
    stack.append(hash256(element))
    return True
...
OP_CODE_FUNCTIONS = {
...
    170: op_hash256,
...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_1_6">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>op_hash160</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_the_script_fields">Parsing the Script Fields</h3>
<div class="paragraph">
<p>Both the ScriptPubKey and ScriptSig are parsed the same way.
If the byte is between <code>0x01</code> and <code>0x4b</code> (whose value we call <em>n</em>), we read the next <em>n</em> bytes as an element.
Otherwise, the byte represents an operation, which we have to look up.
Here are some operations and their byte codes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>0x00</code> - <code>OP_0</code></p>
</li>
<li>
<p><code>0x51</code> - <code>OP_1</code></p>
</li>
<li>
<p><code>0x60</code> - <code>OP_16</code></p>
</li>
<li>
<p><code>0x76</code> - <code>OP_DUP</code></p>
</li>
<li>
<p><code>0x93</code> - <code>OP_ADD</code></p>
</li>
<li>
<p><code>0xa9</code> - <code>OP_HASH160</code></p>
</li>
<li>
<p><code>0xac</code> - <code>OP_CHECKSIG</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Elements Longer Than 75 Bytes</div>
<div class="paragraph">
<p>You might be wondering what would happen if you had an element with a length greater than <code>0x4b</code> (75 in decimal).
There are three specific opcodes for handling such elements: <code>OP_PUSHDATA1</code>, <code>OP_PUSHDATA2</code>, and <code>OP_PUSHDATA4</code>.
<code>OP_PUSHDATA1</code> means that the next byte contains how many bytes we need to read for the element.
<code>OP_PUSHDATA2</code> means that the next 2 bytes contain how many bytes we need to read for the element.
<code>OP_PUSHDATA4</code> means that the next 4 bytes contain how many bytes we need to read for the element.</p>
</div>
<div class="paragraph">
<p>Practically speaking, this means if we have an element that&#8217;s between 76 and 255 bytes inclusive, we use <code>OP_PUSHDATA1</code> &lt;__1-byte length of the element__&gt; &lt;__element__&gt;.
For anything between 256 bytes and 520 bytes inclusive, we use <code>OP_PUSHDATA2</code> &lt;__2-byte length of the element in little-endian__&gt; &lt;__element__&gt;.
Anything larger than 520 bytes is not allowed on the network, so <code>OP_PUSHDATA4</code> is unnecessary, though <code>OP_PUSHDATA4</code> &lt;__4-byte length of the element in little-endian, but value less than or equal to 520__&gt; &lt;__element__&gt; is still legal.</p>
</div>
<div class="paragraph">
<p>It is possible to encode a number below 76 using <code>OP_PUSHDATA1</code> or a number below 256 using <code>OP_PUSHDATA2</code> or even any number below 521 using <code>OP_PUSHDATA4</code>.
However, these are considered nonstandard transactions, meaning most Bitcoin nodes (particularly those running Bitcoin Core software) will not relay them.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are many more opcodes, which are coded in <em>op.py</em>, and the full list can be found at <a href="https://en.bitcoin.it/wiki/Script" class="bare">https://en.bitcoin.it/wiki/Script</a>.</p>
</div>
<div class="sect3">
<h4 id="_coding_a_script_parser_and_serializer">Coding a Script Parser and Serializer</h4>
<div class="paragraph">
<p>Now that we know how Script works, we can write a script parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Script:

    def __init__(self, cmds=None):
        if cmds is None:
            self.cmds = []
        else:
            self.cmds = cmds  # <b class="conum">(1)</b>
    ...
    @classmethod
    def parse(cls, s):
        length = read_varint(s)  # <b class="conum">(2)</b>
        cmds = []
        count = 0
        while count &lt; length:  # <b class="conum">(3)</b>
            current = s.read(1)  # <b class="conum">(4)</b>
            count += 1
            current_byte = current[0]  # <b class="conum">(5)</b>
            if current_byte &gt;= 1 and current_byte &lt;= 75:  # <b class="conum">(6)</b>
                n = current_byte
                cmds.append(s.read(n))
                count += n
            elif current_byte == 76:  # <b class="conum">(7)</b>
                data_length = little_endian_to_int(s.read(1))
                cmds.append(s.read(data_length))
                count += data_length + 1
            elif current_byte == 77:  # <b class="conum">(8)</b>
                data_length = little_endian_to_int(s.read(2))
                cmds.append(s.read(data_length))
                count += data_length + 2
            else:  # <b class="conum">(9)</b>
                op_code = current_byte
                cmds.append(op_code)
        if count != length:  # <b class="conum">(10)</b>
            raise SyntaxError('parsing script failed')
        return cls(cmds)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Each command is either an opcode to be executed or an element to be pushed onto the stack.</p>
</li>
<li>
<p>Script serialization always starts with the length of the entire script.</p>
</li>
<li>
<p>We parse until the right amount of bytes are consumed.</p>
</li>
<li>
<p>The byte determines if we have an opcode or element.</p>
</li>
<li>
<p>This converts the byte into an integer in Python.</p>
</li>
<li>
<p>For a number between 1 and 75 inclusive, we know the next n bytes are an <span class="keep-together">element</span>.</p>
</li>
<li>
<p>76 is <code>OP_PUSHDATA1</code>, so the next byte tells us how many bytes to read.</p>
</li>
<li>
<p>77 is <code>OP_PUSHDATA2</code>, so the next two bytes tell us how many bytes to read.</p>
</li>
<li>
<p>We have an opcode that we store.</p>
</li>
<li>
<p>The script should have consumed exactly the length of bytes we expected; otherwise, we raise an error.</p>
</li>
</ol>
</div>
<div class="paragraph pagebreak-before">
<p>We can similarly write a script serializer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Script:
...
    def raw_serialize(self):
        result = b''
        for cmd in self.cmds:
            if type(cmd) == int:  # <b class="conum">(1)</b>
                result += int_to_little_endian(cmd, 1)
            else:
                length = len(cmd)
                if length &lt; 75:  # <b class="conum">(2)</b>
                    result += int_to_little_endian(length, 1)
                elif length &gt; 75 and length &lt; 0x100:  # <b class="conum">(3)</b>
                    result += int_to_little_endian(76, 1)
                    result += int_to_little_endian(length, 1)
                elif length &gt;= 0x100 and length &lt;= 520:  # <b class="conum">(4)</b>
                    result += int_to_little_endian(77, 1)
                    result += int_to_little_endian(length, 2)
                else:  # <b class="conum">(5)</b>
                    raise ValueError('too long an cmd')
                result += cmd
        return result

    def serialize(self):
        result = self.raw_serialize()
        total = len(result)
        return encode_varint(total) + result  # <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If the command is an integer, we know that&#8217;s an opcode.</p>
</li>
<li>
<p>If the length is between 1 and 75 inclusive, we encode the length as a single byte.</p>
</li>
<li>
<p>For any element with length from 76 to 255, we put <code>OP_PUSHDATA1</code> first, then encode the length as a single byte, followed by the element.</p>
</li>
<li>
<p>For an element with a length from 256 to 520, we put <code>OP_PUSHDATA2</code> first, then encode the length as two bytes in little endian, followed by the element.</p>
</li>
<li>
<p>Any element longer than 520 bytes cannot be serialized.</p>
</li>
<li>
<p>Script serialization starts with the length of the entire script.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that both the parser and the serializer were used in <a href="#chapter_tx_parsing">Transactions</a>, for parsing/serializing the ScriptSig and ScriptPubKey fields.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_combining_the_script_fields">Combining the Script Fields</h3>
<div class="paragraph">
<p>The Script object represents the command set that requires evaluation.
To evaluate a script, we need to combine the ScriptPubKey and ScriptSig fields.
The lockbox (ScriptPubKey) and the unlocking mechanism (ScriptSig) are in <em>different</em> transactions.
Specifically, the lockbox is where the bitcoins are received, and the unlocking script is where the bitcoins are spent.
The input in the spending transaction <em>points to the receiving transaction</em>.
Essentially, we have a situation like <a href="#scriptpubkey_and_scriptsig">Combining the ScriptPubKey and ScriptSig</a>.</p>
</div>
<div id="scriptpubkey_and_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0606.png" alt="ScriptPubKey and ScriptSig">
</div>
<div class="title">Figure 53. Combining the ScriptPubKey and ScriptSig</div>
</div>
<div class="paragraph">
<p>Since the ScriptSig unlocks a ScriptPubKey, we need a mechanism by which the two scripts combine.
To evaluate the two together, we take the commands from the ScriptSig and ScriptPubKey and combine them as in <a href="#scriptpubkey_and_scriptsig">Combining the ScriptPubKey and ScriptSig</a>.
The commands from the ScriptSig go on top of all the commands from the ScriptPubKey.
Instructions are processed one at a time until no commands are left to be processed (or the script fails).</p>
</div>
<div class="sect3">
<h4 id="_coding_the_combined_instruction_set">Coding the Combined Instruction Set</h4>
<div class="paragraph">
<p>The evaluation of a script requires that we take the ScriptSig and ScriptPubKey, combine them into a single command set, and execute the commands.
To do this, we require a way to combine the scripts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Script:
...
    def __add__(self, other):
        return Script(self.cmds + other.cmds)  # <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are combining the command set to create a new, combined Script object.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We will use this ability to combine scripts for evaluation later in this chapter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_standard_scripts">Standard Scripts</h3>
<div class="paragraph">
<p>There are many types of standard scripts in Bitcoin, including the following:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">p2pk</dt>
<dd>
<p>Pay-to-pubkey</p>
</dd>
<dt class="hdlist1">p2pkh</dt>
<dd>
<p>Pay-to-pubkey-hash</p>
</dd>
<dt class="hdlist1">p2sh</dt>
<dd>
<p>Pay-to-script-hash</p>
</dd>
<dt class="hdlist1">p2wpkh</dt>
<dd>
<p>Pay-to-witness-pubkey-hash</p>
</dd>
<dt class="hdlist1">p2wsh</dt>
<dd>
<p>Pay-to-witness-script-hash</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Addresses are known script templates like these.
Wallets know how to interpret various address types (p2pkh, p2sh, p2wpkh) and create the appropriate ScriptPubKeys.
All of the examples here have a particular type of address format (Base58, Bech32) so wallets can pay to them.</p>
</div>
<div class="paragraph">
<p>To show exactly how all this works, we&#8217;ll start with one of the original scripts, pay-to-pubkey.</p>
</div>
</div>
<div class="sect2">
<h3 id="_p2pk">p2pk</h3>
<div class="paragraph">
<p>Pay-to-pubkey (p2pk) was used largely during the early days of Bitcoin.
Most coins thought to belong to Satoshi are in p2pk UTXOs—that is, transaction outputs whose ScriptPubKeys have the p2pk form.
There are some limitations that we&#8217;ll discuss in <a href="#problemsp2pk">Problems with p2pk</a>, but first, let&#8217;s look at how p2pk works.</p>
</div>
<div class="paragraph">
<p>Back in <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>, we learned about both ECDSA signing and verification.
To verify an ECDSA signature, we need the message, <em>z</em>, the public key, <em>P</em>, and the signature, <em>r</em> and <em>s</em>.
In p2pk, bitcoins are sent to a public key, and the owner of the private key can unlock or spend the bitcoins by creating a signature.
The ScriptPubKey of a transaction puts the assigned bitcoins under the control of the private key owner.</p>
</div>
<div class="paragraph">
<p>Specifying where the bitcoins go is the job of the ScriptPubKey—this is the lockbox that receives the bitcoins.
The p2pk ScriptPubKey looks like <a href="#pay_to_pubkey_p2pk_scriptpubkey">Pay-to-pubkey (p2pk) ScriptPubKey</a>.</p>
</div>
<div id="pay_to_pubkey_p2pk_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_0607.png" alt="P2PK ScriptPubKey">
</div>
<div class="title">Figure 54. Pay-to-pubkey (p2pk) ScriptPubKey</div>
</div>
<div class="paragraph">
<p>Note the <code>OP_CHECKSIG</code>, as that will be very important.
The ScriptSig is the part that unlocks the received bitcoins.
The pubkey can be compressed or uncompressed, though early on in Bitcoin&#8217;s history when p2pk was more prominent, the uncompressed format was the only one being used (see <a href="#chapter_serialization">Serialization</a>).</p>
</div>
<div class="paragraph">
<p>For p2pk, the ScriptSig required to unlock the corresponding ScriptPubKey is the signature followed by a single sighash byte, as shown in <a href="#pay_to_pubkey_p2pk_scriptsig">Pay-to-pubkey (p2pk) ScriptSig</a>.</p>
</div>
<div id="pay_to_pubkey_p2pk_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0608.png" alt="P2PK ScriptSig">
</div>
<div class="title">Figure 55. Pay-to-pubkey (p2pk) ScriptSig</div>
</div>
<div class="paragraph">
<p>The ScriptPubKey and ScriptSig combine to make a command set that looks like <a href="#p2pk_combined">p2pk combined</a>.</p>
</div>
<div id="p2pk_combined" class="imageblock">
<div class="content">
<img src="./images/prbc_0609.png" alt="P2PK Combination">
</div>
<div class="title">Figure 56. p2pk combined</div>
</div>
<div class="paragraph">
<p>The two columns in <a href="#p2pk_start">p2pk start</a> are Script commands and the elements stack.
At the end of the processing, the top element of the stack must be nonzero to be considered a valid ScriptSig.
The Script commands are processed one at a time.
In <a href="#p2pk_start">p2pk start</a>, we start with the commands as combined in <a href="#p2pk_combined">p2pk combined</a>.</p>
</div>
<div id="p2pk_start" class="imageblock">
<div class="content">
<img src="./images/prbc_0610.png" alt="P2PK Start">
</div>
<div class="title">Figure 57. p2pk start</div>
</div>
<div class="paragraph">
<p>The first command is the signature, which is an element.
This is data that is pushed to the stack (<a href="#pspk_step_1">p2pk step 1</a>).</p>
</div>
<div id="pspk_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_0611.png" alt="P2PK Step 1">
</div>
<div class="title">Figure 58. p2pk step 1</div>
</div>
<div class="paragraph">
<p>The second command is the pubkey, which is also an element.
Again, this is data that is pushed to the stack (<a href="#pspk_step_2">p2pk step 2</a>).</p>
</div>
<div id="pspk_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_0612.png" alt="P2PK Step 2">
</div>
<div class="title">Figure 59. p2pk step 2</div>
</div>
<div class="paragraph">
<p><code>OP_CHECKSIG</code> consumes two stack commands (pubkey and signature) and determines if they are valid for this transaction.
<code>OP_CHECKSIG</code> will push a 1 to the stack if the signature is valid, and a 0 if not.
Assuming that the signature is valid for this public key, we have the situation shown in <a href="#pspk_step_3">p2pk step 3</a>.</p>
</div>
<div id="pspk_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_0613.png" alt="P2PK End 1">
</div>
<div class="title">Figure 60. p2pk step 3</div>
</div>
<div class="paragraph">
<p>We&#8217;re finished processing all the Script commands, and we&#8217;ve ended up with a single element on the stack.
Since the top element is nonzero (1 is definitely not 0), this script is valid.</p>
</div>
<div class="paragraph">
<p>If this transaction instead had an invalid signature, the result from <code>OP_CHECKSIG</code> would be 0, ending our script processing (as shown in <a href="#p2pk_end">p2pk end</a>).</p>
</div>
<div id="p2pk_end" class="imageblock">
<div class="content">
<img src="./images/prbc_0614.png" alt="P2PK End 2">
</div>
<div class="title">Figure 61. p2pk end</div>
</div>
<div class="paragraph">
<p>If the top element is 0, the combined script is invalid and a transaction with this ScriptSig in the input is invalid.</p>
</div>
<div class="paragraph">
<p>The combined script will validate if the signature is valid, but fail if the signature is invalid.
The ScriptSig will only unlock the ScriptPubKey if the signature is valid for that public key.
In other words, only someone with knowledge of the private key can produce a valid ScriptSig.</p>
</div>
<div class="paragraph">
<p>Incidentally, we can see where ScriptPubKey got its name.
The public key in uncompressed SEC format is the main command in the ScriptPubKey for p2pk (the other command being <code>OP_CHECKSIG</code>).
Similarly, ScriptSig is named as such because the ScriptSig for p2pk has the DER signature.</p>
</div>
<div class="sect3">
<h4 id="_coding_script_evaluation">Coding Script Evaluation</h4>
<div class="paragraph">
<p>We&#8217;ll now code a way to evaluate scripts.
This requires us to go through each command and evaluate whether the script is valid.
What we want to be able to do is this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from script import Script
&gt;&gt;&gt; z = 0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d
&gt;&gt;&gt; sec = bytes.fromhex('04887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e\
4da568744d06c61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34')
&gt;&gt;&gt; sig = bytes.fromhex('3045022000eff69ef2b1bd93a66ed5219add4fb51e11a840f4048\
76325a1e8ffe0529a2c022100c7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fd\
dbdce6feab601')
&gt;&gt;&gt; script_pubkey = Script([sec, 0xac])  # <b class="conum">(1)</b>
&gt;&gt;&gt; script_sig = Script([sig])
&gt;&gt;&gt; combined_script = script_sig + script_pubkey  # <b class="conum">(2)</b>
&gt;&gt;&gt; print(combined_script.evaluate(z))  # <b class="conum">(3)</b>
True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The p2pk ScriptPubkey is the SEC format pubkey followed by <code>OP_CHECKSIG</code>, which is <code>0xac</code> or 172.</p>
</li>
<li>
<p>We can do this because of the <code><em>add</em></code> method we just created.</p>
</li>
<li>
<p>We want to evaluate the commands and see if the script validates.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here is the method that we&#8217;ll use for the <em>combined</em> command set (combination of the ScriptPubKey of the previous transaction and the ScriptSig of the current <span class="keep-together">transaction</span>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from op import OP_CODE_FUNCTIONS, OP_CODE_NAMES
...
class Script:
...
    def evaluate(self, z):
        cmds = self.cmds[:]  # <b class="conum">(1)</b>
        stack = []
        altstack = []
        while len(cmds) &gt; 0:  # <b class="conum">(2)</b>
            cmd = cmds.pop(0)
            if type(cmd) == int:
                operation = OP_CODE_FUNCTIONS[cmd]  # <b class="conum">(3)</b>
                if cmd in (99, 100):  # <b class="conum">(4)</b>
                    if not operation(stack, cmds):
                        LOGGER.info('bad op: {}'.format(OP_CODE_NAMES[cmd]))
                        return False
                elif cmd in (107, 108):  # <b class="conum">(5)</b>
                    if not operation(stack, altstack):
                        LOGGER.info('bad op: {}'.format(OP_CODE_NAMES[cmd]))
                        return False
                elif cmd in (172, 173, 174, 175):  # <b class="conum">(6)</b>
                    if not operation(stack, z):
                        LOGGER.info('bad op: {}'.format(OP_CODE_NAMES[cmd]))
                        return False
                else:
                    if not operation(stack):
                        LOGGER.info('bad op: {}'.format(OP_CODE_NAMES[cmd]))
                        return False
            else:
                stack.append(cmd)  # <b class="conum">(7)</b>
        if len(stack) == 0:
            return False  # <b class="conum">(8)</b>
        if stack.pop() == b'':
            return False  # <b class="conum">(9)</b>
        return True  # <b class="conum">(10)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>As the commands list will change, we make a copy.</p>
</li>
<li>
<p>We execute until the commands list is empty.</p>
</li>
<li>
<p>The function that executes the opcode is in the <code>OP_CODE_FUNCTIONS</code> array (e.g.,
<code>OP_DUP</code>, <code>OP_CHECKSIG</code>, etc.).</p>
</li>
<li>
<p>99 and 100 are <code>OP_IF</code> and <code>OP_NOTIF</code>, respectively.
They require manipulation of the <code>cmds</code> array based on the top element of the stack.</p>
</li>
<li>
<p>107 and 108 are <code>OP_TOALTSTACK</code> and <code>OP_FROMALTSTACK</code>, respectively.
They move stack elements to/from an "alternate" stack, which we call <code>altstack</code>.</p>
</li>
<li>
<p>172, 173, 174, and 175 are <code>OP_CHECKSIG</code>, <code>OP_CHECKSIGVERIFY</code>, <code>OP_CHECKMULTISIG</code>, and <code>OP_CHECKMULTISIGVERIFY</code>, which all require the signature hash, <code>z</code>, from <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a> for signature validation.</p>
</li>
<li>
<p>If the command is not an opcode, it&#8217;s an element, so we push that element to the stack.</p>
</li>
<li>
<p>If the stack is empty at the end of processing all the commands, we fail the script by returning <code>False</code>.</p>
</li>
<li>
<p>If the stack&#8217;s top element is an empty byte string (which is how the stack stores a 0), then we also fail the script by returning <code>False</code>.</p>
</li>
<li>
<p>Any other result means that the script has validated.</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Making Script Evaluation Safe</div>
<div class="paragraph">
<p>The code shown here is a little bit of a cheat, as the combined script is not exactly executed this way.
The ScriptSig is evaluated separately from the ScriptPubKey so as to not allow operations from the ScriptSig to affect the ScriptPubKey commands.</p>
</div>
<div class="paragraph">
<p>Specifically, the stack after all the ScriptSig commands are evaluated is stored, and then the ScriptPubkey commands are evaluated on their own with the stack from the first execution.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_stack_elements_under_the_hood">Stack Elements Under the Hood</h4>
<div class="paragraph">
<p>It may be confusing that the stack elements are sometimes numbers like 0 or 1 and other times byte strings like a DER signature or SEC pubkey.
Under the hood, they&#8217;re all bytes, but some are interpreted as numbers for certain opcodes.
For example, 1 is stored on the stack as the <code>01</code> byte, 2 is stored as the <code>02</code> byte, 999 as the <code>e703</code> byte, and so on.
Any byte string is interpreted as a little-endian number for arithmetic opcodes.
The integer 0 is <em>not</em> stored as the <code>00</code> byte, but as the empty byte string.</p>
</div>
<div class="paragraph">
<p>The code in <em>op.py</em> can clarify what&#8217;s going on:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def encode_num(num):
    if num == 0:
        return b''
    abs_num = abs(num)
    negative = num &lt; 0
    result = bytearray()
    while abs_num:
        result.append(abs_num &amp; 0xff)
        abs_num &gt;&gt;= 8
    if result[-1] &amp; 0x80:
        if negative:
            result.append(0x80)
        else:
            result.append(0)
    elif negative:
        result[-1] |= 0x80
    return bytes(result)


def decode_num(element):
    if element == b'':
        return 0
    big_endian = element[::-1]
    if big_endian[0] &amp; 0x80:
        negative = True
        result = big_endian[0] &amp; 0x7f
    else:
        negative = False
        result = big_endian[0]
    for c in big_endian[1:]:
        result &lt;&lt;= 8
        result += c
    if negative:
        return -result
    else:
        return result


def op_0(stack):
    stack.append(encode_num(0))
    return True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numbers being pushed to the stack are encoded into bytes and decoded from bytes when the numerical value is needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_6">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>op_checksig</code> function in <em>op.py</em>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="problemsp2pk">Problems with p2pk</h3>
<div class="paragraph">
<p>Pay-to-pubkey is intuitive in the sense that there is a public key that anyone can send bitcoins to and a signature that can only be produced by the owner of the private key.
This works well, but there are some problems.</p>
</div>
<div class="paragraph">
<p>First, the public keys are long.
We know from <a href="#chapter_serialization">Serialization</a> that secp256k1 public points are 33 bytes in compressed SEC and 65 bytes in uncompressed SEC format.
Unfortunately, humans can&#8217;t interpret 33 or 65 raw bytes easily.
Most character encodings don&#8217;t render certain byte ranges, as they are control characters, newlines, or similar.
The SEC format is typically encoded instead in hexadecimal, doubling the length (hex encodes 4 bits per character instead of 8).
This makes the compressed and uncompressed SEC formats 66 and 130 characters, respectively, which is bigger than most identifiers (your username on a website, for instance, is usually less than 20 characters).
To compound this, early Bitcoin transactions didn&#8217;t use the compressed versions, so the hexadecimal addresses were 130 characters each!
This is not fun or easy for people to transcribe, much less communicate by voice.</p>
</div>
<div class="paragraph">
<p>That said, the original use cases for p2pk were for IP-to-IP payments and mining outputs.
For IP-to-IP payments, IP addresses were queried for their public keys; communicating the public keys was done machine-to-machine, which meant that human communication wasn&#8217;t necessarily a problem.
Use for mining outputs also doesn&#8217;t require human communication.
Incidentally, this IP-to-IP payment system was phased out because it&#8217;s not secure and prone to man-in-the-middle attacks.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Why Did Satoshi Use the Uncompressed SEC Format?</div>
<div class="paragraph">
<p>It seems the uncompressed SEC format doesn&#8217;t make sense for Bitcoin given that block space is at a premium. So why did Satoshi use it?
Satoshi was using the OpenSSL library to do the SEC format conversions, and the OpenSSL library at the time Satoshi wrote Bitcoin (circa 2008) did not document the compressed format very well.
It&#8217;s speculated this is why Satoshi used the uncompressed SEC format.</p>
</div>
<div class="paragraph">
<p>When Pieter Wuille discovered that the compressed SEC format existed in OpenSSL, more people started using the compressed SEC format in Bitcoin.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Second, the length of the public keys causes a subtler problem: because they have to be kept around and indexed to see if the outputs are spendable, the UTXO set becomes bigger.
This requires more resources on the part of full nodes.</p>
</div>
<div class="paragraph">
<p>Third, because we&#8217;re storing the public keys in the ScriptPubKey field, they&#8217;re known to everyone.
That means should ECDSA someday be broken, these outputs could be stolen. For example, quantum computing has the potential to reduce the calculation times significantly for RSA and ECDSA, so having something else in addition to protect these outputs would be more secure. However, this is not a very big threat since ECDSA is used in a lot of applications besides Bitcoin and breaking it would affect all of those things, too.</p>
</div>
</div>
<div class="sect2">
<h3 id="_solving_the_problems_with_p2pkh">Solving the Problems with p2pkh</h3>
<div class="paragraph">
<p>Pay-to-pubkey-hash (p2pkh) is an alternative script format that has two key advantages over p2pk:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The addresses are shorter.</p>
</li>
<li>
<p>It&#8217;s additionally protected by sha256 and ripemd160.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The addresses are shorter because it uses the sha256 and ripemd160 hashing algorithms.
We do both in succession and call that hash160.
The result of hash160 is 160 bits or 20 bytes, which are encoded into an address.</p>
</div>
<div class="paragraph">
<p>The result is what you may have seen on the Bitcoin network and coded in <a href="#chapter_serialization">Serialization</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1PMycacnJaSqwwJqjawXBErnLsZ7RkXUAs</pre>
</div>
</div>
<div class="paragraph">
<p>This address encodes within 20 bytes that look like this in hexadecimal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>f54a5851e9372b87810a8e60cdd2e7cfd80b6e31</pre>
</div>
</div>
<div class="paragraph">
<p>These 20 bytes are the result of doing a hash160 operation on this (compressed) SEC public key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352</pre>
</div>
</div>
<div class="paragraph">
<p>Given that p2pkh is shorter and more secure, p2pk use declined significantly after 2010, though it&#8217;s still fully supported today.</p>
</div>
<div class="sect3">
<h4 id="_p2pkh">p2pkh</h4>
<div class="paragraph">
<p>Pay-to-pubkey-hash was used during the early days of Bitcoin, though not as much as p2pk.</p>
</div>
<div class="paragraph">
<p>The p2pkh ScriptPubKey, or locking script, looks like <a href="#pay_to_pubkey_hash_p2pkh_scriptpubkey">Pay-to-pubkey-hash (p2pkh) ScriptPubKey</a>.</p>
</div>
<div id="pay_to_pubkey_hash_p2pkh_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_0615.png" alt="P2PKH ScriptPubKey">
</div>
<div class="title">Figure 62. Pay-to-pubkey-hash (p2pkh) ScriptPubKey</div>
</div>
<div class="paragraph">
<p>Like p2pk, <code>OP_CHECKSIG</code> is here and <code>OP_HASH160</code> makes an appearance.
Unlike p2pk, the SEC pubkey is not here, but a 20-byte hash is.
There is also a new opcode here: <code>OP_EQUALVERIFY</code>.</p>
</div>
<div class="paragraph">
<p>The p2pkh ScriptSig, or unlocking script, looks like <a href="#pay_to_pubkey_hash_p2pkh_scriptsig">Pay-to-pubkey-hash (p2pkh) ScriptSig</a>.</p>
</div>
<div id="pay_to_pubkey_hash_p2pkh_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0616.png" alt="P2PKH ScriptSig">
</div>
<div class="title">Figure 63. Pay-to-pubkey-hash (p2pkh) ScriptSig</div>
</div>
<div class="paragraph">
<p>Like p2pk, the ScriptSig has the DER signature.
Unlike p2pk, the ScriptSig also has the SEC pubkey.
The main difference between p2pk and p2pkh ScriptSigs is that the SEC pubkey has moved from the ScriptPubKey to the ScriptSig.</p>
</div>
<div class="paragraph">
<p>The ScriptPubKey and ScriptSig combine to form a list of commands that looks like <a href="#p2pkh_combined">p2pkh combined</a>.</p>
</div>
<div id="p2pkh_combined" class="imageblock">
<div class="content">
<img src="./images/prbc_0617.png" alt="P2PKH Combination">
</div>
<div class="title">Figure 64. p2pkh combined</div>
</div>
<div class="paragraph">
<p>At this point, the script is processed one command at a time.
We start with the commands as combined in <a href="#p2pkh_start">p2pkh start</a>.</p>
</div>
<div id="p2pkh_start" class="imageblock">
<div class="content">
<img src="./images/prbc_0618.png" alt="P2PKH Start">
</div>
<div class="title">Figure 65. p2pkh start</div>
</div>
<div class="paragraph">
<p>The first two commands are elements, so they are pushed to the stack (<a href="#p2pkh_step_1">p2pkh step 1</a>).</p>
</div>
<div id="p2pkh_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_0619.png" alt="P2PKH Step 1">
</div>
<div class="title">Figure 66. p2pkh step 1</div>
</div>
<div class="paragraph">
<p><code>OP_DUP</code> duplicates the top element, so the pubkey gets duplicated (<a href="#p2pkh_step_2">p2pkh step 2</a>).</p>
</div>
<div id="p2pkh_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_0620.png" alt="P2PKH Step 2">
</div>
<div class="title">Figure 67. p2pkh step 2</div>
</div>
<div class="paragraph">
<p><code>OP_HASH160</code> takes the top element and performs the hash160 operation on it (sha256 followed by ripemd160), creating a 20-byte hash (<a href="#p2pkh_step_3">p2pkh step 3</a>).</p>
</div>
<div id="p2pkh_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_0621.png" alt="P2PKH Step 3">
</div>
<div class="title">Figure 68. p2pkh step 3</div>
</div>
<div class="paragraph">
<p>The 20-byte hash is an element and is pushed to the stack (<a href="#p2pkh_step_4">p2pkh step 4</a>).</p>
</div>
<div id="p2pkh_step_4" class="imageblock">
<div class="content">
<img src="./images/prbc_0622.png" alt="P2PKH Step 4">
</div>
<div class="title">Figure 69. p2pkh step 4</div>
</div>
<div class="paragraph">
<p>We are now at <code>OP_EQUALVERIFY</code>.
This opcode consumes the top two elements and checks if they&#8217;re equal.
If they are equal, the script continues execution.
If they are not equal, the script stops immediately and fails.
We assume here that they&#8217;re equal, leading to <a href="#p2pkh_step_5">p2pkh step 5</a>.</p>
</div>
<div id="p2pkh_step_5" class="imageblock">
<div class="content">
<img src="./images/prbc_0623.png" alt="P2PKH Step 5">
</div>
<div class="title">Figure 70. p2pkh step 5</div>
</div>
<div class="paragraph">
<p>We are now exactly where we were during the <code>OP_CHECKSIG</code> part of processing p2pk.
Once again, we assume that the signature is valid (<a href="#p2pkh_end">p2pkh end</a>).</p>
</div>
<div id="p2pkh_end" class="imageblock">
<div class="content">
<img src="./images/prbc_0624.png" alt="P2PKH End">
</div>
<div class="title">Figure 71. p2pkh end</div>
</div>
<div class="paragraph">
<p>There are two ways this script can fail.
If the ScriptSig provides a public key that does not hash160 to the 20-byte hash in the ScriptPubKey, the script will fail at <code>OP_EQUALVERIFY</code> (<a href="#p2pkh_step_4">p2pkh step 4</a>).
The other failure condition is if the ScriptSig has a public key that hash160s to the 20-byte hash in the ScriptPubKey, but has an invalid signature.
That would end the combined script evaluation with a 0, ending in failure.</p>
</div>
<div class="paragraph">
<p>This is why we call this type of script pay-to-pubkey-<em>hash</em>.
The ScriptPubKey has the 20-byte <em>hash160</em> of the public key and not the public key itself.
We are locking bitcoins to a <em>hash</em> of the public key, and the spender is responsible for revealing the public key as part of constructing the ScriptSig.</p>
</div>
<div class="paragraph">
<p>The major advantages are that the ScriptPubKey is shorter (just 25 bytes) and a thief would not only have to solve the discrete log problem in ECDSA, but also figure out a way to find preimages of both ripemd160 and sha256.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scripts_can_be_arbitrarily_constructed">Scripts Can Be Arbitrarily Constructed</h3>
<div class="paragraph">
<p>Note that a script can be any arbitrary program.
Script is a smart contract language and can lock bitcoins in many different ways.
<a href="#example_scriptpubkey">Example ScriptPubKey</a> is an example ScriptPubKey.</p>
</div>
<div id="example_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_0625.png" alt="Example 1 ScriptPubKey">
</div>
<div class="title">Figure 72. Example ScriptPubKey</div>
</div>
<div class="paragraph">
<p><a href="#example_scriptsig">Example ScriptSig</a> is a ScriptSig that will unlock the the ScriptPubKey from <a href="#example_scriptpubkey">Example ScriptPubKey</a>.</p>
</div>
<div id="example_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0626.png" alt="Example 1 ScriptSig">
</div>
<div class="title">Figure 73. Example ScriptSig</div>
</div>
<div class="paragraph">
<p>The combined script is shown in <a href="#example_combined">Example combined</a>.</p>
</div>
<div id="example_combined" class="imageblock">
<div class="content">
<img src="./images/prbc_0627.png" alt="Example 1 Combination">
</div>
<div class="title">Figure 74. Example combined</div>
</div>
<div class="paragraph">
<p>Script evaluation will start as shown in <a href="#example_start">Example start</a>.</p>
</div>
<div id="example_start" class="imageblock">
<div class="content">
<img src="./images/prbc_0628.png" alt="Example 1 Start">
</div>
<div class="title">Figure 75. Example start</div>
</div>
<div class="paragraph">
<p><code>OP_4</code> will push a 4 to the stack (<a href="#example_step_1">Example step 1</a>).</p>
</div>
<div id="example_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_0629.png" alt="Example 1 Step 1">
</div>
<div class="title">Figure 76. Example step 1</div>
</div>
<div class="paragraph">
<p><code>OP_5</code> will likewise push a 5 to the stack (<a href="#example_step_2">Example step 2</a>).</p>
</div>
<div id="example_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_0630.png" alt="Example 1 Step 2">
</div>
<div class="title">Figure 77. Example step 2</div>
</div>
<div class="paragraph">
<p><code>OP_ADD</code> will consume the top two elements of the stack, add them together, and push the sum to the stack (<a href="#example_step_3">Example step 3</a>).</p>
</div>
<div id="example_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_0631.png" alt="Example 1 Step 3">
</div>
<div class="title">Figure 78. Example step 3</div>
</div>
<div class="paragraph">
<p><code>OP_9</code> will push a 9 to the stack (<a href="#example_step_4">Example step 4</a>).</p>
</div>
<div id="example_step_4" class="imageblock">
<div class="content">
<img src="./images/prbc_0632.png" alt="Example 1 Step 4">
</div>
<div class="title">Figure 79. Example step 4</div>
</div>
<div class="paragraph">
<p><code>OP_EQUAL</code> will consume two elements and push a 1 if they&#8217;re equal and a 0 if not (<a href="#example_end">Example end</a>).</p>
</div>
<div id="example_end" class="imageblock">
<div class="content">
<img src="./images/prbc_0633.png" alt="Example 1 End">
</div>
<div class="title">Figure 80. Example end</div>
</div>
<div class="paragraph">
<p>Note that the ScriptSig here isn&#8217;t particularly hard to figure out and contains no signature.
As a result, the ScriptPubKey is vulnerable to being taken by anyone who can solve it.
Think of this ScriptPubKey as a lockbox with a very flimsy lock that anyone can break into.
It is for this reason that most transactions have a signature requirement in the ScriptSig.</p>
</div>
<div class="paragraph">
<p>Once a UTXO has been spent, included in a block, and secured by proof-of-work, the coins are locked to a different ScriptPubKey and no longer as easily spendable.
Someone attempting to spend already spent coins would have to provide proof-of-work, which is expensive (see <a href="#chapter_blocks">Blocks</a>).</p>
</div>
<div class="sect3">
<h4 id="_exercise_3_6">Exercise 3</h4>
<div class="paragraph">
<p>Create a ScriptSig that can unlock this ScriptPubKey:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>767695935687</pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>OP_MUL</code> multiplies the top two elements of the stack.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>56 = OP_6</code></p>
</li>
<li>
<p><code>76 = OP_DUP</code></p>
</li>
<li>
<p><code>87 = OP_EQUAL</code></p>
</li>
<li>
<p><code>93 = OP_ADD</code></p>
</li>
<li>
<p><code>95 = OP_MUL</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_utility_of_scripts">Utility of Scripts</h4>
<div class="paragraph">
<p>The previous exercise was a bit of a cheat, as <code>OP_MUL</code> is no longer allowed on the Bitcoin network.
Version 0.3.5 of Bitcoin disabled a lot of different opcodes (anything that had even a little bit of potential to create vulnerabilities on the network).</p>
</div>
<div class="paragraph">
<p>This is just as well, since most of the functionality in Script is actually not used much.
From a software maintenance standpoint, this is not a great situation as the code has to be maintained despite its lack of usage.
Simplifying and getting rid of certain capabilities can be seen as a way to make Bitcoin more secure.</p>
</div>
<div class="paragraph">
<p>This is in stark contrast to other projects, which try to expand their smart contract languages, often increasing the attack surface along with new features.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_6">Exercise 4</h4>
<div class="paragraph">
<p>Figure out what this script is doing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>6e879169a77ca787</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>69 = OP_VERIFY</code></p>
</li>
<li>
<p><code>6e = OP_2DUP</code></p>
</li>
<li>
<p><code>7c = OP_SWAP</code></p>
</li>
<li>
<p><code>87 = OP_EQUAL</code></p>
</li>
<li>
<p><code>91 = OP_NOT</code></p>
</li>
<li>
<p><code>a7 = OP_SHA1</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use the <code>Script.parse</code> method and look up what various opcodes do at <a href="https://en.bitcoin.it/wiki/Script" class="bare">https://en.bitcoin.it/wiki/Script</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sha_1_piñata">SHA-1 Piñata</h4>
<div class="paragraph">
<p>In 2013, Peter Todd created a script very similar to the one in Exercise 4 and put some bitcoins into it to create an economic incentive for people to find hash collisions.
The donations reached 2.49153717 BTC, and when Google actually found a <a href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html">hash collision for SHA-1 in February 2017</a>, this script was promptly redeemed.
The transaction output was 2.48 BTC, which was 2,848.88 USD at the time.</p>
</div>
<div class="paragraph">
<p>Peter created more piñatas for sha256, hash256, and hash160, which add economic incentives to find collisions for these hashing functions.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_6">Conclusion</h3>
<div class="paragraph">
<p>We&#8217;ve covered Script and how it works.
We can now proceed to the creation and validation of transactions.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_tx">Transaction Creation and Validation</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>One of the trickiest things to code in Bitcoin is validating transactions.
Another one is creating transactions.
In this chapter, we&#8217;ll cover the exact steps to do both.
Toward the end of the chapter, we&#8217;ll be creating a testnet transaction and broadcasting it.</p>
</div>
<div class="sect2">
<h3 id="_validating_transactions">Validating Transactions</h3>
<div class="paragraph">
<p>Every node, when receiving transactions, makes sure that each transaction adheres to the network rules.
This process is called <em>transaction validation</em>.
Here are the main things that a node checks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The inputs of the transaction are previously unspent.</p>
</li>
<li>
<p>The sum of the inputs is greater than or equal to the sum of the outputs.</p>
</li>
<li>
<p>The ScriptSig successfully unlocks the previous ScriptPubKey.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>#1 prevents double-spending.
Any input that&#8217;s been spent (that is, included in the blockchain) cannot be spent again.</p>
</div>
<div class="paragraph">
<p>#2 makes sure no new bitcoins are created (except in a special type of transaction called a coinbase transaction; more on that in <a href="#chapter_blocks">Blocks</a>).</p>
</div>
<div class="paragraph">
<p>#3 makes sure that the combined script is valid.
In the vast majority of transactions, this means checking that the one or more signatures in the ScriptSig are valid.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at how each condition is checked.</p>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_checking_the_spentness_of_inputs">Checking the Spentness of Inputs</h4>
<div class="paragraph">
<p>To prevent double-spending, a node checks that each input exists and has not been spent.
This can be checked by any full node by looking at the UTXO set (see <a href="#chapter_tx_parsing">Transactions</a>).
We cannot determine from the transaction itself whether it&#8217;s double-spending, much like we cannot look at a personal check and determine whether it&#8217;s overdrafting.
The only way to know is to have access to the UTXO set, which requires calculation from the entire set of transactions.</p>
</div>
<div class="paragraph">
<p>In Bitcoin, we can determine whether an input is being double-spent by keeping track of the UTXOs.
If an input is in the UTXO set, that transaction input both exists and is <em>not</em> double-spending.
If the transaction passes the rest of the validity tests, then we remove all the inputs of the transaction from the UTXO set.
Light clients that do not have access to the blockchain have to trust other nodes for a lot of the information, including whether an input has already been spent.</p>
</div>
<div class="paragraph">
<p>A full node can check the spentness of an input pretty easily, but a light client has to get this information from someone else.</p>
</div>
</div>
<div class="sect3">
<h4 id="_checking_the_sum_of_the_inputs_versus_the_sum_of_the_outputs">Checking the Sum of the Inputs Versus the Sum of the Outputs</h4>
<div class="paragraph">
<p>Nodes also make sure that the sum of the inputs is greater than or equal to the sum of the outputs.
This ensures that the transaction does not create new coins.
The one exception is a coinbase transaction, which we&#8217;ll study more in <a href="#chapter_blocks">Blocks</a>.
Since inputs don&#8217;t have an amount field, this must be looked up on the blockchain.
Once again, full nodes have access to the amounts associated with the unspent output, but light clients have to depend on full nodes to supply this information.</p>
</div>
<div class="paragraph">
<p>We covered how to calculate fees in <a href="#chapter_tx_parsing">Transactions</a>.
Checking that the sum of the inputs is greater than or equal to the sum of the outputs is the same as checking that the fee is not negative (that is, creating money).
Recall the last exercise in <a href="#chapter_tx_parsing">Transactions</a>.
The method <code>fee</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
    ...
    def fee(self):
        '''Returns the fee of this transaction in satoshi'''
        input_sum, output_sum = 0, 0
        for tx_in in self.tx_ins:
            input_sum += tx_in.value(self.testnet)
        for tx_out in self.tx_outs:
            output_sum += tx_out.amount
        return input_sum - output_sum</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can test to see if this transaction is trying to create money by using this method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from tx import Tx
&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; raw_tx = ('0100000001813f79011acb80925dfe69b3def355fe914bd1d96a3f5f71bf830\
3c6a989c7d1000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccf\
cf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8\
e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278\
afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88a\
c99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600')
&gt;&gt;&gt; stream = BytesIO(bytes.fromhex(raw_tx))
&gt;&gt;&gt; transaction = Tx.parse(stream)
&gt;&gt;&gt; print(transaction.fee() &gt;= 0)  # <b class="conum">(1)</b>
True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This only works because we&#8217;re using Python (see <a href="#valueOverflow">The Value Overflow Incident</a>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the fee is negative, we know that the <code>output_sum</code> is greater than the <code>input_sum</code>, which is another way of saying that this transaction is trying to create bitcoins out of the ether.</p>
</div>
<div id="valueOverflow" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">The Value Overflow Incident</div>
<div class="paragraph">
<p>Back in 2010, there was a transaction that created 184 billion new bitcoins.
This was due to the fact that in C++, the amount field is a <em>signed</em> integer and not an <em>unsigned</em> integer.
That is, the value could be negative!</p>
</div>
<div class="paragraph">
<p>The clever transaction passed all the checks, including the one for not creating new bitcoins, but only because the output amounts overflowed past the maximum number.
2<sup>64</sup> is ~1.84 &#215; 10<sup>19</sup> satoshis, which is 184 billion bitcoins.
The fee was negative by enough that the C++ code was tricked into believing that the fee was actually positive by 0.1 BTC!</p>
</div>
<div class="paragraph">
<p>The vulnerability is detailed in CVE-2010-5139 and was patched via a soft fork in Bitcoin Core 0.3.11.
The transaction and the extra bitcoins it created were invalidated retroactively by a block reorganization, which is another way of saying that the block including the value overflow transaction and all the blocks built on top of it were replaced.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_checking_the_signature">Checking the Signature</h4>
<div class="paragraph">
<p>Perhaps the trickiest part of validating a transaction is the process of checking its signatures.
A transaction typically has at least one signature per input.
If there are multisig outputs being spent, there may be more than one.
As we learned in <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>, the ECDSA signature algorithm requires the public key <em>P</em>, the signature hash <em>z</em>, and the signature (<em>r</em>,<em>s</em>).
Once these are known, the process of verifying the signature is pretty simple, as we already coded in <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import S256Point, Signature
&gt;&gt;&gt; sec = bytes.fromhex('0349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e\
213bf016b278a')
&gt;&gt;&gt; der = bytes.fromhex('3045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031c\
cfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9\
c8e10615bed')
&gt;&gt;&gt; z = 0x27e0c5994dec7824e56dec6b2fcb342eb7cdb0d0957c2fce9882f715e85d81a6
&gt;&gt;&gt; point = S256Point.parse(sec)
&gt;&gt;&gt; signature = Signature.parse(der)
&gt;&gt;&gt; print(point.verify(z, signature))
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>SEC public keys and DER signatures are in the stack when a command like <code>OP_CHECKSIG</code> is executed, making getting the public key and signature pretty straightforward (see <a href="#chapter_script">Script</a>).
The hard part is getting the signature hash.
A naive way to do this would be to hash the transaction serialization as shown in <a href="#a_signature_is_in_the_yellow_highlighted_part_or_the_scriptsig">A signature is in the yellow highlighted part, or the ScriptSig</a>.
Unfortunately, we can&#8217;t do that, since the signature is part of the ScriptSig and a signature can&#8217;t sign itself.</p>
</div>
<div id="a_signature_is_in_the_yellow_highlighted_part_or_the_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0701.png" alt="Validation Start">
</div>
<div class="title">Figure 81. A signature is in the yellow highlighted part, or the ScriptSig</div>
</div>
<div class="paragraph">
<p>Instead, we modify the transaction before signing it.
That is, we compute a different signature hash <em>for each input</em>.
The procedure is as follows.</p>
</div>
<div class="sect4">
<h5 id="_step_1_empty_all_the_scriptsigs">Step 1: Empty all the ScriptSigs</h5>
<div class="paragraph">
<p>The first step is to empty all the ScriptSigs when checking the signature (<a href="#empty_each_inputs_scriptsig_in_yellow_highlighted_field">Empty each input&#8217;s ScriptSig (in yellow highlighted field, now 00)</a>).
The same procedure is used for creating the signature, except the ScriptSigs are usually already empty.</p>
</div>
<div id="empty_each_inputs_scriptsig_in_yellow_highlighted_field" class="imageblock">
<div class="content">
<img src="./images/prbc_0702.png" alt="Validation Step 1">
</div>
<div class="title">Figure 82. Empty each input&#8217;s ScriptSig (in yellow highlighted field, now 00)</div>
</div>
<div class="paragraph">
<p>Note that this example has only one input, so only that input&#8217;s ScriptSig is emptied, but it&#8217;s possible to have more than one input. In that case, each of those would be emptied.</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_2_replace_the_scriptsig_of_the_input_being_signed_with_the_previous_scriptpubkey">Step 2: Replace the ScriptSig of the input being signed with the previous ScriptPubKey</h5>
<div class="paragraph">
<p>Each input points to a previous transaction output, which has a ScriptPubKey. Recall the diagram from <a href="#chapter_script">Script</a>, shown again in <a href="#scriptpubkey_and_scriptsig2">Combining the ScriptPubKey and ScriptSig</a>.</p>
</div>
<div id="scriptpubkey_and_scriptsig2" class="imageblock">
<div class="content">
<img src="./images/prbc_0703.png" alt="ScriptPubKey and ScriptSig">
</div>
<div class="title">Figure 83. Combining the ScriptPubKey and ScriptSig</div>
</div>
<div class="paragraph">
<p>We take the ScriptPubKey that the input is pointing to and put that in place of the empty ScriptSig (<a href="#replace_the_scriptsig_yellow_highlighted_field_for_one_of_the_inputs_with_the_previous_scriptpubkey">Replace the ScriptSig (yellow highlighted field) for one of the inputs with the previous ScriptPubKey</a>).
This may require a lookup on the blockchain, but in practice the signer already knows the ScriptPubKey, as the input is one where the signer has the private key.</p>
</div>
<div id="replace_the_scriptsig_yellow_highlighted_field_for_one_of_the_inputs_with_the_previous_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_0704.png" alt="Validation Step 2">
</div>
<div class="title">Figure 84. Replace the ScriptSig (yellow highlighted field) for one of the inputs with the previous ScriptPubKey</div>
</div>
</div>
<div class="sect4">
<h5 id="_step_3_append_the_hash_type">Step 3: Append the hash type</h5>
<div class="paragraph">
<p>Last, we add a 4-byte hash type to the end.
This is to specify what the signature is authorizing.
The signature can authorize this input to go with all the other inputs and outputs (<code>SIGHASH_ALL</code>), go with a specific output (<code>SIGHASH_SINGLE</code>), or go with any output whatsoever (<code>SIGHASH_NONE</code>).
The latter two have some theoretical use cases, but in practice, almost every transaction is signed with <code>SIGHASH_ALL</code>.
There&#8217;s also a rarely used hash type called <code>SIGHASH_ANYONECANPAY</code> that can be combined with any of the previous three, which we won&#8217;t get into here.
For <code>SIGHASH_ALL</code>, the final transaction must have the exact outputs that were signed or the input signature is invalid.</p>
</div>
<div class="paragraph">
<p>The integer corresponding to <code>SIGHASH_ALL</code> is 1 and this has to be encoded in little-endian over 4 bytes, which makes the modified transaction look like <a href="#append_the_hash_type_sighash_all_or_the_orange_01000000">Append the hash type (SIGHASH_ALL), or the brown 01000000</a>.</p>
</div>
<div id="append_the_hash_type_sighash_all_or_the_orange_01000000" class="imageblock">
<div class="content">
<img src="./images/prbc_0705.png" alt="Validation Step 3">
</div>
<div class="title">Figure 85. Append the hash type (SIGHASH_ALL), or the brown 01000000</div>
</div>
<div class="paragraph">
<p>The hash256 of this modified transaction is interpreted as a big-endian integer to produce <em>z</em>.
The code for converting the modified transaction to <em>z</em> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; modified_tx = bytes.fromhex('0100000001813f79011acb80925dfe69b3def355fe914\
bd1d96a3f5f71bf8303c6a989c7d1000000001976a914a802fc56c704ce87c42d7c92eb75e7896\
bdc41ae88acfeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02\
e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288a\
c1943060001000000')
&gt;&gt;&gt; h256 = hash256(modified_tx)
&gt;&gt;&gt; z = int.from_bytes(h256, 'big')
&gt;&gt;&gt; print(hex(z))
0x27e0c5994dec7824e56dec6b2fcb342eb7cdb0d0957c2fce9882f715e85d81a6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have our <em>z</em>, we can take the public key in SEC format and the signature in DER format from the ScriptSig to verify the signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import S256Point, Signature
&gt;&gt;&gt; sec = bytes.fromhex('0349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e\
213bf016b278a')
&gt;&gt;&gt; der = bytes.fromhex('3045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031c\
cfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9\
c8e10615bed')
&gt;&gt;&gt; z = 0x27e0c5994dec7824e56dec6b2fcb342eb7cdb0d0957c2fce9882f715e85d81a6
&gt;&gt;&gt; point = S256Point.parse(sec)
&gt;&gt;&gt; signature = Signature.parse(der)
&gt;&gt;&gt; point.verify(z, signature)
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can code this transaction validation process into a method for <code>Tx</code>.
Thankfully, the Script engine can already handle signature verification (see <a href="#chapter_script">Script</a>), so our task here is to glue everything together.
We need <em>z</em>, or the signature hash, to pass into the <code>evaluate</code> method and we need to combine the ScriptSig and ScriptPubKey.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Quadratic Hashing</div>
<div class="paragraph">
<p>The signature hashing algorithm is inefficient and wasteful.
The <em>quadratic hashing problem</em> states that time required to calculate the signature hashes increases quadratically with the number of inputs in a transaction.
Specifically, not only will the number of hash256 operations for calculating <em>z</em> increase on a per-input basis, but in addition, the length of the transaction will increase, slowing down each hash256 operation because the entire signature hash will need to be calculated anew for each input.</p>
</div>
<div class="paragraph">
<p>This was particularly obvious with the biggest transaction mined to date:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2
b4e3e08</pre>
</div>
</div>
<div class="paragraph">
<p>This transaction had 5,569 inputs and 1 output and took many miners over a minute to validate, as the signature hashes for the transaction were expensive to calculate.</p>
</div>
<div class="paragraph">
<p>Segwit (<a href="#chapter_segwit">Segwit</a>) fixes this with a different way of calculating the signature hash, which is specified in BIP0143.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_1_7">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>sig_hash</code> method for the <code>Tx</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_7">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>verify_input</code> method for the <code>Tx</code> class. You will want to use the <code>TxIn.script_pubkey</code>, <code>Tx.sig_hash</code>, and <code>Script.evaluate</code> methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="_verifying_the_entire_transaction">Verifying the Entire Transaction</h4>
<div class="paragraph">
<p>Now that we can verify an input, the task of verifying the entire transaction is straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def verify(self):
        '''Verify this transaction'''
        if self.fee() &lt; 0:  # <b class="conum">(1)</b>
            return False
        for i in range(len(self.tx_ins)):
            if not self.verify_input(i):  # <b class="conum">(2)</b>
                return False
        return True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We make sure that we are not creating money.</p>
</li>
<li>
<p>We make sure that each input has a correct ScriptSig.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that a full node would verify more things, like checking for double-spends and checking some other consensus rules not discussed in this chapter (max sigops, size of ScriptSig, etc.), but this is good enough for our library.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_transactions">Creating Transactions</h3>
<div class="paragraph">
<p>The code to verify transactions will help quite a bit with creating transactions.
We can create transactions that fit the verification process.
Transactions we create will require the sum of the inputs to be greater than or equal to the sum of the outputs.
Similarly, transactions we create will require a ScriptSig that, when combined with the ScriptPubKey, will be valid.</p>
</div>
<div class="paragraph">
<p>To create a transaction, we need at least one output we&#8217;ve received.
That is, we need an output from the UTXO set whose ScriptPubKey we can unlock.
The vast majority of the time, we need one or more private keys corresponding to the public keys that are hashed in the ScriptPubKey.</p>
</div>
<div class="paragraph">
<p>The rest of this chapter will be concerned with creating a transaction whose inputs are locked by p2pkh ScriptPubKeys.</p>
</div>
<div class="sect3">
<h4 id="_constructing_the_transaction">Constructing the Transaction</h4>
<div class="paragraph">
<p>The construction of a transaction requires answering some basic questions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Where do we want the bitcoins to go?</p>
</li>
<li>
<p>What UTXOs can we spend?</p>
</li>
<li>
<p>How quickly do we want this transaction to get into the blockchain?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We&#8217;ll be using testnet for this example, though this can easily be applied to mainnet.</p>
</div>
<div class="paragraph">
<p>The first question is about how much we want to pay whom.
We can pay one or more addresses.
In this example, we will pay 0.1 testnet bitcoins (tBTC) to <code>mnrVtF8DWjMu839VW3rBfgYaAfKk8983Xf</code>.</p>
</div>
<div class="paragraph">
<p>The second question is about what&#8217;s in our wallet.
What do we have available to spend?
In this example, we have an output denoted by a transaction ID and output index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0d6fe5213c0b3291f208cba8bfb59b7476dffacc4e5cb66f6eb20a080843a299:13</pre>
</div>
</div>
<div class="paragraph pagebreak-before">
<p>When we view this output on a testnet block explorer (<a href="#utxo_that_were_spending">UTXO that we&#8217;re spending</a>), we can see that our output is worth 0.44 tBTC.</p>
</div>
<div id="utxo_that_were_spending" class="imageblock">
<div class="content">
<img src="./images/prbc_0706.png" alt="Transaction seen on the blockchain">
</div>
<div class="title">Figure 86. UTXO that we&#8217;re spending</div>
</div>
<div class="paragraph">
<p>Since this is more than 0.1 tBTC, we&#8217;ll want to send the rest back to ourselves.
Though it&#8217;s generally bad privacy and security practice to reuse addresses, we&#8217;ll send the bitcoins back to <code>mzx5YhAH9kNHtcN481u6WkjeHjYtVeKVh2</code> to make the transaction construction easier.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Why Reusing Addresses Is a Bad Idea</div>
<div class="paragraph">
<p>Back in <a href="#chapter_script">Script</a>, we went through how p2pk was inferior to p2pkh, in part because it was only protected by ECDSA.
p2pkh, on the other hand, is also protected by sha256 and ripemd160.
However, because the blockchain is public, once we spend from a ScriptPubKey corresponding to our address, we reveal our public key as part of the ScriptSig.
Once we&#8217;ve revealed that public key, sha256 and ripemd160 no longer protect us, as the attacker knows the public key and doesn&#8217;t have to guess it.</p>
</div>
<div class="paragraph">
<p>As of this writing, we are still protected by the discrete log problem, which is unlikely to be broken any time soon.
It&#8217;s important from a security perspective, however, to understand what we&#8217;re protected by.</p>
</div>
<div class="paragraph">
<p>The other reason to not reuse addresses is for privacy.
Having a single address for all our transactions means that people can link our transactions together.
If, for example, we bought something private (say, medication to treat some disease we don&#8217;t want others to know about) and spent another output with the same ScriptPubKey for a donation to some charity, the charity and the medication vendor could identify that we had done business with the other.</p>
</div>
<div class="paragraph">
<p>Privacy leaks tend to become security holes over time.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The third question is really about fees.
If we want to get the transaction in the blockchain faster, we&#8217;ll have to pay more fees; if we don&#8217;t mind waiting, we can pay less.
In our case, we&#8217;ll use 0.01 tBTC as our fee.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Fee Estimation</div>
<div class="paragraph">
<p>Fee estimation is done on a per-byte basis.
If your transaction is 600 bytes, it will have double the fees as a transaction that&#8217;s 300 bytes.
This is because block space is limited and larger transactions take up more space.
This calculation has changed a bit since Segwit (see <a href="#chapter_segwit">Segwit</a>), but the general principle still applies.
We want to pay enough on a per-byte basis so that miners are motivated to include our transaction as soon as possible.</p>
</div>
<div class="paragraph">
<p>When blocks aren&#8217;t full, almost any amount above the default relay limit (1 satoshi/byte) is enough to get a transaction included.
When blocks are full, this is not an easy thing to estimate.
There are multiple ways to estimate fees, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Looking at various fee levels and estimating the probability of inclusion based on past blocks and the mempools at the time</p>
</li>
<li>
<p>Looking at the current mempool and adding a fee that roughly corresponds to enough economic incentivization</p>
</li>
<li>
<p>Going with some fixed fee</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many wallets use different strategies, and this is an active area of research.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_making_the_transaction">Making the Transaction</h4>
<div class="paragraph">
<p>We have a plan for a new transaction with one input and two outputs.
But first, let&#8217;s look at some other tools we&#8217;ll need.</p>
</div>
<div class="paragraph">
<p>We need a way to take an address and get the 20-byte hash out of it.
This is the opposite of encoding an address, so we call the function <code>decode_base58</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def decode_base58(s):
    num = 0
    for c in s:  # <b class="conum">(1)</b>
        num *= 58
        num += BASE58_ALPHABET.index(c)
    combined = num.to_bytes(25, byteorder='big')  # <b class="conum">(2)</b>
    checksum = combined[-4:]
    if hash256(combined[:-4])[:4] != checksum:
        raise ValueError('bad address: {} {}'.format(checksum,
          hash256(combined[:-4])[:4]))
    return combined[1:-4]  # <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We get what number is encoded in this Base58 address.</p>
</li>
<li>
<p>Once we have the number, we convert it to big-endian bytes.</p>
</li>
<li>
<p>The first byte is the network prefix and the last 4 are the checksum.
The middle 20 are the actual 20-byte hash (aka hash160).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We also need a way to convert the 20-byte hash to a ScriptPubKey.
We call this function <code>p2pkh_script</code> since we&#8217;re converting the hash160 to a p2pkh:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def p2pkh_script(h160):
    '''Takes a hash160 and returns the p2pkh ScriptPubKey'''
    return Script([0x76, 0xa9, h160, 0x88, 0xac])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>0x76</code> is <code>OP_DUP</code>, <code>0xa9</code> is <code>OP_HASH160</code>, <code>h160</code> is a 20-byte element, <code>0x88</code> is <code>OP_EQUALVERIFY</code>, and <code>0xac</code> is <code>OP_CHECKSIG</code>.
This is the p2pkh ScriptPubKey command set from <a href="#chapter_script">Script</a>.</p>
</div>
<div class="paragraph">
<p>Given these tools, we can proceed to transaction creation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from helper import decode_base58, SIGHASH_ALL
&gt;&gt;&gt; from script import p2pkh_script, Script
&gt;&gt;&gt; from tx import TxIn, TxOut, Tx
&gt;&gt;&gt; prev_tx = bytes.fromhex('0d6fe5213c0b3291f208cba8bfb59b7476dffacc4e5cb66f6\
eb20a080843a299')
&gt;&gt;&gt; prev_index = 13
&gt;&gt;&gt; tx_in = TxIn(prev_tx, prev_index)
&gt;&gt;&gt; tx_outs = []
&gt;&gt;&gt; change_amount = int(0.33*100000000)  # <b class="conum">(1)</b>
&gt;&gt;&gt; change_h160 = decode_base58('mzx5YhAH9kNHtcN481u6WkjeHjYtVeKVh2')
&gt;&gt;&gt; change_script = p2pkh_script(change_h160)
&gt;&gt;&gt; change_output = TxOut(amount=change_amount, script_pubkey=change_script)
&gt;&gt;&gt; target_amount = int(0.1*100000000)  # <b class="conum">(1)</b>
&gt;&gt;&gt; target_h160 = decode_base58('mnrVtF8DWjMu839VW3rBfgYaAfKk8983Xf')
&gt;&gt;&gt; target_script = p2pkh_script(target_h160)
&gt;&gt;&gt; target_output = TxOut(amount=target_amount, script_pubkey=target_script)
&gt;&gt;&gt; tx_obj = Tx(1, [tx_in], [change_output, target_output], 0, True)  # <b class="conum">(2)</b>
&gt;&gt;&gt; print(tx_obj)
tx: cd30a8da777d28ef0e61efe68a9f7c559c1d3e5bcd7b265c850ccb4068598d11
version: 1
tx_ins:
0d6fe5213c0b3291f208cba8bfb59b7476dffacc4e5cb66f6eb20a080843a299:13
tx_outs:
33000000:OP_DUP OP_HASH160 d52ad7ca9b3d096a38e752c2018e6fbc40cdf26f OP_EQUALVE\
RIFY OP_CHECKSIG
10000000:OP_DUP OP_HASH160 507b27411ccf7f16f10297de6cef3f291623eddf OP_EQUALVE\
RIFY OP_CHECKSIG
locktime: 0</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The amount must be in satoshis; given there are 100,000,000 satoshis per BTC, we have to multiply and cast to an integer.</p>
</li>
<li>
<p>We have to designate which network to look up using the <code>testnet=True</code> <span class="keep-together">argument</span>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We have created the actual transaction, but every ScriptSig in this transaction is currently empty. Filling it is where we turn next.</p>
</div>
</div>
<div class="sect3">
<h4 id="_signing_the_transaction">Signing the Transaction</h4>
<div class="paragraph">
<p>Signing the transaction could be tricky, but we know how to get the signature hash, <em>z</em>, from earlier in this chapter.
If we have the private key whose public key hash160s to the 20-byte hash in the ScriptPubKey, we can sign <em>z</em> and produce the DER signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; from helper import SIGHASH_ALL
&gt;&gt;&gt; z = transaction.sig_hash(0)  # <b class="conum">(1)</b>
&gt;&gt;&gt; private_key = PrivateKey(secret=8675309)
&gt;&gt;&gt; der = private_key.sign(z).der()
&gt;&gt;&gt; sig = der + SIGHASH_ALL.to_bytes(1, 'big')  # <b class="conum">(2)</b>
&gt;&gt;&gt; sec = private_key.point.sec()
&gt;&gt;&gt; script_sig = Script([sig, sec])  # <b class="conum">(3)</b>
&gt;&gt;&gt; transaction.tx_ins[0].script_sig = script_sig   # <b class="conum">(4)</b>
&gt;&gt;&gt; print(transaction.serialize().hex())
0100000001813f79011acb80925dfe69b3def355fe914bd1d96a3f5f71bf8303c6a989c7d10000\
00006a47304402207db2402a3311a3b845b038885e3dd889c08126a8570f26a844e3e4049c482a\
11022010178cdca4129eacbeab7c44648bf5ac1f9cac217cd609d216ec2ebc8d242c0a01210393\
5581e52c354cd2f484fe8ed83af7a3097005b2f9c60bff71d35bd795f54b67feffffff02a135ef\
01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c3980000000000\
1976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We only need to sign the first input—there&#8217;s only one.
Multiple inputs would require us to sign each input with the right private key.</p>
</li>
<li>
<p>The signature is actually a combination of the DER signature and the hash type, which is <code>SIGHASH_ALL</code> in our case.</p>
</li>
<li>
<p>The ScriptSig of a p2pkh has exactly two elements, as we saw in <a href="#chapter_script">Script</a>: the signature and SEC format public key.</p>
</li>
<li>
<p>We only have one input that we need to sign, but if there were more, this process of creating the ScriptSig would need to be done for each input.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_7">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>sign_input</code> method for the <code>Tx</code> class.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_your_own_transactions_on_testnet">Creating Your Own Transactions on testnet</h3>
<div class="paragraph">
<p>To create your own transaction, get some coins for yourself.
To do that you&#8217;ll need an address.
If you completed the last exercise in <a href="#chapter_serialization">Serialization</a>, you should have your own testnet address and private key.
If you don&#8217;t remember, here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; from helper import hash256, little_endian_to_int
&gt;&gt;&gt; secret = little_endian_to_int(hash256(b'Jimmy Song secret'))  # <b class="conum">(1)</b>
&gt;&gt;&gt; private_key = PrivateKey(secret)
&gt;&gt;&gt; print(private_key.point.address(testnet=True))
mn81594PzKZa9K3Jyy1ushpuEzrnTnxhVg</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Please use a phrase other than <code>Jimmy Song secret</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once you have an address, you can get some coins from one of the testnet faucets that provide free testnet coins for testing purposes.
You can Google "testnet bitcoin faucet" to find one, or use one from the <a href="https://en.bitcoin.it/wiki/Testnet#Faucets">list on the wiki</a>.
My website, <a href="https://faucet.programmingbitcoin.com" class="bare">https://faucet.programmingbitcoin.com</a>, is also updated to point to a testnet faucet that works.
Enter your new testnet address into any of these faucets to get some testnet coins.</p>
</div>
<div class="paragraph">
<p>After receiving some coins, spend them using this library.
This is a big accomplishment for a budding Bitcoin developer, so please take some time to complete these exercises.</p>
</div>
<div class="sect3">
<h4 id="_exercise_4_7">Exercise 4</h4>
<div class="paragraph">
<p>Create a testnet transaction that sends 60% of a single UTXO to <code>mwJn1YPMq7y5F8J3LkC5Hxg9PHyZ5K4cFv</code>. The remaining amount minus fees should go back to your own change address. This should be a one-input, two-output <span class="keep-together">transaction</span>.</p>
</div>
<div class="paragraph">
<p>You can broadcast the transaction at <a href="https://blockstream.info/testnet/tx/push" class="bare">https://blockstream.info/testnet/tx/push</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_6">Exercise 5</h4>
<div class="paragraph">
<p>Advanced: Get some more testnet coins from a testnet faucet and create a two-input, one-output transaction. One input should be from the faucet, the other should be from the previous exercise; the output can be your own address.</p>
</div>
<div class="paragraph">
<p>You can broadcast the transaction at <a href="https://blockstream.info/testnet/tx/push" class="bare">https://blockstream.info/testnet/tx/push</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_7">Conclusion</h3>
<div class="paragraph">
<p>We&#8217;ve successfully validated existing transactions on the blockchain, and you&#8217;ve also created your own transactions on testnet!
This is a major achievement, and you should be proud.</p>
</div>
<div class="paragraph">
<p>The code we have so far will do p2pkh and p2pk.
In the next chapter, we turn to a more advanced smart contract, p2sh.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_p2sh">Pay-to-Script Hash</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>Up to this point in the book, we&#8217;ve been doing single-key transactions, or transactions with only a single private key per input.
What if we wanted something a little more complicated?
A company that has $100 million in bitcoin might not want the funds locked to a single private key: if that single key were lost or stolen, all funds would then be lost.
What can we do to reduce the risk of this single point of failure?</p>
</div>
<div class="paragraph">
<p>The solution is <em>multisig</em>, or multiple signatures.
This was built into Bitcoin from the beginning, but was clunky at first and so wasn&#8217;t used.
As we&#8217;ll discover later in this chapter, Satoshi probably didn&#8217;t test multisig, as it has an off-by-one error (see <a href="#off-by-one">OP_CHECKMULTISIG Off-by-One Bug</a>).
The bug has had to stay in the protocol because fixing it would require a hard fork.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Multiple Private Keys to a Single Aggregated Public Key</div>
<div class="paragraph">
<p>It is possible to "split" a single private key into multiple private keys and use an interactive method to aggregate signatures without ever reconstructing the private key, but this is not a common practice.
Schnorr signatures will make aggregating signatures easier and perhaps more common in the future.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_bare_multisig">Bare Multisig</h3>
<div class="paragraph">
<p>Bare multisig was the first attempt at creating transaction outputs that require signatures from multiple parties.
The idea is to change from a single point of failure to something a little more resilient to hacks.
To understand bare multisig, one must first understand the <code>OP_CHECKMULTISIG</code> opcode.
As discussed in <a href="#chapter_script">Script</a>, Script has a lot of different opcodes.
<code>OP_CHECKMULTISIG</code> is one of them, at <code>0xae</code>.
The opcode <span class="keep-together">consumes</span> a lot of elements from the stack and returns whether or not the required number of signatures are valid for a transaction input.</p>
</div>
<div class="paragraph">
<p>The transaction output is called "bare" multisig because it&#8217;s a long ScriptPubKey.
<a href="#bare_multisig_scriptpubkey">Bare multisig ScriptPubKey</a> shows what a ScriptPubKey for a 1-of-2 multisig looks like.</p>
</div>
<div id="bare_multisig_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_0801.png" alt="Bare multisig ScriptPubKey">
</div>
<div class="title">Figure 87. Bare multisig ScriptPubKey</div>
</div>
<div class="paragraph">
<p>Among bare multisig ScriptPubKeys, this one is on the small end, and we can already see that it&#8217;s long.
The ScriptPubKey for p2pkh is only 25 bytes, whereas this bare multisig is 101 bytes (though obviously, compressed SEC format would reduce it some), and this is a 1-of-2!
<a href="#bare_multisig_scriptsig">Bare multisig ScriptSig</a> shows what the ScriptSig looks like.</p>
</div>
<div id="bare_multisig_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0802.png" alt="Bare multisig ScriptSig">
</div>
<div class="title">Figure 88. Bare multisig ScriptSig</div>
</div>
<div class="paragraph">
<p>We only need 1 signature for this 1-of-2 multisig, so this is relatively short; something like a 5-of-7 would require 5 DER signatures and would be a lot longer (360 bytes or so).
<a href="#bare_multisig_combined_script">Bare multisig combined script</a> shows how the ScriptSig and ScriptPubKey combine.</p>
</div>
<div id="bare_multisig_combined_script" class="imageblock">
<div class="content">
<img src="./images/prbc_0803.png" alt="Bare multisig combined script">
</div>
<div class="title">Figure 89. Bare multisig combined script</div>
</div>
<div class="paragraph">
<p>I&#8217;ve generalized here to show what an <em>m</em>-of-<em>n</em> bare multisig would look like (<em>m</em> and <em>n</em> can be anything from 1 to 20 inclusive, though the numerical opcodes only go up to <code>OP_16</code>; values of 17 to 20 would require <code>0112</code> to push a number like 18 to the stack).
The starting state looks like <a href="#bare_multisig_start">Bare multisig start</a>.</p>
</div>
<div id="bare_multisig_start" class="imageblock">
<div class="content">
<img src="./images/prbc_0804.png" alt="Bare multisig start">
</div>
<div class="title">Figure 90. Bare multisig start</div>
</div>
<div class="paragraph">
<p><code>OP_0</code> will push the number 0 to the stack (<a href="#bare_multisig_step_1">Bare multisig step 1</a>).</p>
</div>
<div id="bare_multisig_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_0805.png" alt="Bare multisig step 1">
</div>
<div class="title">Figure 91. Bare multisig step 1</div>
</div>
<div class="paragraph">
<p>The signatures are elements, so they&#8217;ll be pushed directly to the stack (<a href="#bare_multisig_step_2">Bare multisig step 2</a>).</p>
</div>
<div id="bare_multisig_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_0806.png" alt="Bare multisig step 2">
</div>
<div class="title">Figure 92. Bare multisig step 2</div>
</div>
<div class="paragraph">
<p><code>OP_m</code> will push the number <em>m</em> to the stack, the public keys will be pushed to the stack, and <code>OP_n</code> will push the number <em>n</em> to the stack (<a href="#bare_multisig_step_3">Bare multisig step 3</a>).</p>
</div>
<div id="bare_multisig_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_0807.png" alt="Bare multisig step 3">
</div>
<div class="title">Figure 93. Bare multisig step 3</div>
</div>
<div class="paragraph">
<p>At this point, <code>OP_CHECKMULTISIG</code> will consume <em>m</em> + <em>n</em> + 3 elements (see <a href="#off-by-one">OP_CHECKMULTISIG Off-by-One Bug</a>) and push a 1 to the stack if <em>m</em> of the signatures are valid for <em>m</em> distinct public keys from the list of <em>n</em> public keys; otherwise, it pushes a 0.
Assuming that the signatures are valid, the stack has a single 1, which validates the combined script (<a href="#bare_multisig_end">Bare multisig end</a>).</p>
</div>
<div id="bare_multisig_end" class="imageblock">
<div class="content">
<img src="./images/prbc_0808.png" alt="Bare multisig end">
</div>
<div class="title">Figure 94. Bare multisig end</div>
</div>
<div id="off-by-one" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">OP_CHECKMULTISIG Off-by-One Bug</div>
<div class="paragraph">
<p>The stack elements consumed by <code>OP_CHECKMULTISIG</code> are supposed to be <em>m</em>, <em>m</em> different signatures, <em>n</em> and <em>n</em> different pubkeys. The number of elements consumed should be 2 (<em>m</em> and <em>n</em> themselves) + <em>m</em> (signatures) + <em>n</em> (pubkeys).
Unfortunately, the opcode consumes one more element than the <em>m</em> + <em>n</em> + 2 elements that it&#8217;s supposed to.
<code>OP_CHECKMULTISIG</code> consumes <em>m</em> + <em>n</em> + 3 elements, so an extra element is added (<code>OP_0</code> in our example) so as to not cause a failure.</p>
</div>
<div class="paragraph">
<p>The opcode does nothing with that extra element, and that extra element can be anything. As a way to combat malleability, however, most nodes on the Bitcoin network will not relay the transaction unless the extra element is <code>OP_0</code>.
Note that if we had <em>m</em> + <em>n</em> + 2 elements, <code>OP_CHECKMULTISIG</code> would fail as there are not enough elements to be consumed and the combined script would fail, causing the transaction to be invalid.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_coding_op_checkmultisig">Coding OP_CHECKMULTISIG</h3>
<div class="paragraph">
<p>In an <em>m</em>-of-<em>n</em> bare multisig, the stack contains <em>n</em> as the top element, then <em>n</em> pubkeys, then <em>m</em>, then <em>m</em> signatures, and finally a filler item due to the off-by-one bug.
The code for <code>OP_CHECKMULTISIG</code> in <em>op.py</em> is mostly written here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def op_checkmultisig(stack, z):
    if len(stack) &lt; 1:
        return False
    n = decode_num(stack.pop())
    if len(stack) &lt; n + 1:
        return False
    sec_pubkeys = []
    for _ in range(n):
        sec_pubkeys.append(stack.pop())
    m = decode_num(stack.pop())
    if len(stack) &lt; m + 1:
        return False
    der_signatures = []
    for _ in range(m):
        der_signatures.append(stack.pop()[:-1])  # <b class="conum">(1)</b>
    stack.pop()  # <b class="conum">(2)</b>
    try:
        raise NotImplementedError  # <b class="conum">(3)</b>
    except (ValueError, SyntaxError):
        return False
    return True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Each DER signature is assumed to be signed with <code>SIGHASH_ALL</code>.</p>
</li>
<li>
<p>We take care of the off-by-one error by consuming the only remaining element of the stack and not doing anything with the element.</p>
</li>
<li>
<p>This is the part that you will need to code for the next exercise.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_1_8">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>op_checkmultisig</code> function of <em>op.py</em>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_problems_with_bare_multisig">Problems with Bare Multisig</h3>
<div class="paragraph">
<p>Bare multisig is a bit ugly, but it is functional.
It avoids the single point of failure by requiring <em>m</em> of <em>n</em> signatures to unlock a UTXO.
There is plenty of utility in making outputs multisig, especially if you&#8217;re a business.
However, bare multisig suffers from a few problems:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A bare multisig ScriptPubKey has many different public keys, and that makes the ScriptPubKey long.
Unlike p2pkh or even p2pk ScriptPubKeys, these are not easily communicated using voice or even text messages.</p>
</li>
<li>
<p>Because the output is so long—5 to 20 times larger than a normal p2pkh output—it requires more resources for node software.
Nodes keep track of the UTXO set, and a big ScriptPubKey is more expensive to keep track of.
A large output is more expensive to keep in fast-access storage (like RAM).</p>
</li>
<li>
<p>Because the ScriptPubKey can be so big, bare multisig can and has been abused.
The entire PDF of Satoshi&#8217;s original whitepaper is encoded in this transaction in block 230009:</p>
<div class="listingblock">
<div class="content">
<pre>54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713</pre>
</div>
</div>
<div class="paragraph">
<p>The creator of this transaction split up the whitepaper PDF into 64-byte chunks, which were then made into invalid uncompressed public keys.
The whitepaper was encoded into 947 1-of-3 bare multisig outputs.
These outputs are not spendable but have to be indexed in the UTXO sets of full nodes.
This is a tax every full node has to pay and is in that sense abusive.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>To mitigate these problems, pay-to-script-hash (p2sh) was born.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pay_to_script_hash_p2sh">Pay-to-Script-Hash (p2sh)</h3>
<div class="paragraph">
<p>Pay-to-script-hash (p2sh) is a general solution to the long address/ScriptPubKey problem.
More complicated ScriptPubKeys than bare multisig can easily be made, and they have the same problems as bare multisig.</p>
</div>
<div class="paragraph">
<p>The solution that p2sh implements is to take the hash of some Script commands and then reveal the preimage Script commands later.
Pay-to-script-hash was introduced in 2011 to a lot of controversy.
There were multiple proposals, but as we&#8217;ll see, p2sh is kludgy but works.</p>
</div>
<div class="paragraph">
<p>In p2sh, a special rule gets executed only when the pattern shown in <a href="#pay_to_script_hash_pattern_that_executes_the_special_rule">Pay-to-script-hash pattern (p2sh) that executes the special rule</a> is encountered.</p>
</div>
<div id="pay_to_script_hash_pattern_that_executes_the_special_rule" class="imageblock">
<div class="content">
<img src="./images/prbc_0809.png" alt="p2sh Pattern">
</div>
<div class="title">Figure 95. Pay-to-script-hash pattern (p2sh) that executes the special rule</div>
</div>
<div class="paragraph">
<p>If this exact command set ends with a 1 on the stack, then the RedeemScript (the top item in <a href="#pay_to_script_hash_pattern_that_executes_the_special_rule">Pay-to-script-hash pattern (p2sh) that executes the special rule</a>) is parsed and then added to the Script command set.
This special pattern was introduced in BIP0016, and Bitcoin software that implements BIP0016 (anything post 2011) checks for the pattern.
The RedeemScript does not add new Script commands for processing unless this <em>exact</em> sequence is encountered and ends with a 1.</p>
</div>
<div class="paragraph">
<p>If this sounds hacky, it is.
But before we get to that, let&#8217;s look a little more closely at exactly how this plays out.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say we have a 2-of-2 multisig ScriptPubKey (<a href="#pay_to_script_hash_p2sh_redeemscript">Pay-to-script-hash (p2sh) RedeemScript</a>).</p>
</div>
<div id="pay_to_script_hash_p2sh_redeemscript" class="imageblock">
<div class="content">
<img src="./images/prbc_0810.png" alt="p2sh RedeemScript">
</div>
<div class="title">Figure 96. Pay-to-script-hash (p2sh) RedeemScript</div>
</div>
<div class="paragraph">
<p>This is a ScriptPubKey for a bare multisig.
What we need to do to convert this to p2sh is to take a hash of this script and keep the script handy for when we want to redeem it.
We call this the RedeemScript, because the script is only revealed during redemption.
We put the hash of the RedeemScript as the ScriptPubKey (<a href="#pay_to_script_hash_p2sh_scriptpubkey">Pay-to-script-hash (p2sh) ScriptPubKey</a>).</p>
</div>
<div id="pay_to_script_hash_p2sh_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_0811.png" alt="p2sh ScriptPubKey">
</div>
<div class="title">Figure 97. Pay-to-script-hash (p2sh) ScriptPubKey</div>
</div>
<div class="paragraph">
<p>The hash digest here is the hash160 of the RedeemScript, or what was previously the ScriptPubKey.
We&#8217;re locking the funds to the <em>hash</em> of the RedeemScript, which needs to be revealed at unlock time.</p>
</div>
<div class="paragraph">
<p>Creating the ScriptSig for a p2sh script involves not only revealing the RedeemScript, but also unlocking the RedeemScript.
At this point, you might be wondering where the RedeemScript is stored. It&#8217;s not on the blockchain until actual redemption, so it must be stored by the creator of the p2sh address.
If the RedeemScript is lost and cannot be reconstructed, the funds are lost, so it&#8217;s very important to keep track of it!</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Importance of Keeping the RedeemScript</div>
<div class="paragraph">
<p>If you are receiving to a p2sh address, be sure to store and back up the RedeemScript!
Better yet, make it easy to reconstruct!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The ScriptSig for the 2-of-2 multisig looks like <a href="#pay_to_script_has_p2sh_scriptsig">Pay-to-script-hash (p2sh) ScriptSig</a>.</p>
</div>
<div id="pay_to_script_has_p2sh_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0812.png" alt="p2sh ScriptSig">
</div>
<div class="title">Figure 98. Pay-to-script-hash (p2sh) ScriptSig</div>
</div>
<div class="paragraph">
<p>This produces the combined script in <a href="#p2sh_combined">p2sh combined script</a>.</p>
</div>
<div id="p2sh_combined" class="imageblock">
<div class="content">
<img src="./images/prbc_0813.png" alt="p2sh Combined script">
</div>
<div class="title">Figure 99. p2sh combined script</div>
</div>
<div class="paragraph">
<p>As before, <code>OP_0</code> is there because of the <code>OP_CHECKMULTISIG</code> bug.
The key to understanding p2sh is the execution of the exact sequence shown in <a href="#p2sh_pattern_that_executes_the_special_rule">p2sh pattern that executes the special rule</a>.</p>
</div>
<div id="p2sh_pattern_that_executes_the_special_rule" class="imageblock">
<div class="content">
<img src="./images/prbc_0814.png" alt="p2sh Pattern">
</div>
<div class="title">Figure 100. p2sh pattern that executes the special rule</div>
</div>
<div class="paragraph">
<p>Upon execution of this sequence, if the stack is left with a 1, the RedeemScript is inserted into the Script command set.
In other words, if we reveal a RedeemScript whose hash160 is the same as the hash160 in the ScriptPubKey, that RedeemScript acts like the ScriptPubKey instead.
We hash the script that locks the funds and put that into the blockchain instead of the script itself.
This is why we call this ScriptPubKey pay-to-script-<em>hash</em>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s go through exactly how this works.
We start with the Script commands (<a href="#p2sh_start">p2sh start</a>).</p>
</div>
<div id="p2sh_start" class="imageblock">
<div class="content">
<img src="./images/prbc_0815.png" alt="p2sh start">
</div>
<div class="title">Figure 101. p2sh start</div>
</div>
<div class="paragraph">
<p><code>OP_0</code> will push a 0 to the stack, and the two signatures and the RedeemScript will be pushed to the stack directly, leading to <a href="#p2sh_step_1">p2sh step 1</a>.</p>
</div>
<div id="p2sh_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_0816.png" alt="p2sh step 1">
</div>
<div class="title">Figure 102. p2sh step 1</div>
</div>
<div class="paragraph">
<p><code>OP_HASH160</code> will hash the RedeemScript, which will make the stack look like <a href="#p2sh_step_2">p2sh step 2</a>.</p>
</div>
<div id="p2sh_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_0817.png" alt="p2sh step 2">
</div>
<div class="title">Figure 103. p2sh step 2</div>
</div>
<div class="paragraph">
<p>The 20-byte hash will be pushed to the stack (<a href="#p2sh_step_3">p2sh step 3</a>).</p>
</div>
<div id="p2sh_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_0818.png" alt="p2sh step 3">
</div>
<div class="title">Figure 104. p2sh step 3</div>
</div>
<div class="paragraph">
<p>And finally, <code>OP_EQUAL</code> will compare the top two elements.
If the software checking this transaction is pre-BIP0016, we will end up with <a href="#p2sh_end_if_evaluating_with_pre_bip0016_software">p2sh end if evaluating with pre-BIP0016 software</a>.</p>
</div>
<div id="p2sh_end_if_evaluating_with_pre_bip0016_software" class="imageblock">
<div class="content">
<img src="./images/prbc_0819.png" alt="p2sh pre-BIP0016 End">
</div>
<div class="title">Figure 105. p2sh end if evaluating with pre-BIP0016 software</div>
</div>
<div class="paragraph">
<p>This would end evaluation for pre-BIP0016 nodes and the result would be valid, assuming the hashes are equal.</p>
</div>
<div class="paragraph">
<p>On the other hand, BIP0016 nodes, which as of this writing are the vast majority, will parse the RedeemScript as Script commands (<a href="#p2sh_redeemscript">p2sh RedeemScript</a>).</p>
</div>
<div id="p2sh_redeemscript" class="imageblock">
<div class="content">
<img src="./images/prbc_0820.png" alt="p2sh RedeemScript">
</div>
<div class="title">Figure 106. p2sh RedeemScript</div>
</div>
<div class="paragraph">
<p>These go into the Script column as commands (<a href="#p2sh_step_4">p2sh step 4</a>).</p>
</div>
<div id="p2sh_step_4" class="imageblock">
<div class="content">
<img src="./images/prbc_0821.png" alt="p2sh step 4">
</div>
<div class="title">Figure 107. p2sh step 4</div>
</div>
<div class="paragraph">
<p><code>OP_2</code> pushes a 2 to the stack, the pubkeys are also pushed, and a final <code>OP_2</code> pushes another 2 to the stack (<a href="#p2sh_step_5">p2sh step 5</a>).</p>
</div>
<div id="p2sh_step_5" class="imageblock">
<div class="content">
<img src="./images/prbc_0822.png" alt="p2sh step 5">
</div>
<div class="title">Figure 108. p2sh step 5</div>
</div>
<div class="paragraph">
<p><code>OP_CHECKMULTISIG</code> consumes <em>m</em> + <em>n</em> + 3 elements, which is the entire stack, and we end the same way we did for bare multisig (<a href="#p2sh_end_for_post_bip_0016_software">p2sh end for post-BIP0016 software</a>).</p>
</div>
<div id="p2sh_end_for_post_bip_0016_software" class="imageblock">
<div class="content">
<img src="./images/prbc_0823.png" alt="p2sh End">
</div>
<div class="title">Figure 109. p2sh end for post-BIP0016 software</div>
</div>
<div class="paragraph">
<p>The RedeemScript substitution is a bit hacky, and there&#8217;s special-cased code in Bitcoin software to handle this.
Why wasn&#8217;t something a lot less hacky and more intuitive chosen?
BIP0012 was a competing proposal at the time that used <code>OP_EVAL</code> and was considered more elegant.
A ScriptPubKey like <a href="#op_eval_would_have_been_an_command_which_adds_additional_commands_based_on_the_top_element">OP_EVAL would have been a command that adds additional commands based on the top element</a> would have worked with BIP0012.</p>
</div>
<div id="op_eval_would_have_been_an_command_which_adds_additional_commands_based_on_the_top_element" class="imageblock">
<div class="content">
<img src="./images/prbc_0824.png" alt="`OP_EVAL`">
</div>
<div class="title">Figure 110. OP_EVAL would have been a command that adds additional commands based on the top element</div>
</div>
<div class="paragraph">
<p><code>OP_EVAL</code> would have consumed the top element of the stack and interpreted that as Script commands to be put into the Script column.</p>
</div>
<div class="paragraph">
<p>Unfortunately, this more elegant solution comes with an unwanted side effect, namely Turing completeness.
Turing completeness is undesirable as it makes the security of a smart contract much harder to guarantee (see <a href="#chapter_script">Script</a>).
Thus, the more hacky but more secure option of special-casing was chosen in BIP0016.
BIP0016 (or p2sh) was implemented in 2011 and continues to be a part of the network today.</p>
</div>
</div>
<div class="sect2">
<h3 id="_coding_p2sh">Coding p2sh</h3>
<div class="paragraph">
<p>The special pattern of RedeemScript, <code>OP_HASH160</code>, hash160, and <code>OP_EQUAL</code> needs handling.
The <code>evaluate</code> method in <em>script.py</em> is where we handle the special case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Script:
...
    def evaluate(self, z):
...
        while len(commands) &gt; 0:
            command = commands.pop(0)
            if type(command) == int:
...
            else:
                stack.append(cmd)
                if len(cmds) == 3 and cmds[0] == 0xa9 \
                    and type(cmds[1]) == bytes and len(cmds[1]) == 20 \
                    and cmds[2] == 0x87:  # <b class="conum">(1)</b>
                    cmds.pop()  # <b class="conum">(2)</b>
                    h160 = cmds.pop()
                    cmds.pop()
                    if not op_hash160(stack):  # <b class="conum">(3)</b>
                        return False
                    stack.append(h160)
                    if not op_equal(stack):
                        return False
                    if not op_verify(stack):  # <b class="conum">(4)</b>
                        LOGGER.info('bad p2sh h160')
                        return False
                    redeem_script = encode_varint(len(cmd)) + cmd  # <b class="conum">(5)</b>
                    stream = BytesIO(redeem_script)
                    cmds.extend(Script.parse(stream).cmds)  # <b class="conum">(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>0xa9</code> is <code>OP_HASH160</code>, <code>0x87</code> is <code>OP_EQUAL</code>.
We&#8217;re checking that the next three commands conform to the BIP0016 special pattern.</p>
</li>
<li>
<p>We know that this is <code>OP_HASH160</code>, so we just pop it off.
Similarly, we know the next command is the 20-byte hash value and the third command is <code>OP_EQUAL</code>, which is what we tested for in the <code>if</code> statement above it.</p>
</li>
<li>
<p>We run the <code>OP_HASH160</code>, 20-byte hash push to the stack, and <code>OP_EQUAL</code> as normal.</p>
</li>
<li>
<p>There should be a 1 remaining, which is what <code>op_verify</code> checks for (<code>OP_VERIFY</code> consumes one element and does not put anything back).</p>
</li>
<li>
<p>Because we want to parse the RedeemScript, we need to prepend the length.</p>
</li>
<li>
<p>We extend the command set with the parsed commands from the RedeemScript.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_more_complicated_scripts">More Complicated Scripts</h4>
<div class="paragraph">
<p>The nice thing about p2sh is that the RedeemScript can be as long as the largest single element from <code>OP_PUSHDATA2</code>, which is 520 bytes.
Multisig is just one possibility.
You can have scripts that define more complicated logic, like "2 of 3 of these keys or 5 of 7 of these other keys."
The main feature of p2sh is that it&#8217;s flexible and at the same time reduces the UTXO set size by pushing the burden of storing part of the script back to the user.</p>
</div>
<div class="paragraph">
<p>In <a href="#chapter_segwit">Segwit</a>, p2sh is also used to make Segwit backward compatible.</p>
</div>
</div>
<div class="sect3">
<h4 id="_addresses">Addresses</h4>
<div class="paragraph">
<p>To compute p2sh addresses, we use a process similar to how we compute p2pkh addresses.
The hash160 is prepended with a prefix byte and appended with a checksum.</p>
</div>
<div class="paragraph">
<p>Mainnet p2sh uses the <code>0x05</code> byte, which causes addresses to start with a <code>3</code> in Base58, while testnet p2sh uses the <code>0xc4</code> byte to cause addresses to start with a <code>2</code>.
We can calculate the address using the <code>encode_base58_checksum</code> function from <em>helper.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from helper import encode_base58_checksum
&gt;&gt;&gt; h160 = bytes.fromhex('74d691da1574e6b3c192ecfb52cc8984ee7b6c56')
&gt;&gt;&gt; print(encode_base58_checksum(b'\x05' + h160))
3CLoMMyuoDQTPRD3XYZtCvgvkadrAdvdXh</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_8">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>h160_to_p2pkh_address</code> function that converts a 20-byte hash160 into a p2pkh address.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_8">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>h160_to_p2sh_address</code> function that converts a 20-byte hash160 into a p2sh address.</p>
</div>
</div>
<div class="sect3">
<h4 id="_p2sh_signature_verification">p2sh Signature Verification</h4>
<div class="paragraph">
<p>As with p2pkh, one of the tricky aspects of p2sh is verifying the signatures. p2sh signature verification is different from the p2pkh process covered in <a href="#chapter_tx">Transaction Creation and Validation</a>.</p>
</div>
<div class="paragraph">
<p>Unlike with p2pkh, where there&#8217;s only one signature and one public key, we have some number of pubkeys (in SEC format in the RedeemScript) and some equal or smaller number of signatures (in DER format in the ScriptSig).
Thankfully, the signatures have to be in the same order as the pubkeys or the signatures are not considered valid.</p>
</div>
<div class="paragraph">
<p>Once we have a particular signature and public key, we only need the signature hash, or <em>z</em>, to figure out whether the signature is valid (<a href="#validation_of_p2sh_inputs">Validation of p2sh inputs</a>).</p>
</div>
<div id="validation_of_p2sh_inputs" class="imageblock">
<div class="content">
<img src="./images/prbc_0825.png" alt="Validation Start">
</div>
<div class="title">Figure 111. Validation of p2sh inputs</div>
</div>
<div class="paragraph">
<p>As with p2pkh, finding the signature hash is the most difficult part of the p2sh signature validation process. We&#8217;ll now proceed to cover this in detail.</p>
</div>
<div class="sect4">
<h5 id="_step_1_empty_all_the_scriptsigs_2">Step 1: Empty all the ScriptSigs</h5>
<div class="paragraph">
<p>The first step is to empty all the ScriptSigs when checking the signature (<a href="#empty_each_inputs_scriptsig">Empty each input&#8217;s ScriptSig</a>).
The same procedure is used for creating the signature.</p>
</div>
<div id="empty_each_inputs_scriptsig" class="imageblock">
<div class="content">
<img src="./images/prbc_0826.png" alt="Validation Step 1">
</div>
<div class="title">Figure 112. Empty each input&#8217;s ScriptSig</div>
</div>
</div>
<div class="sect4">
<h5 id="_step_2_replace_the_scriptsig_of_the_p2sh_input_being_signed_with_the_redeemscript">Step 2: Replace the ScriptSig of the p2sh input being signed with the RedeemScript</h5>
<div class="paragraph">
<p>Each p2sh input has a RedeemScript.
We take the RedeemScript and put that in place of the empty ScriptSig (<a href="#replace_the_scriptsig_of_the_input_were_checking_with_the_redeemscript">Replace the ScriptSig of the input we&#8217;re checking with the RedeemScript</a>).
This is different from p2pkh in that it&#8217;s not the ScriptPubKey.</p>
</div>
<div id="replace_the_scriptsig_of_the_input_were_checking_with_the_redeemscript" class="imageblock">
<div class="content">
<img src="./images/prbc_0827.png" alt="Validation Step 2">
</div>
<div class="title">Figure 113. Replace the ScriptSig of the input we&#8217;re checking with the RedeemScript</div>
</div>
</div>
<div class="sect4">
<h5 id="_step_3_append_the_hash_type_2">Step 3: Append the hash type</h5>
<div class="paragraph">
<p>Last, we add a 4-byte hash type to the end.
This is the same as in p2pkh. The integer corresponding to <code>SIGHASH_ALL</code> is 1 and this has to be encoded in little-endian over 4 bytes, which makes the transaction look like <a href="#append_the_hash_type_sighash_all_or_the_blue_part_at_the_end">Append the hash type (SIGHASH_ALL), 01000000</a>.</p>
</div>
<div id="append_the_hash_type_sighash_all_or_the_blue_part_at_the_end" class="imageblock">
<div class="content">
<img src="./images/prbc_0828.png" alt="Validation Step 3">
</div>
<div class="title">Figure 114. Append the hash type (SIGHASH_ALL), 01000000</div>
</div>
<div class="paragraph">
<p>The hash256 of this interpreted as a big-endian integer is our <em>z</em>.
The code for getting our signature hash looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; modified_tx = bytes.fromhex('0100000001868278ed6ddfb6c1ed3ad5f8181eb0c7a38\
5aa0836f01d5e4789e6bd304d87221a000000475221022626e955ea6ea6d98850c994f9107b036\
b1334f18ca8830bfff1295d21cfdb702103b287eaf122eea69030a0e9feed096bed8045c8b98be\
c453e1ffac7fbdbd4bb7152aeffffffff04d3b11400000000001976a914904a49878c0adfc3aa0\
5de7afad2cc15f483a56a88ac7f400900000000001976a914418327e3f3dda4cf5b9089325a4b9\
5abdfa0334088ac722c0c00000000001976a914ba35042cfe9fc66fd35ac2224eebdafd1028ad2\
788acdc4ace020000000017a91474d691da1574e6b3c192ecfb52cc8984ee7b6c5687000000000\
1000000')
&gt;&gt;&gt; s256 = hash256(modified_tx)
&gt;&gt;&gt; z = int.from_bytes(s256, 'big')
&gt;&gt;&gt; print(hex(z))
0xe71bfa115715d6fd33796948126f40a8cdd39f187e4afb03896795189fe1423c</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have our <em>z</em>, we can grab the SEC public key and DER signature from the ScriptSig and RedeemScript  (<a href="#der_and_sec_within_the_p2sh_scriptsig_and_redeemscript">DER signature and SEC pubkey within the p2sh ScriptSig and RedeemScript</a>).</p>
</div>
<div id="der_and_sec_within_the_p2sh_scriptsig_and_redeemscript" class="imageblock">
<div class="content">
<img src="./images/prbc_0829.png" alt="DER and SEC">
</div>
<div class="title">Figure 115. DER signature and SEC pubkey within the p2sh ScriptSig and RedeemScript</div>
</div>
<div class="paragraph">
<p>We can now validate the signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import S256Point, Signature
&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; modified_tx = bytes.fromhex('0100000001868278ed6ddfb6c1ed3ad5f8181eb0c7a38\
5aa0836f01d5e4789e6bd304d87221a000000475221022626e955ea6ea6d98850c994f9107b036\
b1334f18ca8830bfff1295d21cfdb702103b287eaf122eea69030a0e9feed096bed8045c8b98be\
c453e1ffac7fbdbd4bb7152aeffffffff04d3b11400000000001976a914904a49878c0adfc3aa0\
5de7afad2cc15f483a56a88ac7f400900000000001976a914418327e3f3dda4cf5b9089325a4b9\
5abdfa0334088ac722c0c00000000001976a914ba35042cfe9fc66fd35ac2224eebdafd1028ad2\
788acdc4ace020000000017a91474d691da1574e6b3c192ecfb52cc8984ee7b6c5687000000000\
1000000')
&gt;&gt;&gt; h256 = hash256(modified_tx)
&gt;&gt;&gt; z = int.from_bytes(h256, 'big')  # <b class="conum">(1)</b>
&gt;&gt;&gt; sec = bytes.fromhex('022626e955ea6ea6d98850c994f9107b036b1334f18ca8830bfff\
1295d21cfdb70')
&gt;&gt;&gt; der = bytes.fromhex('3045022100dc92655fe37036f47756db8102e0d7d5e28b3beb83a\
8fef4f5dc0559bddfb94e02205a36d4e4e6c7fcd16658c50783e00c341609977aed3ad00937bf4\
ee942a89937')
&gt;&gt;&gt; point = S256Point.parse(sec)
&gt;&gt;&gt; sig = Signature.parse(der)
&gt;&gt;&gt; print(point.verify(z, sig))
True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>z</code> is from the code on page 185.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We&#8217;ve verified one of the two signatures that are required to unlock this p2sh <span class="keep-together">multisig</span>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_8">Exercise 4</h4>
<div class="paragraph">
<p>Validate the second signature from the preceding transaction.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_7">Exercise 5</h4>
<div class="paragraph">
<p>Modify the <code>sig_hash</code> and <code>verify_input</code> methods to be able to verify p2sh <span class="keep-together">transactions</span>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_8">Conclusion</h3>
<div class="paragraph">
<p>In this chapter we learned how p2sh ScriptPubKeys are created and how they&#8217;re redeemed.
We&#8217;ve covered transactions for the last four chapters; we now turn to how they are grouped in blocks.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_blocks">Blocks</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>Transactions transfer bitcoins from one party to another and are unlocked, or authorized, by signatures.
This ensures that the sender authorized the transaction, but what if the sender sends the same coins to multiple people? The owner of a lockbox may try to spend the same output twice. This is called the <em>double-spending problem</em>.
Much like being given a check that has the possibility of bouncing, the receiver needs to be assured that the transaction is valid.</p>
</div>
<div class="paragraph">
<p>This is where a major innovation of Bitcoin comes in, with <em>blocks</em>.
Think of blocks as a way to order transactions.
If we order transactions, a double-spend can be prevented by making any later, conflicting transaction invalid.
This is the equivalent to accepting the earlier transaction as the valid one.</p>
</div>
<div class="paragraph">
<p>Implementing this rule would be easy (earliest transaction is valid, subsequent transactions that conflict are invalid) if we could order transactions one at a time.
Unfortunately, that would require nodes on the network to agree on which transaction is supposed to be next and would cause a lot of transmission overhead in coming to consensus.
We could also order large batches of transactions, maybe once per day, but that wouldn&#8217;t be very practical as transactions would settle only once per day and not have finality before then.</p>
</div>
<div class="paragraph">
<p>Bitcoin finds a middle ground between these extremes by settling every 10 minutes in batches of transactions.
These batches of transactions are what we call blocks.
In this chapter we&#8217;ll review how to parse blocks and how to check the proof-of-work.
We&#8217;ll start with a special transaction called the coinbase transaction, which is the first transaction of every block.</p>
</div>
<div class="sect2">
<h3 id="_coinbase_transactions">Coinbase Transactions</h3>
<div class="paragraph">
<p>Coinbase transactions have nothing to do with the US company of the same name.
Coinbase is the required first transaction of every block and is the only transaction allowed to bring bitcoins into existence.
The coinbase transaction&#8217;s outputs are kept by whomever the mining entity designates and usually include all the transaction fees of the other transactions in the block as well as something called the <em>block reward</em>.</p>
</div>
<div class="paragraph">
<p>The coinbase transaction is what makes it worthwhile for a miner to mine.
<a href="#coinbase_transaction">Coinbase transaction</a> shows what a coinbase transaction looks like.</p>
</div>
<div id="coinbase_transaction" class="imageblock">
<div class="content">
<img src="./images/prbc_0901.png" alt="Coinbase transaction">
</div>
<div class="title">Figure 116. Coinbase transaction</div>
</div>
<div class="paragraph">
<p>The transaction structure is no different from that of other transactions on the Bitcoin network, with a few exceptions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Coinbase transactions must have exactly one input.</p>
</li>
<li>
<p>The one input must have a previous transaction of 32 bytes of <code>00</code>.</p>
</li>
<li>
<p>The one input must have a previous index of <code>ffffffff</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>These three conditions determine whether a transaction is a coinbase transaction or not.</p>
</div>
<div class="sect3">
<h4 id="_exercise_1_9">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>is_coinbase</code> method of the <code>Tx</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_scriptsig">ScriptSig</h4>
<div class="paragraph">
<p>The coinbase transaction has no previous output that it&#8217;s spending, so the input is not unlocking anything.
So what&#8217;s in the ScriptSig?</p>
</div>
<div class="paragraph">
<p>The ScriptSig of the coinbase transaction is set by whoever mined the transaction.
The main restriction is that the ScriptSig has to be at least 2 bytes and no longer than 100 bytes.
Other than those restrictions and BIP0034 (described in the next section), the ScriptSig can be anything the miner wants as long as the evaluation of the ScriptSig by itself, with no corresponding ScriptPubKey, is valid.
Here is the ScriptSig for the genesis block&#8217;s coinbase transaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c
6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73</code></pre>
</div>
</div>
<div class="paragraph">
<p>This ScriptSig was composed by Satoshi and contains a message that we can read:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from script import Script
&gt;&gt;&gt; stream = BytesIO(bytes.fromhex('4d04ffff001d0104455468652054696d6573203033\
2f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64\
206261696c6f757420666f722062616e6b73'))
&gt;&gt;&gt; s = Script.parse(stream)
&gt;&gt;&gt; print(s.cmds[2])
b'The Times 03/Jan/2009 Chancellor on brink of second bailout for banks'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This was the headline from the <em>Times</em> of London on January 3, 2009.
This proves that the genesis block was created some time <em>at or after</em> that date, and not <em>before</em>.
Other coinbase transactions' ScriptSigs contain similarly arbitrary data.</p>
</div>
</div>
<div class="sect3">
<h4 id="BIP0034">BIP0034</h4>
<div class="paragraph">
<p>BIP0034 regulates the first element of the ScriptSig of coinbase transactions.
This was due to a network problem where miners were using the <em>same</em> coinbase transaction for different blocks.</p>
</div>
<div class="paragraph">
<p>The coinbase transaction being the same byte-wise means that the transaction IDs are also the same, since the hash256 of the transaction is deterministic.
To prevent transaction ID duplication, Gavin Andresen authored BIP0034, which is a soft-fork rule that adds the height of the block being mined into the first element of the coinbase ScriptSig.</p>
</div>
<div class="paragraph">
<p>The height is interpreted as a little-endian integer and must equal the height of the block (that is, the number of blocks since the genesis block).
Thus, a coinbase transaction cannot be byte-wise the same across different blocks, since the block height will differ.
Here&#8217;s how we can parse the height from the coinbase transaction in <a href="#coinbase_transaction">Coinbase transaction</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from script import Script
&gt;&gt;&gt; from helper import little_endian_to_int
&gt;&gt;&gt; stream = BytesIO(bytes.fromhex('5e03d71b07254d696e656420627920416e74506f6f\
6c20626a31312f4542312f4144362f43205914293101fabe6d6d678e2c8c34afc36896e7d94028\
24ed38e856676ee94bfdb0c6c4bcd8b2e5666a0400000000000000c7270000a5e00e00'))
&gt;&gt;&gt; script_sig = Script.parse(stream)
&gt;&gt;&gt; print(little_endian_to_int(script_sig.cmds[0]))
465879</code></pre>
</div>
</div>
<div class="paragraph">
<p>A coinbase transaction reveals the block it was in!
Coinbase transactions in different blocks are required to have different ScriptSigs and thus different transaction IDs.
This rule continues to be needed as it would otherwise allow the duplicate coinbase transaction IDs across multiple blocks.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_9">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>coinbase_height</code> method for the <code>Tx</code> class.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_block_headers">Block Headers</h3>
<div class="paragraph">
<p>Blocks are batches of transactions, and the block header is metadata about the transactions included in a block.
The block header as shown in <a href="#parsed_block">Parsed block</a> consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Version</p>
</li>
<li>
<p>Previous block</p>
</li>
<li>
<p>Merkle root</p>
</li>
<li>
<p>Timestamp</p>
</li>
<li>
<p>Bits</p>
</li>
<li>
<p>Nonce</p>
</li>
</ul>
</div>
<div id="parsed_block" class="imageblock">
<div class="content">
<img src="./images/prbc_0902.png" alt="Block parsing">
</div>
<div class="title">Figure 117. Parsed block</div>
</div>
<div class="paragraph">
<p>The block header is the metadata for the block.
Unlike in transactions, each field in a block header is of a fixed length, as listed in <a href="#parsed_block">Parsed block</a>;
a block header takes up exactly 80 bytes.
As of this writing there are roughly 550,000 blocks, or ~45 MB in block headers.
The entire blockchain, on the other hand, is roughly 200 GB, so the headers are roughly .023% of the size.
The fact that headers are so much smaller is an important feature, as we&#8217;ll see when we look at simplified payment verification in <a href="#chapter_spv">Simplified Payment Verification</a>.</p>
</div>
<div class="paragraph">
<p>Like the transaction ID, the block ID is the hex representation of the hash256 of the header interpreted in little-endian.
The block ID is interesting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; block_hash = hash256(bytes.fromhex('020000208ec39428b17323fa0ddec8e887b4a7\
c53b8c0a0a220cfd0000000000000000005b0750fce0a889502d40508d39576821155e9c9e3f5c\
3157f961db38fd8b25be1e77a759e93c0118a4ffd71d'))[::-1]
&gt;&gt;&gt; block_id = block_hash.hex()
&gt;&gt;&gt; print(block_id)
0000000000000000007e9e4c586439b0cdbe13b1370bdd9435d76a644d047523</pre>
</div>
</div>
<div class="paragraph">
<p>This ID is what gets put into <code>prev_block</code> for a block building on top of this one.
For now, notice that the ID starts with a lot of zeros.
We&#8217;ll come back to this in <a href="#proof_f_work">Proof-of-Work</a>, after we take a closer look at the fields in the block header.</p>
</div>
<div class="paragraph">
<p>We can start coding a <code>Block</code> class based on what we already know:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:

    def __init__(self, version, prev_block, merkle_root, timestamp, bits, nonce):
        self.version = version
        self.prev_block = prev_block
        self.merkle_root = merkle_root
        self.timestamp = timestamp
        self.bits = bits
        self.nonce = nonce</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_9">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>parse</code> method for <code>Block</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_9">Exercise 4</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>Block</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_8">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code>hash</code> method for <code>Block</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_version_2">Version</h4>
<div class="paragraph">
<p><em>Version</em> in normal software refers to a particular set of features.
For a block, this is similar, in the sense that the version field reflects the capabilities of the software that produced the block.
In the past this was used as a way to indicate a single feature that was ready to be deployed by the block&#8217;s miner.
Version 2 meant that the software was ready for BIP0034, which introduced the coinbase transaction block height feature mentioned earlier in this chapter.
Version 3 meant that the software was ready for BIP0066, which enforced strict DER encoding.
Version 4 meant that the software was ready for BIP0065, which specified <code>OP_CHECKLOCKTIMEVERIFY</code>.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the incremental increase in version number meant that only one feature was signaled on the network at a time.
To alleviate this, the developers came up with BIP0009, which allows up to 29 different features to be signaled at the same time.</p>
</div>
<div class="paragraph">
<p>The way BIP0009 works is by fixing the first 3 bits of the 4-byte (32-bit) header to be <code>001</code> to indicate that the miner is using BIP0009.
The first 3 bits have to be <code>001</code>, as that forces older clients to interpret the version field as a number greater than or equal to 4, which was the last version number that was used pre-BIP0009.</p>
</div>
<div class="paragraph">
<p>This means that in hexadecimal, the first character will always be 2 or 3.
The other 29 bits can be assigned to different soft-fork features for which miners can signal readiness.
For example, bit 0 (the rightmost bit) can be flipped to 1 to signal readiness for one soft fork, bit 1 (the second bit from the right) can be flipped to 1 to signal readiness for another, bit 2 (the third bit from the right) can be flipped to 1 to signal readiness for another, and so on.</p>
</div>
<div class="paragraph">
<p>BIP0009 requires that 95% of blocks signal readiness in a given 2,016-block epoch (the period for a difficulty adjustment; more on that later in this chapter) before the soft fork feature gets activated on the network.
Soft forks that used BIP0009 as of this writing have been BIP0068/BIP0112/BIP0113 (<code>OP_CHECKSEQUENCEVERIFY</code> and related changes) and BIP0141 (Segwit).
These BIPs used bits 0 and 1 for signaling, respectively.
BIP0091 used something like BIP0009 but with an 80% threshold and a smaller block period, so it wasn&#8217;t strictly using BIP0009.
Bit 4 was used to signal BIP0091.</p>
</div>
<div class="paragraph">
<p>Checking for these features is relatively straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from block import Block
&gt;&gt;&gt; b = Block.parse(BytesIO(bytes.fromhex('020000208ec39428b17323fa0ddec8e887b\
4a7c53b8c0a0a220cfd0000000000000000005b0750fce0a889502d40508d39576821155e9c9e3\
f5c3157f961db38fd8b25be1e77a759e93c0118a4ffd71d')))
&gt;&gt;&gt; print('BIP9: {}'.format(b.version &gt;&gt; 29 == 0b001))  # <b class="conum">(1)</b>
BIP9: True
&gt;&gt;&gt; print('BIP91: {}'.format(b.version &gt;&gt; 4 &amp; 1 == 1))  # <b class="conum">(2)</b>
BIP91: False
&gt;&gt;&gt; print('BIP141: {}'.format(b.version &gt;&gt; 1 &amp; 1 == 1))  # <b class="conum">(3)</b>
BIP141: True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>&gt;&gt;</code> operator is the right bit-shift operator, which throws away the rightmost 29 bits, leaving just the top 3 bits.
The <code>0b001</code> is a way of writing a number in binary in Python.</p>
</li>
<li>
<p>The <code>&amp;</code> operator is the "bitwise and" operator.
In our case, we right-shift by 4 bits first and then check that the rightmost bit is 1.</p>
</li>
<li>
<p>We shift 1 to the right because BIP0141 was assigned to bit 1.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_6">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>bip9</code> method for the <code>Block</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_5">Exercise 7</h4>
<div class="paragraph">
<p>Write the <code>bip91</code> method for the <code>Block</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_8_3">Exercise 8</h4>
<div class="paragraph">
<p>Write the <code>bip141</code> method for the <code>Block</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_previous_block">Previous Block</h4>
<div class="paragraph">
<p>All blocks have to point to a previous block.
This is why the data structure is called a <em>blockchain</em>.
Blocks link back all the way to the very first block, or the <em>genesis block</em>.
The previous block field ends in a bunch of <code>00</code> bytes, which we will discuss more later in this chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_merkle_root">Merkle Root</h4>
<div class="paragraph">
<p>The Merkle root encodes all the ordered transactions in a 32-byte hash.
We will discuss how this is important for simplified payment verification (SPV) clients and how they can use the Merkle root along with data from the server to get a proof of inclusion in <a href="#chapter_spv">Simplified Payment Verification</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_timestamp">Timestamp</h4>
<div class="paragraph">
<p>The timestamp is a Unix-style timestamp taking up 4 bytes.
Unix timestamps are the number of seconds since January 1, 1970.
This timestamp is used in two places: for validating timestamp-based locktimes on transactions included in the block and for calculating a new bits/target/difficulty every 2,016 blocks.
The locktimes were at one point used directly for transactions within a block, but BIP0113 changed the behavior to not use the current block&#8217;s timestamp directly, but the median time past (MTP) of the past 11 blocks.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Will Bitcoin Overflow on the Timestamp?</div>
<div class="paragraph">
<p>Bitcoin&#8217;s timestamp field in the block header is 4 bytes, or 32 bits.
This means that once the Unix timestamp exceeds 2<sup>32</sup> – 1, there is no room to go further.
2<sup>32</sup> seconds is roughly 136 years, which means that this field will have no more room in 2106 (136 years after 1970).</p>
</div>
<div class="paragraph">
<p>Many people mistakenly believe that we only have until 68 years after 1970, or 2038, but that&#8217;s only when the field is a signed integer (2<sup>31</sup> seconds is 68 years), so we get the benefit of that extra bit, giving us until 2106.</p>
</div>
<div class="paragraph">
<p>In 2106, the block header will need some sort of fork as the timestamp in the block header will no longer continuously increase.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_bits">Bits</h4>
<div class="paragraph">
<p>Bits is a field that encodes the proof-of-work necessary in this block.
This will be discussed more in the next section.</p>
</div>
</div>
<div class="sect3">
<h4 id="_nonce">Nonce</h4>
<div class="paragraph">
<p>Nonce stands for "number used only once," or <em>n-once</em>.
This number is what is changed by miners when looking for proof-of-work.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="proof_f_work">Proof-of-Work</h3>
<div class="paragraph">
<p>Proof-of-work is what secures Bitcoin and, at a deep level, allows the decentralized mining of Bitcoin.
Finding a proof-of-work gives a miner the right to put the attached block into the blockchain.
As proof-of-work is very rare, this is not an easy task.
But because proof-of-work is objective and easy to verify, anyone can be a miner if they so choose.</p>
</div>
<div class="paragraph">
<p>Proof-of-work is called "mining" for a very good reason.
Like with physical mining, there is something that miners are searching for.
A typical gold mining operation processes 45 tons of dirt and rock before accumulating 1 oz of gold.
This is because gold is very rare.
However, once gold is found, it&#8217;s very easy to verify that the gold is real.
There are chemical tests, touchstones, and many other ways to tell relatively cheaply whether the thing found is gold.</p>
</div>
<div class="paragraph">
<p>Similarly, proof-of-work is a number that provides a very rare result.
To find a proof-of-work, the miners on the Bitcoin network have to churn through the numerical equivalent of dirt and rock.
Like with gold, verifying proof-of-work is much cheaper than actually finding it.</p>
</div>
<div class="paragraph">
<p>So what is proof-of-work?
Let&#8217;s look at the hash256 of the block header we saw before to find out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>020000208ec39428b17323fa0ddec8e887b4a7c53b8c0a0a220cfd000000000000000000
5b0750fce0a889502d40508d39576821155e9c9e3f5c3157f961db38fd8b25be1e77a759
e93c0118a4ffd71d</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; block_id = hash256(bytes.fromhex('020000208ec39428b17323fa0ddec8e887b4a7c5\
3b8c0a0a220cfd0000000000000000005b0750fce0a889502d40508d39576821155e9c9e3f5c31\
57f961db38fd8b25be1e77a759e93c0118a4ffd71d'))[::-1]
&gt;&gt;&gt; print('{}'.format(block_id.hex()).zfill(64))  # <b class="conum">(1)</b>
0000000000000000007e9e4c586439b0cdbe13b1370bdd9435d76a644d047523</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are purposefully printing this number as 64 hexadecimal digits to show how small it is in 256-bit terms.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>sha256 is known to generate uniformly distributed values.
Given this, we can treat two rounds of sha256, or hash256, as a random number.
The probability of any random 256-bit number being this small is tiny.
The probability of the first bit in a 256-bit number being 0 is 0.5, the first two bits being 00, 0.25, the first three bits being 000, 0.125, and so on.
Note that each 0 in the hexadecimal just shown represents four 0- bits.
In this case, we have the first 73 bits being 0, which has a probability of 0.5<sup>73</sup>, or about 1 in 10<sup>22</sup>.
This is a really tiny probability.
On average, 10<sup>22</sup> (or 10 trillion trillion) random 256-bit numbers have to be generated before finding one this small.
In other words, we need to calculate 10<sup>22</sup> in hashes on average to find one this small.
Getting back to the analogy, the process of finding proof-of-work requires us to process around 10<sup>22</sup> numerical bits of dirt and rock to find our numerical gold nugget.</p>
</div>
<div class="sect3">
<h4 id="_how_a_miner_generates_new_hashes">How a Miner Generates New Hashes</h4>
<div class="paragraph">
<p>Where does the miner get new numerical dirt to process to see if it satisfies proof-of-work?
This is where the nonce field comes in.
The miners can change the nonce field at will to change the hash of the block header.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the 4 bytes or 32 bits of the nonce field (or 2<sup>32</sup> possible nonces that a miner can try) is insufficient for the required proof-of-work.
Modern ASIC equipment can calculate way more than 2<sup>32</sup> different hashes per second.
The AntMiner S9, for example, calculates 12 terahashes per second (Th/s).
That is approximately 2<sup>43</sup> hashes per second, which means that the entire nonce space can be consumed in just 0.0003 seconds.</p>
</div>
<div class="paragraph">
<p>What miners can do when the nonce field is exhausted is change the coinbase transaction, which then changes the Merkle root, giving miners a fresh nonce space each time.
The other option is to roll the version field or use overt ASICBOOST.
The mechanics of how the Merkle root changes whenever any transaction in the block changes will be discussed in <a href="#chapter_spv">Simplified Payment Verification</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_target">The Target</h4>
<div class="paragraph">
<p>Proof-of-work is the requirement that the hash of every block header in Bitcoin must be below a certain target.
The <em>target</em> is a 256-bit number that is computed directly from the bits field (in our example, e93c0118).
The target is very small compared to an average 256-bit number.</p>
</div>
<div class="paragraph">
<p>The bits field is actually two different numbers.
The first is the exponent, which is the last byte.
The second is the coefficient, which is the other three bytes in little-endian.
The formula for calculating the target from these two numbers is:</p>
</div>
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>target</mi>
<mo>=</mo>
<mi>coefficient</mi> <mo>&#215;</mo> <msup><mn>256</mn><mrow><mi>exponent</mi> <mo>–</mo> <mn>3</mn></mrow></msup>
</math>
</div>
<div class="paragraph">
<p>This is how we calculate the target given the bits field in Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from helper import little_endian_to_int
&gt;&gt;&gt; bits = bytes.fromhex('e93c0118')
&gt;&gt;&gt; exponent = bits[-1]
&gt;&gt;&gt; coefficient = little_endian_to_int(bits[:-1])
&gt;&gt;&gt; target = coefficient * 256**(exponent - 3)
&gt;&gt;&gt; print('{:x}'.format(target).zfill(64))  # <b class="conum">(1)</b>
0000000000000000013ce9000000000000000000000000000000000000000000</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are purposefully printing this number as 64 hexadecimal digits to show how small the number is in 256-bit terms.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A valid proof-of-work is a hash of the block header that, when interpreted as a little-endian integer, is below the target number.
Proof-of-work hashes are exceedingly rare, and the process of mining is the process of finding one of these hashes.
To find a single proof-of-work with the preceding target, the network as a whole must calculate 3.8 &#215; 10<sup>21</sup> hashes, which, when this block was found, could be done roughly every 10 minutes.
To give this number some context, the best GPU mining card in the world would need to run for 50,000 years on average to find a single proof-of-work below this target.</p>
</div>
<div class="paragraph">
<p>We can check that this block header&#8217;s hash satisfies the proof-of-work as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import little_endian_to_int
&gt;&gt;&gt; proof = little_endian_to_int(hash256(bytes.fromhex('020000208ec39428b17323\
fa0ddec8e887b4a7c53b8c0a0a220cfd0000000000000000005b0750fce0a889502d40508d3957\
6821155e9c9e3f5c3157f961db38fd8b25be1e77a759e93c0118a4ffd71d')))
&gt;&gt;&gt; print(proof &lt; target)  # <b class="conum">(1)</b>
True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>target</code> is calculated above.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can see that the proof-of-work is lower by lining up the numbers in 64 hex <span class="keep-together">characters</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>TG: 0000000000000000013ce9000000000000000000000000000000000000000000

ID: 0000000000000000007e9e4c586439b0cdbe13b1370bdd9435d76a644d047523</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_9_3">Exercise 9</h4>
<div class="paragraph">
<p>Write the <code>bits_to_target</code> function in <em>helper.py</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_difficulty">Difficulty</h4>
<div class="paragraph">
<p>Targets are hard for human beings to comprehend. The target is the number that the hash must be below, but as humans, it&#8217;s not easy to see the difference between a 180-bit number and a 190-bit number.
The first is a thousand times smaller, but from looking at targets, such large numbers are not easy to contextualize.</p>
</div>
<div class="paragraph">
<p>To make different targets easier to compare, the concept of <em>difficulty</em> was born.
The trick is that difficulty is inversely proportional to the target, to make comparisons easier.
The specific formula is:</p>
</div>
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>difficulty</mi>
<mo>=</mo>
<mi>0xffff</mi> <mo>&#215;</mo> <msup><mn>256</mn> <mrow><mi>0x1d</mi> <mo>–</mo> <mn>3</mn></mrow></msup> <mo>&#8725;</mo> <mi>target</mi>
</math>
</div>
<div class="paragraph">
<p>The code looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import little_endian_to_int
&gt;&gt;&gt; bits = bytes.fromhex('e93c0118')
&gt;&gt;&gt; exponent = bits[-1]
&gt;&gt;&gt; coefficient = little_endian_to_int(bits[:-1])
&gt;&gt;&gt; target = coefficient*256**(exponent-3)
&gt;&gt;&gt; difficulty = 0xffff * 256**(0x1d-3) / target
&gt;&gt;&gt; print(difficulty)
888171856257.3206</code></pre>
</div>
</div>
<div class="paragraph">
<p>The difficulty of Bitcoin at the genesis block was 1.
This gives us context for how difficult mainnet currently is.
The difficulty can be thought of as how much more difficult mining is now than it was at the start.
The mining difficulty in the preceding code is roughly 888 billion times harder than when Bitcoin started.</p>
</div>
<div class="paragraph">
<p>Difficulty is often shown in block explorers and Bitcoin price charting services, as it&#8217;s a much more intuitive way to understand the effort required to create a new block.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_10">Exercise 10</h4>
<div class="paragraph">
<p>Write the <code>difficulty</code> method for <code>Block</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_checking_that_the_proof_of_work_is_sufficient">Checking That the Proof-of-Work Is Sufficient</h4>
<div class="paragraph">
<p>We already learned that proof-of-work can be calculated by computing the hash256 of the block header and interpreting this as a little-endian integer.
If this number is lower than the target, we have a valid proof-of-work.
If not, the block is not valid as it doesn&#8217;t have proof-of-work.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_11">Exercise 11</h4>
<div class="paragraph">
<p>Write the <code>check_pow</code> method for <code>Block</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_difficulty_adjustment">Difficulty Adjustment</h4>
<div class="paragraph">
<p>In Bitcoin, each group of 2,016 blocks is called a <em>difficulty adjustment period</em>.
At the end of every difficulty adjustment period, the target is adjusted according to this <span class="keep-together">formula</span>:</p>
</div>
<ul class="simplelist">
<li><em>time_differential</em> = (block timestamp of last block in difficulty adjustment period) –
(block timestamp of first block in difficulty adjustment period)</li>
<li>&nbsp;</li>
<li><em>new_target</em> = <em>previous_target</em> * <em>time_differential</em> / (2 weeks)</li>
</ul>
<div class="paragraph">
<p>The <em>time_differential</em> is calculated so that if it&#8217;s greater than 8 weeks, 8 weeks is used, and if it&#8217;s less than 3.5 days, 3.5 days is used.
This way, the new target cannot change more than four times in either direction.
That is, the target will be reduced or increased by four times at the most.</p>
</div>
<div class="paragraph">
<p>If each block took on average 10 minutes to create, 2,016 blocks should take 20,160 minutes.
There are 1,440 minutes per day, which means that 2,016 blocks will take 20,160 / 1,440 = 14 days to create.
The effect of the difficulty adjustment is that block times are regressed toward the mean of 10 minutes per block.
This means that long-term, blocks will always go toward 10-minute blocks even if a lot of hashing power has entered or left the network.</p>
</div>
<div class="paragraph">
<p>The new bits calculation should be using the timestamp field of the last block of each of the current and previous difficulty adjustment periods.
Satoshi unfortunately had another off-by-one error here, as the timestamp differential calculation looks at the first and last blocks of the 2,016-block difficulty adjustment period instead.
The time differential is therefore the difference of blocks that are 2,015 blocks apart instead of 2,016 blocks apart.</p>
</div>
<div class="paragraph">
<p>We can code this formula like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from block import Block
&gt;&gt;&gt; from helper import TWO_WEEKS  # <b class="conum">(1)</b>
&gt;&gt;&gt; last_block = Block.parse(BytesIO(bytes.fromhex('00000020fdf740b0e49cf75bb3\
d5168fb3586f7613dcc5cd89675b0100000000000000002e37b144c0baced07eb7e7b64da916cd\
3121f2427005551aeb0ec6a6402ac7d7f0e4235954d801187f5da9f5')))
&gt;&gt;&gt; first_block = Block.parse(BytesIO(bytes.fromhex('000000201ecd89664fd205a37\
566e694269ed76e425803003628ab010000000000000000bfcade29d080d9aae8fd461254b0418\
05ae442749f2a40100440fc0e3d5868e55019345954d80118a1721b2e')))
&gt;&gt;&gt; time_differential = last_block.timestamp - first_block.timestamp
&gt;&gt;&gt; if time_differential &gt; TWO_WEEKS * 4:  # <b class="conum">(2)</b>
...     time_differential = TWO_WEEKS * 4
&gt;&gt;&gt; if time_differential &lt; TWO_WEEKS // 4:  # <b class="conum">(3)</b>
...     time_differential = TWO_WEEKS // 4
&gt;&gt;&gt; new_target = last_block.target() * time_differential // TWO_WEEKS
&gt;&gt;&gt; print('{:x}'.format(new_target).zfill(64))
0000000000000000007615000000000000000000000000000000000000000000</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Note that <code>TWO_WEEKS = 60*60*24*14</code> is the number of seconds in 2 weeks: 60 seconds &#xd7; 60 minutes &#xd7; 24 hours &#xd7; 14 days.</p>
</li>
<li>
<p>This makes sure that if it took more than 8 weeks to find the last 2,015 blocks, we don&#8217;t decrease the difficulty too much.</p>
</li>
<li>
<p>This makes sure that if it took less than 3.5 days to find the last 2,015 blocks, we don&#8217;t increase the difficulty too much.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that we only need the headers to calculate what the next block&#8217;s target should be.
Once we have the target, we can convert the target to bits.
The inverse operation looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def target_to_bits(target):
    '''Turns a target integer back into bits'''
    raw_bytes = target.to_bytes(32, 'big')
    raw_bytes = raw_bytes.lstrip(b'\x00')  # <b class="conum">(1)</b>
    if raw_bytes[0] &gt; 0x7f:  # <b class="conum">(2)</b>
        exponent = len(raw_bytes) + 1
        coefficient = b'\x00' + raw_bytes[:2]
    else:
        exponent = len(raw_bytes)  # <b class="conum">(3)</b>
        coefficient = raw_bytes[:3]  # <b class="conum">(4)</b>
    new_bits = coefficient[::-1] + bytes([exponent])  # <b class="conum">(5)</b>
    return new_bits</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get rid of all the leading zeros.</p>
</li>
<li>
<p>The bits format is a way to express really large numbers succinctly and can be used with both negative and positive numbers.
If the first bit in the coefficient is a 1, the bits field is interpreted as a negative number.
Since the target is always positive for us, we shift everything over by 1 byte if the first bit is 1.</p>
</li>
<li>
<p>The exponent is how long the number is in base 256.</p>
</li>
<li>
<p>The coefficient is the first three digits of the base 256 number.</p>
</li>
<li>
<p>The coefficient is in little-endian and the exponent goes last in the bits format.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the block doesn&#8217;t have the correct bits calculated using the difficulty adjustment formula, then we can safely reject that block.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_12">Exercise 12</h4>
<div class="paragraph">
<p>Calculate the new bits given the first and last blocks of this 2,016-block difficulty adjustment period:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Block 471744:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>000000203471101bbda3fe307664b3283a9ef0e97d9a38a7eacd88000000000000000000
10c8aba8479bbaa5e0848152fd3c2289ca50e1c3e58c9a4faaafbdf5803c5448ddb84559
7e8b0118e43a81d3</code></pre>
</div>
</div>
</li>
<li>
<p>Block 473759:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>02000020f1472d9db4b563c35f97c428ac903f23b7fc055d1cfc26000000000000000000
b3f449fcbe1bc4cfbcb8283a0d2c037f961a3fdf2b8bedc144973735eea707e126425859
7e8b0118e5f00474</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_13">Exercise 13</h4>
<div class="paragraph">
<p>Write the <code>calculate_new_bits</code> function in <em>helper.py</em>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_9">Conclusion</h3>
<div class="paragraph">
<p>We&#8217;ve learned how to calculate proof-of-work, how to calculate the new bits for a block after a difficulty adjustment period, and how to parse coinbase transactions.
We&#8217;ll now move on to networking in <a href="#chapter_networking">Networking</a> on our way to the block header field we haven&#8217;t covered, the Merkle root, in <a href="#chapter_spv">Simplified Payment Verification</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_networking">Networking</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>The peer-to-peer network that Bitcoin runs on is what gives it a lot of its robustness. More than 65,000 nodes are running on the network as of this writing and are communicating constantly.</p>
</div>
<div class="paragraph">
<p>The Bitcoin network is a broadcast network, or gossip network.
Every node is announcing different transactions, blocks, and peers that it knows about.
The protocol is rich and has a lot of features that have been added to it over the years.</p>
</div>
<div class="paragraph">
<p>One thing to note about the networking protocol is that it is not consensus-critical.
The same data can be sent from one node to another using some other protocol and the blockchain itself will not be affected.</p>
</div>
<div class="paragraph">
<p>With that in mind, we&#8217;ll work in this chapter toward requesting, receiving, and validating block headers using the network protocol.</p>
</div>
<div class="sect2">
<h3 id="_network_messages">Network Messages</h3>
<div class="paragraph">
<p>All network messages look like <a href="#network_message_or_the_envelope_that_contains_the_actual_payload">A network message—the envelope that contains the actual payload</a>.</p>
</div>
<div class="paragraph">
<p>The first 4 bytes are always the same and are referred to as the <em>network magic</em>.
Magic bytes are common in network programming as the communication is asynchronous and can be intermittent.
Magic bytes give the receiver of the message a place to start should the communication get interrupted (say, by your phone dropping signal).
They are also useful for identifying the network.
You would not want a Bitcoin node to connect to a Litecoin node, for example.
Thus, a Litecoin node has a different magic.
Bitcoin testnet also has a different magic, <code>0b110907</code>, as opposed to the Bitcoin mainnet magic, <code>f9beb4d9</code>.</p>
</div>
<div id="network_message_or_the_envelope_that_contains_the_actual_payload" class="imageblock">
<div class="content">
<img src="./images/prbc_1001.png" alt="Network Message">
</div>
<div class="title">Figure 118. A network message—the envelope that contains the actual payload</div>
</div>
<div class="paragraph">
<p>The next 12 bytes are the command field, or a description of what the payload actually carries.
There are many different commands; an exhaustive list can be seen in the <a href="https://en.bitcoin.it/wiki/Protocol_documentation">documentation</a>.
The command field is meant to be human-readable and this particular message is the byte string "version" in ASCII with 0-byte padding.</p>
</div>
<div class="paragraph">
<p>The next 4 bytes are the length of the payload in little-endian.
As we saw in Chapters <a data-type="xref" href="#chapter_tx_parsing" data-xrefstyle="select:labelnumber">#chapter_tx_parsing</a> and
<a data-type="xref" href="#chapter_blocks" data-xrefstyle="select:labelnumber">#chapter_blocks</a>, the length of the payload is necessary since the payload is variable.
2<sup>32</sup> is about 4 billion, so payloads can be as big as 4 GB, though the reference client rejects any payloads over 32 MB.
In the message in Figure 10-1, our payload is 101 bytes.</p>
</div>
<div class="paragraph">
<p>The next 4 bytes are the checksum field.
The checksum algorithm is something of an odd choice, as it&#8217;s the first 4 bytes of the hash256 of the payload.
It&#8217;s an odd choice because networking protocol checksums are normally designed to have error-correcting capability and hash256 has none.
That said, hash256 is common in the rest of the Bitcoin protocol, which is probably the reason it&#8217;s used here.</p>
</div>
<div class="paragraph">
<p>The code to handle network messages requires us to create a new class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">NETWORK_MAGIC = b'\xf9\xbe\xb4\xd9'
TESTNET_NETWORK_MAGIC = b'\x0b\x11\x09\x07'


class NetworkEnvelope:

    def __init__(self, command, payload, testnet=False):
        self.command = command
        self.payload = payload
        if testnet:
            self.magic = TESTNET_NETWORK_MAGIC
        else:
            self.magic = NETWORK_MAGIC

    def __repr__(self):
        return '{}: {}'.format(
            self.command.decode('ascii'),
            self.payload.hex(),
        )</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_1_10">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>parse</code> method for <code>NetworkEnvelope</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_10">Exercise 2</h4>
<div class="paragraph">
<p>Determine what this network message is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>f9beb4d976657261636b000000000000000000005df6e0e2</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_10">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>NetworkEnvelope</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_the_payload">Parsing the Payload</h3>
<div class="paragraph">
<p>Each command has a separate payload specification.
<a href="#parsed_version_chap_ten">Parsed version</a> is the parsed payload for <code>version</code>.</p>
</div>
<div id="parsed_version_chap_ten" class="imageblock">
<div class="content">
<img src="./images/prbc_1002.png" alt="Version Message">
</div>
<div class="title">Figure 119. Parsed version</div>
</div>
<div class="paragraph">
<p>The fields are meant to give enough information for two nodes to be able to <span class="keep-together">communicate</span>.</p>
</div>
<div class="paragraph">
<p>The first field is the network protocol version, which specifies what messages may be communicated.
The service field gives information about what capabilities are available to connecting nodes.
The timestamp field is 8 bytes (as opposed to 4 bytes in the block header) and is the Unix timestamp in little-endian.</p>
</div>
<div class="paragraph">
<p>IP addresses can be IPv6, IPv4, or OnionCat (a mapping of TOR&#8217;s <code>.onion</code> addresses to IPv6).
If IPv4, the first 12 bytes are <code>00000000000000000000ffff</code> and the last 4 bytes are the IP.
The port is 2 bytes in big-endian. The default on mainnet is 8333, which maps to <code>208d</code> in big-endian hex.</p>
</div>
<div class="paragraph">
<p>A nonce is a number used by a node to detect a connection to itself.
The user agent identifies the software being run.
The height or latest block field helps the other node know which block a node is synced up to.</p>
</div>
<div class="paragraph">
<p>Relay is used for Bloom filters, which we&#8217;ll get to in <a href="#chapter_bloom_filters">Bloom Filters</a>.</p>
</div>
<div class="paragraph">
<p>Setting some reasonable defaults, our <code>VersionMessage</code> class looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class VersionMessage:
    command = b'version'

    def __init__(self, version=70015, services=0, timestamp=None,
                 receiver_services=0,
                 receiver_ip=b'\x00\x00\x00\x00', receiver_port=8333,
                 sender_services=0,
                 sender_ip=b'\x00\x00\x00\x00', sender_port=8333,
                 nonce=None, user_agent=b'/programmingbitcoin:0.1/',
                 latest_block=0, relay=False):
        self.version = version
        self.services = services
        if timestamp is None:
            self.timestamp = int(time.time())
        else:
            self.timestamp = timestamp
        self.receiver_services = receiver_services
        self.receiver_ip = receiver_ip
        self.receiver_port = receiver_port
        self.sender_services = sender_services
        self.sender_ip = sender_ip
        self.sender_port = sender_port
        if nonce is None:
            self.nonce = int_to_little_endian(randint(0, 2**64), 8)
        else:
            self.nonce = nonce
        self.user_agent = user_agent
        self.latest_block = latest_block
        self.relay = relay</code></pre>
</div>
</div>
<div class="paragraph">
<p>At this point, we need a way to serialize this message.</p>
</div>
<div class="sect3">
<h4 id="_exercise_4_10">Exercise 4</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>VersionMessage</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_network_handshake">Network Handshake</h3>
<div class="paragraph">
<p>The network handshake is how nodes establish communication:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A wants to connect to B and sends a version message.</p>
</li>
<li>
<p>B receives the version message, responds with a verack message, and sends its own version message.</p>
</li>
<li>
<p>A receives the version and verack messages and sends back a verack message.</p>
</li>
<li>
<p>B receives the verack message and continues communication.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once the handshake is finished, A and B can communicate however they want.
Note that there is no authentication here, and it&#8217;s up to the nodes to verify all data that they receive.
If a node sends a bad transaction or block, it can expect to get banned or disconnected.</p>
</div>
</div>
<div class="sect2">
<h3 id="_connecting_to_the_network">Connecting to the Network</h3>
<div class="paragraph">
<p>Network communication is tricky due to its asynchronous nature.
To experiment, we can establish a connection to a node on the network synchronously:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; import socket
&gt;&gt;&gt; from network import NetworkEnvelope, VersionMessage
&gt;&gt;&gt; host = 'testnet.programmingbitcoin.com'  # <b class="conum">(1)</b>
&gt;&gt;&gt; port = 18333
&gt;&gt;&gt; socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&gt;&gt;&gt; socket.connect((host, port))
&gt;&gt;&gt; stream = socket.makefile('rb', None)  # <b class="conum">(2)</b>
&gt;&gt;&gt; version = VersionMessage()  # <b class="conum">(3)</b>
&gt;&gt;&gt; envelope = NetworkEnvelope(version.command, version.serialize())
&gt;&gt;&gt; socket.sendall(envelope.serialize())  # <b class="conum">(4)</b>
&gt;&gt;&gt; while True:
...     new_message = NetworkEnvelope.parse(stream)  # <b class="conum">(5)</b>
...     print(new_message)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is a server I&#8217;ve set up for testnet.
The testnet port is 18333 by default.</p>
</li>
<li>
<p>We create a stream to be able to read from the socket.
A stream made this way can be passed to all the parse methods.</p>
</li>
<li>
<p>The first step of the handshake is to send a version message.</p>
</li>
<li>
<p>We now send the message in the right envelope.</p>
</li>
<li>
<p>This line will read any messages coming in through our connected socket.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Connecting in this way, we can&#8217;t send until we&#8217;ve received and can&#8217;t respond intelligently to more than one message at a time.
A more robust implementation would use an asynchronous library (like <code>asyncio</code> in Python 3) to send and receive without being blocked.</p>
</div>
<div class="paragraph">
<p>We also need a verack message class, which we&#8217;ll create here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class VerAckMessage:
    command = b'verack'

    def __init__(self):
        pass

    @classmethod
    def parse(cls, s):
        return cls()

    def serialize(self):
        return b''</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>VerAckMessage</code> is a minimal network message.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s now automate this by creating a class that will handle the communication for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class SimpleNode:

    def __init__(self, host, port=None, testnet=False, logging=False):
        if port is None:
            if testnet:
                port = 18333
            else:
                port = 8333
        self.testnet = testnet
        self.logging = logging
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((host, port))
        self.stream = self.socket.makefile('rb', None)

    def send(self, message):  # <b class="conum">(1)</b>
        '''Send a message to the connected node'''
        envelope = NetworkEnvelope(
            message.command, message.serialize(), testnet=self.testnet)
        if self.logging:
            print('sending: {}'.format(envelope))
        self.socket.sendall(envelope.serialize())

    def read(self):  # <b class="conum">(2)</b>
        '''Read a message from the socket'''
        envelope = NetworkEnvelope.parse(self.stream, testnet=self.testnet)
        if self.logging:
            print('receiving: {}'.format(envelope))
        return envelope

    def wait_for(self, *message_classes):  # <b class="conum">(3)</b>
        '''Wait for one of the messages in the list'''
        command = None
        command_to_class = {m.command: m for m in message_classes}
        while command not in command_to_class.keys():
            envelope = self.read()
            command = envelope.command
            if command == VersionMessage.command:
                self.send(VerAckMessage())
            elif command == PingMessage.command:
                self.send(PongMessage(envelope.payload))
        return command_to_class[command].parse(envelope.stream())</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>send</code> method sends a message over the socket.
The <code>command</code> property and <code>serialize</code> methods are expected to exist in the <code>message</code> object.</p>
</li>
<li>
<p>The <code>read</code> method reads a new message from the socket.</p>
</li>
<li>
<p>The <code>wait_for</code> method lets us wait for any one of several commands (specifically, message classes).
Along with the synchronous nature of this class, a method like this makes for easier programming.
A commercial-strength node would definitely not use something like this.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now that we have a node, we can handshake with another node:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from network import SimpleNode, VersionMessage
&gt;&gt;&gt; node = SimpleNode('testnet.programmingbitcoin.com', testnet=True)
&gt;&gt;&gt; version = VersionMessage()  # <b class="conum">(1)</b>
&gt;&gt;&gt; node.send(version)  # <b class="conum">(2)</b>
&gt;&gt;&gt; verack_received = False
&gt;&gt;&gt; version_received = False
&gt;&gt;&gt; while not verack_received and not version_received:  # <b class="conum">(3)</b>
...     message = node.wait_for(VersionMessage, VerAckMessage)  # <b class="conum">(4)</b>
...     if message.command == VerAckMessage.command:
...         verack_received = True
...     else:
...         version_received = True
...         node.send(VerAckMessage())</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Most nodes don&#8217;t care about the fields in <code>version</code> like IP address.
We can connect with the defaults and everything will be just fine.</p>
</li>
<li>
<p>We start the handshake by sending the version message.</p>
</li>
<li>
<p>We only finish when we&#8217;ve received both verack and version.</p>
</li>
<li>
<p>We expect to receive a verack for our version and the other node&#8217;s version.
We don&#8217;t know in which order they will arrive, though.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_5_9">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code>handshake</code> method for <code>SimpleNode</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getting_block_headers">Getting Block Headers</h3>
<div class="paragraph">
<p>Now that we have code to connect to a node, what can we do?
When any node first connects to the network, the data that&#8217;s most crucial to get and verify is the block headers.
For full nodes, downloading the block headers allows them to asynchronously ask for full blocks from multiple nodes, parallelizing the download of the blocks.
For light clients, downloading headers allows them to verify the proof-of-work in each block.
As we&#8217;ll see in <a href="#chapter_spv">Simplified Payment Verification</a>, light clients will be able to get proofs of inclusion through the network, but that requires the light clients to have the block headers.</p>
</div>
<div class="paragraph">
<p>Nodes can give us the block headers without taking up much bandwidth.
The command to get the block headers is called <code>getheaders</code>, and it looks like <a href="#parsed_getheaders">Parsed getheaders</a>.</p>
</div>
<div id="parsed_getheaders" class="imageblock">
<div class="content">
<img src="./images/prbc_1003.png" alt="GetHeaders payload">
</div>
<div class="title">Figure 120. Parsed getheaders</div>
</div>
<div class="paragraph">
<p>As with version, we start with the protocol version, then the number of block header groups in this list (this number can be more than 1 if there&#8217;s a chain split), then the starting block header, and finally the ending block header.
If we specify the ending block to be <code>000&#8230;&#8203;000</code>, we&#8217;re indicating that we want as many as the other node will give us.
The maximum number of headers that we can get back is 2,000, or almost a single difficulty adjustment period (2,016 blocks).</p>
</div>
<div class="paragraph">
<p>Here&#8217;s what the class looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class GetHeadersMessage:
    command = b'getheaders'

    def __init__(self, version=70015, num_hashes=1,
        start_block=None, end_block=None):
        self.version = version
        self.num_hashes = num_hashes  # <b class="conum">(1)</b>
        if start_block is None:  # <b class="conum">(2)</b>
            raise RuntimeError('a start block is required')
        self.start_block = start_block
        if end_block is None:
            self.end_block = b'\x00' * 32  # <b class="conum">(3)</b>
        else:
            self.end_block = end_block</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>For the purposes of this chapter, we&#8217;re going to assume that the number of block header groups is 1.
A more robust implementation would handle more than a single block group, but we can download the block headers using a single group.</p>
</li>
<li>
<p>A starting block is needed, otherwise we can&#8217;t create a proper message.</p>
</li>
<li>
<p>The ending block we assume to be null, or as many as the server will send to us if not defined.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_6_7">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>GetHeadersMessage</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_headers_response">Headers Response</h3>
<div class="paragraph">
<p>We can now create a node, handshake, and then ask for some headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from block import Block, GENESIS_BLOCK
&gt;&gt;&gt; from network import SimpleNode, GetHeadersMessage
&gt;&gt;&gt; node = SimpleNode('mainnet.programmingbitcoin.com', testnet=False)
&gt;&gt;&gt; node.handshake()
&gt;&gt;&gt; genesis = Block.parse(BytesIO(GENESIS_BLOCK))
&gt;&gt;&gt; getheaders = GetHeadersMessage(start_block=genesis.hash())
&gt;&gt;&gt; node.send(getheaders)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we need a way to receive the headers from the other node.
The other node will send back the <code>headers</code> command.
This is a list of block headers (<a href="#parsed_headers_chap_ten">Parsed headers</a>), which we already learned how to parse in <a href="#chapter_blocks">Blocks</a>.
The <code>HeadersMessage</code> class can take advantage of this when parsing.</p>
</div>
<div id="parsed_headers_chap_ten" class="imageblock">
<div class="content">
<img src="./images/prbc_1004.png" alt="headers payload">
</div>
<div class="title">Figure 121. Parsed headers</div>
</div>
<div class="paragraph">
<p>The headers message starts with the number of headers as a varint, which is a number from 1 to 2,000 inclusive.
Each block header, we know, is 80 bytes.
Then we have the number of transactions.
The number of transactions in the headers message is always 0.
This may be a bit confusing at first, since we only asked for the headers and not the transactions.
The reason nodes bother sending the number of transactions at all is because the headers message is meant to be compatible with the format for the block message, which is the block header, the number of transactions, and then the transactions themselves.
By specifying that the number of transactions is 0, we can use the same parsing engine as when parsing a full block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class HeadersMessage:
    command = b'headers'

    def __init__(self, blocks):
        self.blocks = blocks

    @classmethod
    def parse(cls, stream):
        num_headers = read_varint(stream)
        blocks = []
        for _ in range(num_headers):
            blocks.append(Block.parse(stream))  # <b class="conum">(1)</b>
            num_txs = read_varint(stream)  # <b class="conum">(2)</b>
            if num_txs != 0:  # <b class="conum">(3)</b>
                raise RuntimeError('number of txs not 0')
        return cls(blocks)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Each block gets parsed with the <code>Block</code> class&#8217;s <code>parse</code> method, using the same stream that we have.</p>
</li>
<li>
<p>The number of transactions is always 0 and is a remnant of block parsing.</p>
</li>
<li>
<p>If we didn&#8217;t get 0, something is wrong.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Given the network connection that we&#8217;ve set up, we can download the headers, check their proof-of-work, and validate the block header difficulty adjustments as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from network import SimpleNode, GetHeadersMessage, HeadersMessage
&gt;&gt;&gt; from block import Block, GENESIS_BLOCK, LOWEST_BITS
&gt;&gt;&gt; from helper import calculate_new_bits
&gt;&gt;&gt; previous = Block.parse(BytesIO(GENESIS_BLOCK))
&gt;&gt;&gt; first_epoch_timestamp = previous.timestamp
&gt;&gt;&gt; expected_bits = LOWEST_BITS
&gt;&gt;&gt; count = 1
&gt;&gt;&gt; node = SimpleNode('mainnet.programmingbitcoin.com', testnet=False)
&gt;&gt;&gt; node.handshake()
&gt;&gt;&gt; for _ in range(19):
...     getheaders = GetHeadersMessage(start_block=previous.hash())
...     node.send(getheaders)
...     headers = node.wait_for(HeadersMessage)
...     for header in headers.blocks:
...         if not header.check_pow():  # <b class="conum">(1)</b>
...             raise RuntimeError('bad PoW at block {}'.format(count))
...         if header.prev_block != previous.hash():  # <b class="conum">(2)</b>
...             raise RuntimeError('discontinuous block at {}'.format(count))
...         if count % 2016 == 0:
...             time_diff = previous.timestamp - first_epoch_timestamp
...             expected_bits = calculate_new_bits(previous.bits, time_diff)  # <b class="conum">(4)</b>
...             print(expected_bits.hex())
...             first_epoch_timestamp = header.timestamp  # <b class="conum">(5)</b>
...         if header.bits != expected_bits:  # <b class="conum">(3)</b>
...             raise RuntimeError('bad bits at block {}'.format(count))
...         previous = header
...         count += 1
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
ffff001d
6ad8001d
28c4001d
71be001d</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Check that the proof-of-work is valid.</p>
</li>
<li>
<p>Check that the current block is after the previous one.</p>
</li>
<li>
<p>Check that the bits/target/difficulty is what we expect based on the previous epoch calculation.</p>
</li>
<li>
<p>At the end of the epoch, calculate the next bits/target/difficulty.</p>
</li>
<li>
<p>Store the first block of the epoch to calculate bits at the end of the epoch.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that this won&#8217;t work on testnet as the difficulty adjustment algorithm is different.
To make sure blocks can be found consistently for testing, if a block hasn&#8217;t been found on testnet in 20 minutes, the difficulty drops to 1, making it very easy to find a block.
This is set up this way to allow testers to be able to keep building blocks on the network without expensive mining equipment.
A $30 USB ASIC can typically find a few blocks per minute at the minimum difficulty.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_10">Conclusion</h3>
<div class="paragraph">
<p>We&#8217;ve managed to connect to a node on the network, handshake, download the block headers, and verify that they meet the consensus rules.
In the next chapter, we focus on getting information about transactions that we&#8217;re interested in from another node in a private yet provable way.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_spv">Simplified Payment Verification</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>The one block header field that we didn&#8217;t investigate much in <a href="#chapter_blocks">Blocks</a> was the Merkle root.
To understand what makes the Merkle root useful, we first have to learn about Merkle trees and what properties they have.
In this chapter, we&#8217;re going to learn exactly what a Merkle root is.
This will be motivated by something called a <em>proof of inclusion</em>.</p>
</div>
<div class="sect2">
<h3 id="_motivation">Motivation</h3>
<div class="paragraph">
<p>For a device that doesn&#8217;t have much disk space, bandwidth, or computing power, it&#8217;s expensive to store, receive, and validate the entire blockchain.
As of this writing, the entire Bitcoin blockchain is around 200 GB, which is more than many phones can store; it can be very difficult to download efficiently and will certainly tax the CPU.
If the entire blockchain cannot be put on the phone, what else can we do?
Is it possible to create a Bitcoin wallet on a phone without having all the data?</p>
</div>
<div class="paragraph">
<p>For any wallet, there are two scenarios that we&#8217;re concerned with:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Paying someone</p>
</li>
<li>
<p>Getting paid by someone</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you are paying someone with your Bitcoin wallet, it is up to the person receiving your bitcoins to verify that they&#8217;ve been paid.
Once they&#8217;ve verified that the transaction has been included in a block sufficiently deep, the other side of the trade, or the good or service, will be given to you.
Once you&#8217;ve sent the transaction to the other party, there really isn&#8217;t anything for you to do other than wait until you receive whatever it is you&#8217;re exchanging the bitcoins for.</p>
</div>
<div class="paragraph">
<p>When getting paid bitcoins, however, we have a dilemma.
If we are connected and have the full blockchain, we can easily see when the transaction is in a sufficiently deep block, at which point we give the other party our goods or services.
But if we don&#8217;t have the full blockchain, as with a phone, what can we do?</p>
</div>
<div class="paragraph">
<p>The answer lies in the Merkle root field from the block header that we saw in <a href="#chapter_blocks">Blocks</a>.
As we saw in the last chapter, we can download the block headers and verify that they meet the Bitcoin consensus rules.
In this chapter we&#8217;re going to work toward getting proof that a particular transaction is in a block that we know about.
Since the block header is secured by proof-of-work, a transaction with a proof of inclusion in that block means, at a minimum, there was a good deal of energy spent to produce that block.
This means that the cost to deceive you would be at least the cost of the proof-of-work for the block.
The rest of this chapter goes into what the proof of inclusion is and how to verify it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_tree">Merkle Tree</h3>
<div class="paragraph">
<p>A Merkle tree is a computer science structure designed for efficient proofs of inclusion.
The prerequisites are an ordered list of items and a cryptographic hash function.
In our case, the items in the ordered list are transactions in a block and the hash function is hash256.
To construct the Merkle tree, we follow this algorithm:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hash all the items of the ordered list with the provided hash function.</p>
</li>
<li>
<p>If there is exactly 1 hash, we are done.</p>
</li>
<li>
<p>Otherwise, if there is an odd number of hashes, we duplicate the last hash in the list and add it to the end so that we have an even number of hashes.</p>
</li>
<li>
<p>We pair the hashes in order and hash the concatenation to get the parent level, which should have half the number of hashes.</p>
</li>
<li>
<p>Go to &#35;2.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The idea is to come to a single hash that "represents" the entire ordered list.
Visually, a Merkle tree looks like <a href="#merkle_tree_chap_eleven">Merkle tree</a>.</p>
</div>
<div class="paragraph">
<p>The bottom row is what we call the <em>leaves</em> of the tree.
All other nodes besides the leaves are called <em>internal nodes</em>.
The leaves get combined to produce a <em>parent level</em> (H<sub>AB</sub> and H<sub>CD</sub>), and when we calculate the parent level of that, we get the Merkle root.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll go through each part of this process in the following sections.</p>
</div>
<div id="merkle_tree_chap_eleven" class="imageblock">
<div class="content">
<img src="./images/prbc_1101.png" alt="Merkle tree">
</div>
<div class="title">Figure 122. Merkle tree</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Be Careful with Merkle Trees!</div>
<div class="paragraph">
<p>There was a vulnerability in Bitcoin 0.4&#8211;0.6 related to the Merkle root, which is detailed in CVE-2012-2459.
There was a denial-of-service vector due to the duplication of the last item in Merkle trees, which caused some nodes to invalidate blocks even if they were valid.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_parent">Merkle Parent</h3>
<div class="paragraph">
<p>Given two hashes, we produce another hash that represents both of them.
As they are ordered, we will call the two hashes the <em>left</em> hash and the <em>right</em> hash.
The hash of the left and right hashes is what we call the <em>parent</em> hash.
To clarify, here&#8217;s the formula for the parent hash:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>H</em> = Hashing function</p>
</li>
<li>
<p><em>P</em> = Parent hash</p>
</li>
<li>
<p><em>L</em> = Left hash</p>
</li>
<li>
<p><em>R</em> = Right hash</p>
</li>
</ul>
</div>
<ul class="simplelist">
<li><em>P</em>=<em>H</em>(<em>L</em>||<em>R</em>)</li>
</ul>
<div class="paragraph">
<p>Note that the || symbol denotes concatenation.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how we can code this process in Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; hash0 = bytes.fromhex('c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38b\
dc15d9eb64cf5')
&gt;&gt;&gt; hash1 = bytes.fromhex('c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea\
7a08d672d7cc5')
&gt;&gt;&gt; parent = hash256(hash0 + hash1)
&gt;&gt;&gt; print(parent.hex())
8b30c5ba100f6f2e5ad1e2a742e5020491240f8eb514fe97c713c31718ad7ecd</pre>
</div>
</div>
<div class="paragraph">
<p>The reason why we hash the concatenation to get the parent is because we can provide a proof of inclusion.
Specifically, we can show that <em>L</em> is represented in the parent, <em>P</em>, by revealing <em>R</em>.
That is, if we want proof <em>L</em> is represented in <em>P</em>, the producer of <em>P</em> can show us <em>R</em> and let us know that <em>L</em> is the left child of <em>P</em>.
We can then combine <em>L</em> and <em>R</em> to produce <em>P</em> and have proof that <em>L</em> was used to produce <em>P</em>.
If <em>L</em> is not represented in <em>P</em>, being able to provide <em>R</em> would be the equivalent to providing a hash pre-image, which we know is very difficult.
This is what we mean by a proof of inclusion.</p>
</div>
<div class="sect3">
<h4 id="_exercise_1_11">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>merkle_parent</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_parent_level">Merkle Parent Level</h3>
<div class="paragraph">
<p>Given an ordered list of more than two hashes, we can calculate the parents of each pair, or what we call the <em>Merkle parent level</em>.
If we have an even number of hashes, this is straightforward, as we can simply pair them up in order.
If we have an odd number of hashes, then we need to do something, as we have a lone hash at the end.
We can solve this by duplicating the last item.</p>
</div>
<div class="paragraph">
<p>That is, for a list like [A, B, C] we can add C again to get [A, B, C, C].
Now we can calculate the Merkle parent of A and B and calculate the Merkle parent of C and C to get:</p>
</div>
<ul class="simplelist">
<li>[<em>H</em>(<em>A</em>||<em>B</em>), <em>H</em>(<em>C</em>||<em>C</em>)]</li>
</ul>
<div class="paragraph">
<p>Since the Merkle parent always consists of two hashes, the Merkle parent level always has exactly half the number of hashes, rounded up. Here is how we calculate a Merkle parent level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from helper import merkle_parent
&gt;&gt;&gt; hex_hashes = [
...     'c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38bdc15d9eb64cf5',
...     'c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea7a08d672d7cc5',
...     'f391da6ecfeed1814efae39e7fcb3838ae0b02c02ae7d0a5848a66947c0727b0',
...     '3d238a92a94532b946c90e19c49351c763696cff3db400485b813aecb8a13181',
...     '10092f2633be5f3ce349bf9ddbde36caa3dd10dfa0ec8106bce23acbff637dae',
... ]
&gt;&gt;&gt; hashes = [bytes.fromhex(x) for x in hex_hashes]
&gt;&gt;&gt; if len(hashes) % 2 == 1:
...     hashes.append(hashes[-1])  # <b class="conum">(1)</b>
&gt;&gt;&gt; parent_level = []
&gt;&gt;&gt; for i in range(0, len(hashes), 2):  # <b class="conum">(2)</b>
...     parent = merkle_parent(hashes[i], hashes[i+1])
...     parent_level.append(parent)
&gt;&gt;&gt; for item in parent_level:
...     print(item.hex())
8b30c5ba100f6f2e5ad1e2a742e5020491240f8eb514fe97c713c31718ad7ecd
7f4e6f9e224e20fda0ae4c44114237f97cd35aca38d83081c9bfd41feb907800
3ecf6115380c77e8aae56660f5634982ee897351ba906a6837d15ebc3a225df0</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We add the last hash on the list, <code>hashes[-1]</code>, to the end of <code>hashes</code> to make the length of <code>hashes</code> even.</p>
</li>
<li>
<p>This is how we skip by two in Python.
<code>i</code> will be 0 the first time through the loop, 2 the second, 4 the third, and so on.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This code results in a new list of hashes that correspond to the Merkle parent level.</p>
</div>
<div class="sect3">
<h4 id="_exercise_2_11">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>merkle_parent_level</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_root_2">Merkle Root</h3>
<div class="paragraph">
<p>To get the Merkle root we calculate successive Merkle parent levels until we get a single hash.
If, for example, we have items A through G (7 items), we calculate the Merkle parent level first as follows:</p>
</div>
<ul class="simplelist">
<li>[<em>H</em>(<em>A</em>||<em>B</em>), <em>H</em>(<em>C</em>||<em>D</em>), <em>H</em>(<em>E</em>||<em>F</em>), <em>H</em>(<em>G</em>||<em>G</em>)]</li>
</ul>
<div class="paragraph">
<p>Then we calculate the Merkle parent level again:</p>
</div>
<ul class="simplelist">
<li>[<em>H</em>(<em>H</em>(<em>A</em>||<em>B</em>)||<em>H</em>(<em>C</em>||<em>D</em>)), <em>H</em>(<em>H</em>(<em>E</em>||<em>F</em>)||<em>H</em>(<em>G</em>||<em>G</em>))]</li>
</ul>
<div class="paragraph">
<p>We are left with just two items, so we calculate the Merkle parent level one more time:</p>
</div>
<ul class="simplelist">
<li><em>H</em>(<em>H</em>(<em>H</em>(<em>A</em>||<em>B</em>)||<em>H</em>(<em>C</em>||<em>D</em>))||<em>H</em>(<em>H</em>(<em>E</em>||<em>F</em>)||<em>H</em>(<em>G</em>||<em>G</em>)))</li>
</ul>
<div class="paragraph">
<p>Since we are left with exactly one hash, we are done.
Each level will halve the number of hashes, so doing this process over and over will eventually result in a final single item called the Merkle root:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import merkle_parent_level
&gt;&gt;&gt; hex_hashes = [
...     'c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38bdc15d9eb64cf5',
...     'c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea7a08d672d7cc5',
...     'f391da6ecfeed1814efae39e7fcb3838ae0b02c02ae7d0a5848a66947c0727b0',
...     '3d238a92a94532b946c90e19c49351c763696cff3db400485b813aecb8a13181',
...     '10092f2633be5f3ce349bf9ddbde36caa3dd10dfa0ec8106bce23acbff637dae',
...     '7d37b3d54fa6a64869084bfd2e831309118b9e833610e6228adacdbd1b4ba161',
...     '8118a77e542892fe15ae3fc771a4abfd2f5d5d5997544c3487ac36b5c85170fc',
...     'dff6879848c2c9b62fe652720b8df5272093acfaa45a43cdb3696fe2466a3877',
...     'b825c0745f46ac58f7d3759e6dc535a1fec7820377f24d4c2c6ad2cc55c0cb59',
...     '95513952a04bd8992721e9b7e2937f1c04ba31e0469fbe615a78197f68f52b7c',
...     '2e6d722e5e4dbdf2447ddecc9f7dabb8e299bae921c99ad5b0184cd9eb8e5908',
...     'b13a750047bc0bdceb2473e5fe488c2596d7a7124b4e716fdd29b046ef99bbf0',
... ]
&gt;&gt;&gt; hashes = [bytes.fromhex(x) for x in hex_hashes]
&gt;&gt;&gt; current_hashes = hashes
&gt;&gt;&gt; while len(current_hashes) &gt; 1:  # <b class="conum">(1)</b>
...     current_hashes = merkle_parent_level(current_hashes)
&gt;&gt;&gt; print(current_hashes[0].hex())  # <b class="conum">(2)</b>
acbcab8bcc1af95d8d563b77d24c3d19b18f1486383d75a5085c4e86c86beed6</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We loop until there&#8217;s one hash left.</p>
</li>
<li>
<p>We&#8217;ve exited the loop so there should only be one item.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_3_11">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>merkle_root</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_root_in_blocks">Merkle Root in Blocks</h3>
<div class="paragraph">
<p>Calculating the Merkle root in blocks should be pretty straightforward, but due to endianness issues, it turns out to be tricky.
Specifically, we use little-endian ordering for the leaves of the Merkle tree.
After we calculate the Merkle root, we use little-endian ordering again.</p>
</div>
<div class="paragraph">
<p>In practice, this means reversing the leaves before we start and reversing the root at the end:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from helper import merkle_root
&gt;&gt;&gt; tx_hex_hashes = [
...     '42f6f52f17620653dcc909e58bb352e0bd4bd1381e2955d19c00959a22122b2e',
...     '94c3af34b9667bf787e1c6a0a009201589755d01d02fe2877cc69b929d2418d4',
...     '959428d7c48113cb9149d0566bde3d46e98cf028053c522b8fa8f735241aa953',
...     'a9f27b99d5d108dede755710d4a1ffa2c74af70b4ca71726fa57d68454e609a2',
...     '62af110031e29de1efcad103b3ad4bec7bdcf6cb9c9f4afdd586981795516577',
...     '766900590ece194667e9da2984018057512887110bf54fe0aa800157aec796ba',
...     'e8270fb475763bc8d855cfe45ed98060988c1bdcad2ffc8364f783c98999a208',
... ]
&gt;&gt;&gt; tx_hashes = [bytes.fromhex(x) for x in tx_hex_hashes]
&gt;&gt;&gt; hashes = [h[::-1] for h in tx_hashes]  # <b class="conum">(1)</b>
&gt;&gt;&gt; print(merkle_root(hashes)[::-1].hex())  # <b class="conum">(2)</b>
654d6181e18e4ac4368383fdc5eead11bf138f9b7ac1e15334e4411b3c4797d9</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We reverse each hash before we begin using a Python list comprehension.</p>
</li>
<li>
<p>We reverse the root at the end.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We want to calculate Merkle roots for a <code>Block</code>, so we add a <code>tx_hashes</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:

    def __init__(self, version, prev_block, merkle_root,
                 timestamp, bits, nonce, tx_hashes=None):  # <b class="conum">(1)</b>
        self.version = version
        self.prev_block = prev_block
        self.merkle_root = merkle_root
        self.timestamp = timestamp
        self.bits = bits
        self.nonce = nonce
        self.tx_hashes = tx_hashes</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We now allow the transaction hashes to be set as part of the initialization of the block.
The transaction hashes have to be ordered.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As a full node, if we are given all of the transactions, we can calculate the Merkle root and check that the Merkle root is what we expect.</p>
</div>
<div class="sect3">
<h4 id="_exercise_4_11">Exercise 4</h4>
<div class="paragraph">
<p>Write the <code>validate_merkle_root</code> method for <code>Block</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_a_merkle_tree">Using a Merkle Tree</h3>
<div class="paragraph">
<p>Now that we know how a Merkle tree is constructed, we can create and verify proofs of inclusion.
Light nodes can get proofs that transactions of interest were included in a block without having to know all the transactions of a block (<a href="#merkle_proof">Merkle proof</a>).</p>
</div>
<div class="paragraph">
<p>Say that a light client has two transactions that are of interest, which would be the hashes represented by the green boxes, H<sub>K</sub> and H<sub>N</sub> in <a href="#merkle_proof">Merkle proof</a>.
A full node can construct a proof of inclusion by sending us all of the hashes marked by blue boxes: H<sub>ABCDEFGH</sub>, H<sub>IJ</sub>, H<sub>L</sub>, H<sub>M</sub>, and H<sub>OP</sub>.
The light client would then perform these calculations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>H<sub>KL</sub> = <em>merkle_parent</em>(H<sub>K</sub>, H<sub>L</sub>)</p>
</li>
<li>
<p>H<sub>MN</sub> = <em>merkle_parent</em>(H<sub>M</sub>, H<sub>N</sub>)</p>
</li>
<li>
<p>H<sub>IJKL</sub> = <em>merkle_parent</em>(H<sub>IJ</sub>, H<sub>KL</sub>)</p>
</li>
<li>
<p>H<sub>MNOP</sub> = <em>merkle_parent</em>(H<sub>MN</sub>, H<sub>OP</sub>)</p>
</li>
<li>
<p>H<sub>IJKLMNOP</sub> = <em>merkle_parent</em>(H<sub>IJKL</sub>, H<sub>MNOP</sub>)</p>
</li>
<li>
<p>H<sub>ABCDEFGHIJKLMNOP</sub> = <em>merkle_parent</em>(H<sub>ABCDEFGH</sub>, H<sub>IJKLMNOP</sub>)</p>
</li>
</ul>
</div>
<div id="merkle_proof" class="imageblock">
<div class="content">
<img src="./images/prbc_1102.png" alt="Merkle Proof">
</div>
<div class="title">Figure 123. Merkle proof</div>
</div>
<div class="paragraph">
<p>You can see that in <a href="#merkle_proof">Merkle proof</a>, the dotted boxes correspond to the hashes that the light client calculates. In particular, the Merkle root is H<sub>ABCDEFGHIJKLMNOP</sub>, which can then be checked against the block header whose proof-of-work has been validated.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">How Secure Is an SPV Proof?</div>
<div class="paragraph">
<p>The full node can send a limited amount of information about the block and the light client can recalculate the Merkle root, which can then be verified against the Merkle root in the block header.
This does not guarantee that the transaction is in the longest blockchain, but it does assure the light client that the full node would have had to spend a lot of hashing power or energy creating a valid proof-of-work.
As long as the reward for creating such a proof-of-work is greater than the amounts in the transactions, the light client can at least know that the full node has no clear economic incentive to lie.</p>
</div>
<div class="paragraph">
<p>Since block headers can be requested from multiple nodes, light clients have a way to verify if one node is trying to show them block headers that are not the longest.
It only takes a single honest node to invalidate a hundred dishonest ones, since proof-of-work is objective.
Therefore, isolation of a light client (that is, control of who the light client is connected to) is required to deceive in this way.
The security of SPV requires that there be lots of honest nodes on the network.</p>
</div>
<div class="paragraph">
<p>In other words, light client security is based on a robust network of nodes and the economic cost of producing proof-of-work.
For small transactions relative to the block subsidy (currently 12.5 BTC), there&#8217;s probably little to worry about.
For large transactions (say, 100 BTC), the full nodes may have an economic incentive to deceive you.
Transactions that large should generally be validated using a full node.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_block">Merkle Block</h3>
<div class="paragraph">
<p>When a full node sends a proof of inclusion, there are two pieces of information that need to be included.
First, the light client needs the Merkle tree structure, and second, the light client needs to know which hash is at which position in the Merkle tree.
Once both pieces of information are given, the light client can reconstruct the partial Merkle tree to reconstruct the Merkle root and validate the proof of inclusion.
A full node communicates these two pieces of information to a light client using a Merkle block.</p>
</div>
<div class="paragraph">
<p>To understand what&#8217;s in a Merkle block, we need to understand a bit about how a Merkle tree, or more generally, binary trees, can be traversed.
In a binary tree, nodes can be traversed breadth-first or depth-first.
Breadth-first traversal would go level by level like in <a href="#bread_first_ordering">Breadth-first ordering</a>.</p>
</div>
<div id="bread_first_ordering" class="imageblock">
<div class="content">
<img src="./images/prbc_1103.png" alt="Breadth First">
</div>
<div class="title">Figure 124. Breadth-first ordering</div>
</div>
<div class="paragraph">
<p>The breadth-first ordering starts at the root and goes from root to leaves, level by level, left to right.</p>
</div>
<div class="paragraph">
<p>Depth-first ordering is a bit different and looks like <a href="#depth_first_ordering">Depth-first ordering</a>.</p>
</div>
<div id="depth_first_ordering" class="imageblock">
<div class="content">
<img src="./images/prbc_1104.png" alt="Depth First">
</div>
<div class="title">Figure 125. Depth-first ordering</div>
</div>
<div class="paragraph">
<p>The depth-first ordering starts at the root and traverses the left side at each node before the right side.</p>
</div>
<div class="paragraph">
<p>In a proof of inclusion (see <a href="#merkle_proof_two">Merkle proof</a>), the full node sends the green boxes, H<sub>K</sub> and H<sub>N</sub>, along with the blue boxes, H<sub>ABCDEFGH</sub>, H<sub>IJ</sub>, H<sub>L</sub>, H<sub>M</sub> and H<sub>OP</sub>.
The location of each hash is reconstructed using depth-first ordering from some flags.
The process of reconstructing the tree, namely the dotted-edged boxes in <a href="#merkle_proof_two">Merkle proof</a>, is described next.</p>
</div>
<div id="merkle_proof_two" class="imageblock">
<div class="content">
<img src="./images/prbc_1102.png" alt="Merkle proof">
</div>
<div class="title">Figure 126. Merkle proof</div>
</div>
<div class="sect3">
<h4 id="_merkle_tree_structure">Merkle Tree Structure</h4>
<div class="paragraph">
<p>The first thing a light client does is create the general structure of the Merkle tree.
Because Merkle trees are built from the leaves upward, the only thing a light client needs is the number of leaves that exist to know the structure.
The tree from <a href="#merkle_proof_two">Merkle proof</a> has 16 leaves.
A light client can create the empty Merkle tree like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; import math
&gt;&gt;&gt; total = 16
&gt;&gt;&gt; max_depth = math.ceil(math.log(total, 2))  # <b class="conum">(1)</b>
&gt;&gt;&gt; merkle_tree = []  # <b class="conum">(2)</b>
&gt;&gt;&gt; for depth in range(max_depth + 1):  # <b class="conum">(3)</b>
...     num_items = math.ceil(total / 2**(max_depth - depth))  # <b class="conum">(4)</b>
...     level_hashes = [None] * num_items  # <b class="conum">(5)</b>
...     merkle_tree.append(level_hashes)  # <b class="conum">(6)</b>
&gt;&gt;&gt; for level in merkle_tree:
...     print(level)
[None]
[None, None]
[None, None, None, None]
[None, None, None, None, None, None, None, None]
[None, None, None, None, None, None, None, None, None, None, None, None, None,\
 None, None, None]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Since we halve at every level, log<sub>2</sub> of the number of leaves is how many levels there are in the Merkle tree.
Note we round up using <code>math.ceil</code> as we round up for halving at each level.
We could also be clever and use <code>len(bin(total))-2</code>.</p>
</li>
<li>
<p>The Merkle tree will hold the root level at index 0, the level below at index 1, and so on.
In other words, the index is the "depth" from the top.</p>
</li>
<li>
<p>There are levels 0 to <code>max_depth</code> in this Merkle tree.</p>
</li>
<li>
<p>At any particular level, the number of nodes is the number of total leaves divided by 2 for every level above the leaf level.</p>
</li>
<li>
<p>We don&#8217;t know yet what any of the hashes are, so we set them to <code>None</code>.</p>
</li>
<li>
<p>Note <code>merkle_tree</code> is a list of lists of hashes, or a two-dimensional array.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_10">Exercise 5</h4>
<div class="paragraph">
<p>Create an empty Merkle Tree with 27 items and print each level.</p>
</div>
</div>
<div class="sect3">
<h4 id="_coding_a_merkle_tree">Coding a Merkle Tree</h4>
<div class="paragraph">
<p>We can now create a <code>MerkleTree</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleTree:

    def __init__(self, total):
        self.total = total
        self.max_depth = math.ceil(math.log(self.total, 2))
        self.nodes = []
        for depth in range(self.max_depth + 1):
            num_items = math.ceil(self.total / 2**(self.max_depth - depth))
            level_hashes = [None] * num_items
            self.nodes.append(level_hashes)
        self.current_depth = 0  # <b class="conum">(1)</b>
        self.current_index = 0

    def __repr__(self):  # <b class="conum">(2)</b>
        result = []
        for depth, level in enumerate(self.nodes):
            items = []
            for index, h in enumerate(level):
                if h is None:
                    short = 'None'
                else:
                    short = '{}...'.format(h.hex()[:8])
                if depth == self.current_depth and index == self.current_index:
                    items.append('*{}*'.format(short[:-2]))
                else:
                    items.append('{}'.format(short))
            result.append(', '.join(items))
        return '\n'.join(result)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We keep a pointer to a particular node in the tree, which will come in handy later.</p>
</li>
<li>
<p>We print a representation of the tree.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now that we have an empty tree, we can go about filling it to calculate the Merkle root.
If we had every leaf hash, getting the Merkle root would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from merkleblock import MerkleTree
&gt;&gt;&gt; from helper import merkle_parent_level
&gt;&gt;&gt; hex_hashes = [
...     "9745f7173ef14ee4155722d1cbf13304339fd00d900b759c6f9d58579b5765fb",
...     "5573c8ede34936c29cdfdfe743f7f5fdfbd4f54ba0705259e62f39917065cb9b",
...     "82a02ecbb6623b4274dfcab82b336dc017a27136e08521091e443e62582e8f05",
...     "507ccae5ed9b340363a0e6d765af148be9cb1c8766ccc922f83e4ae681658308",
...     "a7a4aec28e7162e1e9ef33dfa30f0bc0526e6cf4b11a576f6c5de58593898330",
...     "bb6267664bd833fd9fc82582853ab144fece26b7a8a5bf328f8a059445b59add",
...     "ea6d7ac1ee77fbacee58fc717b990c4fcccf1b19af43103c090f601677fd8836",
...     "457743861de496c429912558a106b810b0507975a49773228aa788df40730d41",
...     "7688029288efc9e9a0011c960a6ed9e5466581abf3e3a6c26ee317461add619a",
...     "b1ae7f15836cb2286cdd4e2c37bf9bb7da0a2846d06867a429f654b2e7f383c9",
...     "9b74f89fa3f93e71ff2c241f32945d877281a6a50a6bf94adac002980aafe5ab",
...     "b3a92b5b255019bdaf754875633c2de9fec2ab03e6b8ce669d07cb5b18804638",
...     "b5c0b915312b9bdaedd2b86aa2d0f8feffc73a2d37668fd9010179261e25e263",
...     "c9d52c5cb1e557b92c84c52e7c4bfbce859408bedffc8a5560fd6e35e10b8800",
...     "c555bc5fc3bc096df0a0c9532f07640bfb76bfe4fc1ace214b8b228a1297a4c2",
...     "f9dbfafc3af3400954975da24eb325e326960a25b87fffe23eef3e7ed2fb610e",
... ]
&gt;&gt;&gt; tree = MerkleTree(len(hex_hashes))
&gt;&gt;&gt; tree.nodes[4] = [bytes.fromhex(h) for h in hex_hashes]
&gt;&gt;&gt; tree.nodes[3] = merkle_parent_level(tree.nodes[4])
&gt;&gt;&gt; tree.nodes[2] = merkle_parent_level(tree.nodes[3])
&gt;&gt;&gt; tree.nodes[1] = merkle_parent_level(tree.nodes[2])
&gt;&gt;&gt; tree.nodes[0] = merkle_parent_level(tree.nodes[1])
&gt;&gt;&gt; print(tree)
*597c4baf.*
6382df3f..., 87cf8fa3...
3ba6c080..., 8e894862..., 7ab01bb6..., 3df760ac...
272945ec..., 9a38d037..., 4a64abd9..., ec7c95e1..., 3b67006c..., 850683df..., \
d40d268b..., 8636b7a3...
9745f717..., 5573c8ed..., 82a02ecb..., 507ccae5..., a7a4aec2..., bb626766..., \
ea6d7ac1..., 45774386..., 76880292..., b1ae7f15..., 9b74f89f..., b3a92b5b..., \
b5c0b915..., c9d52c5c..., c555bc5f..., f9dbfafc...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This fills the tree and gets us the Merkle root.
However, the message from the network may not be giving us all of the leaves.
The message might contain some internal nodes as well.
We need a cleverer way to fill the tree.</p>
</div>
<div class="paragraph">
<p><em>Tree traversal</em> is going to be the way we do this.
We can do a depth-first traversal and only fill in the nodes that we can calculate.
To traverse, we need to keep track of where exactly in the tree we are.
The properties <code>self.current_depth</code> and <code>self.current_index</code> do this.</p>
</div>
<div class="paragraph">
<p>We need methods to traverse the Merkle tree.
We&#8217;ll also include other useful methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleTree:
...
    def up(self):
        self.current_depth -= 1
        self.current_index //= 2

    def left(self):
        self.current_depth += 1
        self.current_index *= 2

    def right(self):
        self.current_depth += 1
        self.current_index = self.current_index * 2 + 1

    def root(self):
        return self.nodes[0][0]

    def set_current_node(self, value):  # <b class="conum">(1)</b>
        self.nodes[self.current_depth][self.current_index] = value

    def get_current_node(self):
        return self.nodes[self.current_depth][self.current_index]

    def get_left_node(self):
        return self.nodes[self.current_depth + 1][self.current_index * 2]

    def get_right_node(self):
        return self.nodes[self.current_depth + 1][self.current_index * 2 + 1]

    def is_leaf(self):  # <b class="conum">(2)</b>
        return self.current_depth == self.max_depth

    def right_exists(self):  # <b class="conum">(3)</b>
        return len(self.nodes[self.current_depth + 1]) &gt; \
            self.current_index * 2 + 1</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We want the ability to set the current node in the tree to some value.</p>
</li>
<li>
<p>We want to know if we are a leaf node.</p>
</li>
<li>
<p>In certain situations, we won&#8217;t have a right child because we may be at the furthest-right node of a level whose child level has an odd number of items.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We have Merkle tree traversal methods <code>left</code>, <code>right</code>, and <code>up</code>.
Let&#8217;s use these methods to populate the tree via depth-first traversal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from merkleblock import MerkleTree
&gt;&gt;&gt; from helper import merkle_parent
&gt;&gt;&gt; hex_hashes = [
...     "9745f7173ef14ee4155722d1cbf13304339fd00d900b759c6f9d58579b5765fb",
...     "5573c8ede34936c29cdfdfe743f7f5fdfbd4f54ba0705259e62f39917065cb9b",
...     "82a02ecbb6623b4274dfcab82b336dc017a27136e08521091e443e62582e8f05",
...     "507ccae5ed9b340363a0e6d765af148be9cb1c8766ccc922f83e4ae681658308",
...     "a7a4aec28e7162e1e9ef33dfa30f0bc0526e6cf4b11a576f6c5de58593898330",
...     "bb6267664bd833fd9fc82582853ab144fece26b7a8a5bf328f8a059445b59add",
...     "ea6d7ac1ee77fbacee58fc717b990c4fcccf1b19af43103c090f601677fd8836",
...     "457743861de496c429912558a106b810b0507975a49773228aa788df40730d41",
...     "7688029288efc9e9a0011c960a6ed9e5466581abf3e3a6c26ee317461add619a",
...     "b1ae7f15836cb2286cdd4e2c37bf9bb7da0a2846d06867a429f654b2e7f383c9",
...     "9b74f89fa3f93e71ff2c241f32945d877281a6a50a6bf94adac002980aafe5ab",
...     "b3a92b5b255019bdaf754875633c2de9fec2ab03e6b8ce669d07cb5b18804638",
...     "b5c0b915312b9bdaedd2b86aa2d0f8feffc73a2d37668fd9010179261e25e263",
...     "c9d52c5cb1e557b92c84c52e7c4bfbce859408bedffc8a5560fd6e35e10b8800",
...     "c555bc5fc3bc096df0a0c9532f07640bfb76bfe4fc1ace214b8b228a1297a4c2",
...     "f9dbfafc3af3400954975da24eb325e326960a25b87fffe23eef3e7ed2fb610e",
... ]
&gt;&gt;&gt; tree = MerkleTree(len(hex_hashes))
&gt;&gt;&gt; tree.nodes[4] = [bytes.fromhex(h) for h in hex_hashes]
&gt;&gt;&gt; while tree.root() is None:  # <b class="conum">(1)</b>
...     if tree.is_leaf():  # <b class="conum">(2)</b>
...         tree.up()
...     else:
...         left_hash = tree.get_left_node()
...         right_hash = tree.get_right_node()
...         if left_hash is None:  # <b class="conum">(3)</b>
...             tree.left()
...         elif right_hash is None:  # <b class="conum">(4)</b>
...             tree.right()
...         else:  # <b class="conum">(5)</b>
...             tree.set_current_node(merkle_parent(left_hash, right_hash))
...             tree.up()
&gt;&gt;&gt; print(tree)
597c4baf...
6382df3f..., 87cf8fa3...
3ba6c080..., 8e894862..., 7ab01bb6..., 3df760ac...
272945ec..., 9a38d037..., 4a64abd9..., ec7c95e1..., 3b67006c..., 850683df..., \
d40d268b..., 8636b7a3...
9745f717..., 5573c8ed..., 82a02ecb..., 507ccae5..., a7a4aec2..., bb626766..., \
ea6d7ac1..., 45774386..., 76880292..., b1ae7f15..., 9b74f89f..., b3a92b5b..., \
b5c0b915..., c9d52c5c..., c555bc5f..., f9dbfafc...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We traverse until we calculate the Merkle root.
Each time through the loop, we are at a particular node.</p>
</li>
<li>
<p>If we are at a leaf node, we already have that hash, so we don&#8217;t need to do anything but go back up.</p>
</li>
<li>
<p>If we don&#8217;t have the left hash, then we calculate the value first before calculating the current node&#8217;s hash.</p>
</li>
<li>
<p>If we don&#8217;t have the right hash, we calculate the value before calculating the current node&#8217;s hash.
Note that we already have the left one due to the depth-first traversal.</p>
</li>
<li>
<p>We have both the left and the right hash, so we calculate the Merkle parent value and set that to the current node.
Once set, we can go back up.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This code will only work when the number of leaves is a power of two, as edge cases where there are an odd number of nodes on a level are not handled.</p>
</div>
<div class="paragraph">
<p>We handle the case where the parent is the parent of the rightmost node on a level with an odd number of nodes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from merkleblock import MerkleTree
&gt;&gt;&gt; from helper import merkle_parent
&gt;&gt;&gt; hex_hashes = [
...     "9745f7173ef14ee4155722d1cbf13304339fd00d900b759c6f9d58579b5765fb",
...     "5573c8ede34936c29cdfdfe743f7f5fdfbd4f54ba0705259e62f39917065cb9b",
...     "82a02ecbb6623b4274dfcab82b336dc017a27136e08521091e443e62582e8f05",
...     "507ccae5ed9b340363a0e6d765af148be9cb1c8766ccc922f83e4ae681658308",
...     "a7a4aec28e7162e1e9ef33dfa30f0bc0526e6cf4b11a576f6c5de58593898330",
...     "bb6267664bd833fd9fc82582853ab144fece26b7a8a5bf328f8a059445b59add",
...     "ea6d7ac1ee77fbacee58fc717b990c4fcccf1b19af43103c090f601677fd8836",
...     "457743861de496c429912558a106b810b0507975a49773228aa788df40730d41",
...     "7688029288efc9e9a0011c960a6ed9e5466581abf3e3a6c26ee317461add619a",
...     "b1ae7f15836cb2286cdd4e2c37bf9bb7da0a2846d06867a429f654b2e7f383c9",
...     "9b74f89fa3f93e71ff2c241f32945d877281a6a50a6bf94adac002980aafe5ab",
...     "b3a92b5b255019bdaf754875633c2de9fec2ab03e6b8ce669d07cb5b18804638",
...     "b5c0b915312b9bdaedd2b86aa2d0f8feffc73a2d37668fd9010179261e25e263",
...     "c9d52c5cb1e557b92c84c52e7c4bfbce859408bedffc8a5560fd6e35e10b8800",
...     "c555bc5fc3bc096df0a0c9532f07640bfb76bfe4fc1ace214b8b228a1297a4c2",
...     "f9dbfafc3af3400954975da24eb325e326960a25b87fffe23eef3e7ed2fb610e",
...     "38faf8c811988dff0a7e6080b1771c97bcc0801c64d9068cffb85e6e7aacaf51",
... ]
&gt;&gt;&gt; tree = MerkleTree(len(hex_hashes))
&gt;&gt;&gt; tree.nodes[5] = [bytes.fromhex(h) for h in hex_hashes]
&gt;&gt;&gt; while tree.root() is None:
...     if tree.is_leaf():
...         tree.up()
...     else:
...         left_hash = tree.get_left_node()
...         if left_hash is None:  # <b class="conum">(1)</b>
...             tree.left()
...         elif tree.right_exists():  # <b class="conum">(2)</b>
...             right_hash = tree.get_right_node()
...             if right_hash is None:  # <b class="conum">(3)</b>
...                 tree.right()
...             else:  # <b class="conum">(4)</b>
...                 tree.set_current_node(merkle_parent(left_hash, right_hash))
...                 tree.up()
...         else:  # <b class="conum">(5)</b>
...             tree.set_current_node(merkle_parent(left_hash, left_hash))
...             tree.up()
&gt;&gt;&gt; print(tree)
0a313864...
597c4baf..., 6f8a8190...
6382df3f..., 87cf8fa3..., 5647f416...
3ba6c080..., 8e894862..., 7ab01bb6..., 3df760ac..., 28e93b98...
272945ec..., 9a38d037..., 4a64abd9..., ec7c95e1..., 3b67006c..., 850683df..., \
d40d268b..., 8636b7a3..., ce26d40b...
9745f717..., 5573c8ed..., 82a02ecb..., 507ccae5..., a7a4aec2..., bb626766..., \
ea6d7ac1..., 45774386..., 76880292..., b1ae7f15..., 9b74f89f..., b3a92b5b..., \
b5c0b915..., c9d52c5c..., c555bc5f..., f9dbfafc..., 38faf8c8...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If we don&#8217;t have the left node&#8217;s value, we traverse to the left node, since all internal nodes are guaranteed a left child.</p>
</li>
<li>
<p>We check first if this node has a right child.
This is true unless this node happens to be the rightmost node and the child level has an odd number of nodes.</p>
</li>
<li>
<p>If we don&#8217;t have the right node&#8217;s value, we traverse to that node.</p>
</li>
<li>
<p>If we have both the left and the right node&#8217;s values, we calculate the current node&#8217;s value using <code>merkle_parent</code>.</p>
</li>
<li>
<p>We have the left node&#8217;s value, but the right child doesn&#8217;t exist.
This is the rightmost node of this level, so we combine the left value twice.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can now traverse the tree for the number of leaves that aren&#8217;t powers of two.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_merkleblock_command">The merkleblock Command</h4>
<div class="paragraph">
<p>The full node communicating a Merkle block sends all the information needed to verify that the interesting transaction is in the Merkle tree.
The <code>merkleblock</code> network command is what communicates this information; it looks like <a href="#parsed_merkleblock">Parsed merkleblock</a>.</p>
</div>
<div id="parsed_merkleblock" class="imageblock">
<div class="content">
<img src="./images/prbc_1106.png" alt="merkleblock command">
</div>
<div class="title">Figure 127. Parsed merkleblock</div>
</div>
<div class="paragraph">
<p>The first six fields are exactly the same as the block header from <a href="#chapter_blocks">Blocks</a>.
The last four fields are the proof of inclusion.</p>
</div>
<div class="paragraph">
<p>The number of transactions field indicates how many leaves this particular Merkle tree will have.
This allows a light client to construct an empty Merkle tree.
The hashes field holds the blue and green boxes from <a href="#merkle_proof_two">Merkle proof</a>.
Since the number of hashes in the hashes field is not fixed, it&#8217;s prefixed with how many there are.
Last, the flags field gives information about where the hashes go within the Merkle tree.
The flags are parsed using <code>bytes_to_bits_field</code> to convert them to a list of bits (1&#8217;s and 0&#8217;s):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def bytes_to_bit_field(some_bytes):
    flag_bits = []
    for byte in some_bytes:
        for _ in range(8):
            flag_bits.append(byte &amp; 1)
            byte &gt;&gt;= 1
    return flag_bits</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ordering for the bytes is a bit strange, but it&#8217;s meant to be easy to convert into the flag bits needed to reconstruct the Merkle root.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_8">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>parse</code> method for <code>MerkleBlock</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_flag_bits_and_hashes">Using Flag Bits and Hashes</h4>
<div class="paragraph">
<p>The flag bits inform where the hashes go using depth-first ordering.</p>
</div>
<div class="paragraph">
<p>The rules for the flag bits are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the node&#8217;s value is given in the hashes field (blue box in <a href="#processing_a_merkle_block">Processing a Merkle block</a>), the flag bit is 0.</p>
</li>
<li>
<p>If the node is an internal node and the value is to be calculated by the light client (dotted outline in <a href="#processing_a_merkle_block">Processing a Merkle block</a>), the flag bit is 1.</p>
</li>
<li>
<p>If the node is a leaf node and is a transaction of interest (green box in <a href="#processing_a_merkle_block">Processing a Merkle block</a>), the flag is 1 and the node&#8217;s value is also given in the hashes field.
These are the items proven to be included in the Merkle tree.</p>
</li>
</ol>
</div>
<div id="processing_a_merkle_block" class="imageblock">
<div class="content">
<img src="./images/prbc_1107.png" alt="Merkle Blocks and Hashes">
</div>
<div class="title">Figure 128. Processing a Merkle block</div>
</div>
<div class="paragraph">
<p>Given the tree from <a href="#processing_a_merkle_block">Processing a Merkle block</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The flag bit is 1 for the root node (1), since that hash is calculated by the light client.</p>
</li>
<li>
<p>The left child, H<sub>ABCDEFGH</sub> (2), is included in the hashes field, so the flag is 0.</p>
</li>
<li>
<p>From here, we traverse to H<sub>IJKLMNOP</sub> (3) instead of H<sub>ABCD</sub> or H<sub>EFGH</sub> since H<sub>ABCDEFGH</sub> represents both those nodes and we don&#8217;t need them.</p>
</li>
<li>
<p>The right child, H<sub>IJKLMNOP</sub>, is also calculated, so it has a flag bit of 1.</p>
</li>
<li>
<p>To calculate H<sub>IJKLMNOP</sub>, we need the values for H<sub>IJKL</sub> and H<sub>MNOP</sub> (9). The next node in depth-first order is the left child, H<sub>IJKL</sub> (4), which is where we traverse to next.</p>
</li>
<li>
<p>H<sub>IJKL</sub> is an internal node that&#8217;s calculated, so the flag bit is 1.</p>
</li>
<li>
<p>From here, we traverse to its left child, H<sub>IJ</sub> (5).
We will be traversing to H<sub>KL</sub> (6) when we come back to this node.</p>
</li>
<li>
<p>H<sub>IJ</sub> is next in depth-first ordering; its hash is included in the hashes list and the flag is 0.</p>
</li>
<li>
<p>H<sub>KL</sub> is an internal, calculated node, so the flag is 1.</p>
</li>
<li>
<p>H<sub>K</sub> (7) is a leaf node whose presence in the block is being proved, so the flag is 1.</p>
</li>
<li>
<p>H<sub>L</sub> (8) is a node whose value is included in the hashes field, so the flag is 0.</p>
</li>
<li>
<p>We traverse up to H<sub>KL</sub>, whose value can now be calculated since H<sub>K</sub> and H<sub>L</sub> are known.</p>
</li>
<li>
<p>We traverse up to H<sub>IJKL</sub>, whose value can now be calculated since H<sub>IJ</sub> and H<sub>KL</sub> are known.</p>
</li>
<li>
<p>We traverse up to H<sub>IJKLMNOP</sub>, whose value we can&#8217;t calculate yet since we haven&#8217;t been to H<sub>MNOP</sub>.</p>
</li>
<li>
<p>We traverse to H<sub>MNOP</sub>, which is another internal node, so the flag is 1.</p>
</li>
<li>
<p>H<sub>MN</sub> (10) is another internal node that&#8217;s calculated, so the flag is 1.</p>
</li>
<li>
<p>H<sub>M</sub> (11) is a node whose value is included in the hashes field, so the flag is 0.</p>
</li>
<li>
<p>H<sub>N</sub> (12) is of interest, so the flag is 1 and its value is in the hashes field.</p>
</li>
<li>
<p>We traverse up to H<sub>MN</sub>, whose value can now be calculated.</p>
</li>
<li>
<p>We traverse up again to H<sub>MNOP</sub>, whose value cannot be calculated because we haven&#8217;t been to H<sub>OP</sub> yet.</p>
</li>
<li>
<p>H<sub>OP</sub> (13) is given, so the flag is 1 and its hash is the final hash in the hashes field.</p>
</li>
<li>
<p>We traverse to H<sub>MNOP</sub>, which can now be calculated.</p>
</li>
<li>
<p>We traverse to H<sub>IJKLMNOP</sub>, which can now be calculated.</p>
</li>
<li>
<p>Finally, we traverse to H<sub>ABCDEFGHIJKLMNOP</sub>, which is the Merkle root, and calculate it!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The flag bits for nodes (1) through (13) are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>There should be seven hashes in the hashes field, in this order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>H<sub>ABCDEFGH</sub></p>
</li>
<li>
<p>H<sub>IJ</sub></p>
</li>
<li>
<p>H<sub>K</sub></p>
</li>
<li>
<p>H<sub>L</sub></p>
</li>
<li>
<p>H<sub>M</sub></p>
</li>
<li>
<p>H<sub>N</sub></p>
</li>
<li>
<p>H<sub>OP</sub></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Notice that every letter is represented in the hashes, A to P.
This information is sufficient to prove that H<sub>K</sub> and H<sub>N</sub> (the green boxes in <a href="#processing_a_merkle_block">Processing a Merkle block</a>) are included in the block.</p>
</div>
<div class="paragraph">
<p>As you can see from <a href="#processing_a_merkle_block">Processing a Merkle block</a>, the flag bits are given in depth-first order.
Anytime we&#8217;re given a hash, as with H<sub>ABCDEFGH</sub>, we skip its children and continue.
In the case of H<sub>ABCDEFGH</sub>, we traverse to H<sub>IJKLMNOP</sub> instead of H<sub>ABCD</sub>.
Flag bits are a clever mechanism to encode which nodes have which hash value.</p>
</div>
<div class="paragraph">
<p>We can now populate the Merkle tree and calculate the root, given the appropriate flag bits and hashes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleTree:
...
    def populate_tree(self, flag_bits, hashes):
        while self.root() is None:  # <b class="conum">(1)</b>
            if self.is_leaf():  # <b class="conum">(2)</b>
                flag_bits.pop(0)  # <b class="conum">(3)</b>
                self.set_current_node(hashes.pop(0))  # <b class="conum">(4)</b>
                self.up()
            else:
                left_hash = self.get_left_node()
                if left_hash is None:  # <b class="conum">(5)</b>
                    if flag_bits.pop(0) == 0:  # <b class="conum">(6)</b>
                        self.set_current_node(hashes.pop(0))
                        self.up()
                    else:
                        self.left()  # <b class="conum">(7)</b>
                elif self.right_exists():  # <b class="conum">(8)</b>
                    right_hash = self.get_right_node()
                    if right_hash is None:  # <b class="conum">(9)</b>
                        self.right()
                    else:  # <b class="conum">(10)</b>
                        self.set_current_node(merkle_parent(left_hash,
                        right_hash))
                        self.up()
                else:  # <b class="conum">(11)</b>
                    self.set_current_node(merkle_parent(left_hash, left_hash))
                    self.up()
        if len(hashes) != 0:  # <b class="conum">(12)</b>
            raise RuntimeError('hashes not all consumed {}'.format(len(hashes)))
        for flag_bit in flag_bits:  # <b class="conum">(13)</b>
            if flag_bit != 0:
                raise RuntimeError('flag bits not all consumed')</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The point of populating this Merkle tree is to calculate the root.
Each loop iteration processes one node until the root is calculated.</p>
</li>
<li>
<p>For leaf nodes, we are always given the hash.</p>
</li>
<li>
<p><code>flag_bits.pop(0)</code> is a way in Python to dequeue the next flag bit.
We may want to keep track of which hashes are of interest to us by looking at the flag bit, but for now, we don&#8217;t do this.</p>
</li>
<li>
<p><code>hashes.pop(0)</code> is how we get the next hash from the hashes field.
We need to set the current node to that hash.</p>
</li>
<li>
<p>If we don&#8217;t have the left child value, there are two possibilities.
This node&#8217;s value may be in the hashes field, or it might need calculation.</p>
</li>
<li>
<p>The next flag bit tells us whether we need to calculate this node or not.
If the flag bit is 0, the next hash in the hashes field is this node&#8217;s value.
If the flag bit is 1, we need to calculate the left (and possibly the right) node&#8217;s value.</p>
</li>
<li>
<p>We are guaranteed that there&#8217;s a left child, so we traverse to that node and get its value.</p>
</li>
<li>
<p>We check that the right node exists.</p>
</li>
<li>
<p>We have the left hash, but not the right.
We traverse to the right node to get its value.</p>
</li>
<li>
<p>We have both the left and the right node&#8217;s values, so we calculate their Merkle parent to get the current node&#8217;s value.</p>
</li>
<li>
<p>We have the left node&#8217;s value, but the right does not exist.
In this case, according to Merkle tree rules, we calculate the Merkle parent of the left node twice.</p>
</li>
<li>
<p>All hashes must be consumed or we got bad data.</p>
</li>
<li>
<p>All flag bits must be consumed or we got bad data.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_6">Exercise 7</h4>
<div class="paragraph">
<p>Write the <code>is_valid</code> method for <code>MerkleBlock</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_11">Conclusion</h3>
<div class="paragraph">
<p>Simplified payment verification is useful but not without some significant downsides.
The full details are outside the scope of this book, but despite the programming being pretty straightforward, most light wallets do not use SPV and instead trust data from the wallet vendor servers.
The main drawback of SPV is that the nodes you are connecting to know something about the transactions you are interested in.
That is, you lose some privacy by using SPV.
This will be covered in more detail in <a href="#chapter_bloom_filters">Bloom Filters</a> as we make Bloom filters to tell nodes what transactions we are interested in.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_bloom_filters">Bloom Filters</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>In <a href="#chapter_spv">Simplified Payment Verification</a> we learned how to validate a Merkle block.
A full node can provide a proof of inclusion for transactions of interest through the <code>merkleblock</code> command.
But how does the full node know which transactions are of interest?</p>
</div>
<div class="paragraph">
<p>A light client could tell the full node its addresses (or ScriptPubKeys).
The full node can check for transactions that are relevant to these addresses, but that would be compromising the light client&#8217;s privacy.
A light client wouldn&#8217;t want to reveal, for example, that it has 1,000 BTC to a full node.
Privacy leaks are security leaks, and in Bitcoin, it&#8217;s generally a good idea to not leak any privacy whenever possible.</p>
</div>
<div class="paragraph">
<p>One solution is for the light client to tell the full node enough information to create a <em>superset</em> of all transactions of interest.
To create this superset, we use what&#8217;s called a <em>Bloom filter</em>.</p>
</div>
<div class="sect2">
<h3 id="_what_is_a_bloom_filter">What Is a Bloom Filter?</h3>
<div class="paragraph">
<p>A Bloom filter is a filter for all possible transactions.
Full nodes run transactions through a Bloom filter and send <code>merkleblock</code> commands for transactions that make it through.</p>
</div>
<div class="paragraph">
<p>Suppose there are 50 total transactions.
There is one transaction a light client is interested in.
The light client wants to "hide" the transaction among a group of five transactions.
This requires a function that groups the 50 transactions into 10 different buckets, and the full node can then send a single bucket of transactions, in a manner of speaking.
This grouping would have to be <em>deterministic</em>—that is, be the same each time.
How can this be accomplished?</p>
</div>
<div class="paragraph">
<p>The solution is to use a hash function to get a deterministic number and modulo to organize transactions into buckets.</p>
</div>
<div class="paragraph">
<p>A Bloom filter is a computer science structure that can be used on any data in a set, so suppose that we have one item, "hello world", that we want to create a Bloom filter for.
We need a hash function, so we&#8217;ll use one we already have: hash256.
The process of figuring out what bucket our item goes into looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; bit_field_size = 10  # <b class="conum">(1)</b>
&gt;&gt;&gt; bit_field = [0] * bit_field_size
&gt;&gt;&gt; h = hash256(b'hello world')  # <b class="conum">(2)</b>
&gt;&gt;&gt; bit = int.from_bytes(h, 'big') % bit_field_size  # <b class="conum">(3)</b>
&gt;&gt;&gt; bit_field[bit] = 1  # <b class="conum">(4)</b>
&gt;&gt;&gt; print(bit_field)
[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Our <code>bit_field</code> is the list of "buckets," and we want there to be 10.</p>
</li>
<li>
<p>We hash the item with hash256.</p>
</li>
<li>
<p>We interpret this as a big-endian integer and modulo by 10 to determine the bucket this item belongs to.</p>
</li>
<li>
<p>We indicate the bucket we want in the Bloom filter.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Conceptually, what we just did looks like <a href="#ten_bit_bloom_filter_with_1_element">10-bit Bloom filter with one element</a>.</p>
</div>
<div id="ten_bit_bloom_filter_with_1_element" class="imageblock">
<div class="content">
<img src="./images/prbc_1201.png" alt="Simple Bloom filter">
</div>
<div class="title">Figure 129. 10-bit Bloom filter with one element</div>
</div>
<div class="paragraph">
<p>Our Bloom filter consists of:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The size of the bit field</p>
</li>
<li>
<p>The hash function used (and how we converted that to a number)</p>
</li>
<li>
<p>The bit field, which indicates the bucket we&#8217;re interested in</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This works great for a single item, so it would work for a single address/ScriptPubKey/transaction ID of interest.
What do we do when we&#8217;re interested in more than one item?</p>
</div>
<div class="paragraph">
<p>We can run a second item through the same filter and set that bit to 1 as well.
The full node can then send multiple buckets of transactions instead of a single bucket.
Let&#8217;s create a Bloom filter with two items, "hello world" and "goodbye", using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; bit_field_size = 10
&gt;&gt;&gt; bit_field = [0] * bit_field_size
&gt;&gt;&gt; for item in (b'hello world', b'goodbye'):  # <b class="conum">(1)</b>
...     h = hash256(item)
...     bit = int.from_bytes(h, 'big') % bit_field_size
...     bit_field[bit] = 1
&gt;&gt;&gt; print(bit_field)
[0, 0, 1, 0, 0, 0, 0, 0, 0, 1]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are creating a filter for two items here, but this can be extended to many more.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#ten_bit_bloom_filter_with_two_elements">10-bit Bloom filter with two elements</a> shows what this looks like conceptually.</p>
</div>
<div id="ten_bit_bloom_filter_with_two_elements" class="imageblock">
<div class="content">
<img src="./images/prbc_1202.png" alt="Two Item Bloom filter">
</div>
<div class="title">Figure 130. 10-bit Bloom filter with two elements</div>
</div>
<div class="paragraph">
<p>If the space of all possible items is 50, 10 items on average will make it through this filter instead of the 5 when we only had 1 item of interest, because 2 buckets are returned, not 1.</p>
</div>
<div class="sect3">
<h4 id="_exercise_1_12">Exercise 1</h4>
<div class="paragraph">
<p>Calculate the Bloom Filter for "hello world" and "goodbye" using the hash160 hash function over a bit field of 10.</p>
</div>
</div>
<div class="sect3">
<h4 id="_going_a_step_further">Going a Step Further</h4>
<div class="paragraph">
<p>Suppose that the space of all items is 1 million and we want bucket sizes to still be 5. We would need a Bloom filter that&#8217;s 1,000,000 / 5 = 200,000 bits long.
Each bucket would have on average 5 items and we would get 5 times the number of items we&#8217;re interested in, 20% of which would be items of interest.
200,000 bits is 25,000 bytes and is a lot to transmit.
Can we do better?</p>
</div>
<div class="paragraph">
<p>A Bloom filter using multiple hash functions can shorten the bit field considerably.
If we use 5 hash functions over a bit field of 32, we have 32!/(27!5!) ~ 200,000 possible 5-bit combinations in that 32-bit field.
Of 1 million possible items, 5 items on average should have that 5-bit combination.
Instead of transmitting 25K bytes, we can transmit just 32 bits, or 4 bytes!</p>
</div>
<div class="paragraph">
<p>Here&#8217;s what that would look like.
For simplicity, we stick to the same 10-bit field but still have two items of interest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import hash256, hash160
&gt;&gt;&gt; bit_field_size = 10
&gt;&gt;&gt; bit_field = [0] * bit_field_size
&gt;&gt;&gt; for item in (b'hello world', b'goodbye'):
...     for hash_function in (hash256, hash160):  # <b class="conum">(1)</b>
...         h = hash_function(item)
...         bit = int.from_bytes(h, 'big') % bit_field_size
...         bit_field[bit] = 1
&gt;&gt;&gt; print(bit_field)
[1, 1, 1, 0, 0, 0, 0, 0, 0, 1]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We iterate over two different hash functions (hash256 and hash160), but we could just as easily have more.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Conceptually, <a href="#ten_bit_bloom_filter_with_two_elements_and_two_hash_functions">10-bit Bloom filter with two elements and two hash functions</a> shows what the preceding code does.</p>
</div>
<div id="ten_bit_bloom_filter_with_two_elements_and_two_hash_functions" class="imageblock">
<div class="content">
<img src="./images/prbc_1203.png" alt="Multiple Hash Functions">
</div>
<div class="title">Figure 131. 10-bit Bloom filter with two elements and two hash functions</div>
</div>
<div class="paragraph">
<p>A Bloom filter can be optimized by changing the number of hash functions and bit field size to get a desirable false-positive rate.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bip0037_bloom_filters">BIP0037 Bloom Filters</h3>
<div class="paragraph">
<p>BIP0037 specifies Bloom filters in network communication. The information contained in a Bloom filter is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The size of the bit field, or how many buckets there are.
The size is specified in bytes (8 bits per byte) and rounded up if necessary.</p>
</li>
<li>
<p>The number of hash functions.</p>
</li>
<li>
<p>A "tweak" to be able to change the Bloom filter slightly if it hits too many items.</p>
</li>
<li>
<p>The bit field that results from running the Bloom filter over the items of interest.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>While we could define lots of hash functions (sha512, keccak384, ripemd160, blake256, etc.), in practice, we use a single hash function with a different seed.
This allows the implementation to be simpler.</p>
</div>
<div class="paragraph">
<p>The hash function we use is called <em>murmur3</em>.
Unlike sha256, murmur3 is not cryptographically secure, but it is much faster.
The task of filtering and getting a deterministic, evenly distributed modulo does not require cryptographic security but benefits from speed, so murmur3 is the appropriate tool for the job.
The seed formula is defined this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">i*0xfba4c795 + tweak</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fba4c795</code> is a constant for Bitcoin Bloom filters.
<code>i</code> is 0 for the first hash function, 1 for the second, 2 for the third, and so on.
The <code>tweak</code> is a bit of entropy that can be added if the results of of one tweak are not satisfactory.
The hash functions and the size of the bit field are used to calculate the bit field, which then gets transmitted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import murmur3  # <b class="conum">(1)</b>
&gt;&gt;&gt; from bloomfilter import BIP37_CONSTANT  # <b class="conum">(2)</b>
&gt;&gt;&gt; field_size = 2
&gt;&gt;&gt; num_functions = 2
&gt;&gt;&gt; tweak = 42
&gt;&gt;&gt; bit_field_size = field_size * 8
&gt;&gt;&gt; bit_field = [0] * bit_field_size
&gt;&gt;&gt; for phrase in (b'hello world', b'goodbye'):  # <b class="conum">(3)</b>
...     for i in range(num_functions):  # <b class="conum">(4)</b>
...         seed = i * BIP37_CONSTANT + tweak  # <b class="conum">(5)</b>
...         h = murmur3(phrase, seed=seed)  # <b class="conum">(6)</b>
...         bit = h % bit_field_size
...         bit_field[bit] = 1
&gt;&gt;&gt; print(bit_field)
[0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>murmur3</code> is implemented in pure Python in <em>helper.py</em>.</p>
</li>
<li>
<p><code>BIP37_CONSTANT</code> is the <code>fba4c795</code> number specified in BIP0037.</p>
</li>
<li>
<p>We iterate over some items of interest.</p>
</li>
<li>
<p>We use two hash functions.</p>
</li>
<li>
<p>This is the seed formula.</p>
</li>
<li>
<p>murmur3 returns a number, so we don&#8217;t have to do a conversion to an integer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This 2-byte Bloom filter has 4 bits set to 1 out of 16, so the probability of any random item passing through this filter is 1/4 &#215; 1/4 = 1/16.
If the space of all items numbers 160, a client will receive 10 items on average, 2 of which will be interesting.</p>
</div>
<div class="paragraph">
<p>We can start coding a <code>BloomFilter</code> class now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class BloomFilter:

    def __init__(self, size, function_count, tweak):
        self.size = size
        self.bit_field = [0] * (size * 8)
        self.function_count = function_count
        self.tweak = tweak</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_12">Exercise 2</h4>
<div class="paragraph">
<p>Given a Bloom Filter with <code>size=10</code>, <code>function_count=5</code>, <code>tweak=99</code>, what are the bytes that are set after adding these items? (Use <code>bit_field_to_bytes</code> to convert to bytes.)</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>b&#8217;Hello World'</code></p>
</li>
<li>
<p><code>b&#8217;Goodbye!'</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_12">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>add</code> method for <code>BloomFilter</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loading_a_bloom_filter">Loading a Bloom Filter</h3>
<div class="paragraph">
<p>Once a light client has created a Bloom filter, it needs to let the full node know the details of the filter so the full node can send proofs of inclusion.
The first thing a light client must do is set the optional relay flag in the version message (see <a href="#chapter_networking">Networking</a>) to 0.
This tells the full node not to send transaction messages unless they match a Bloom filter or they have been specifically requested.
After the relay flag, a light client then communicates to the full node the Bloom filter itself.
The command to set the Bloom filter is called <code>filterload</code>.
The payload looks like <a href="#parsed_filterload">Parsed filterload</a>.</p>
</div>
<div id="parsed_filterload" class="imageblock">
<div class="content">
<img src="./images/prbc_1204.png" alt="filterload Command">
</div>
<div class="title">Figure 132. Parsed filterload</div>
</div>
<div class="paragraph">
<p>The elements of a Bloom filter are encoded into bytes. The bit field, hash function count, and tweak are encoded in this message.
The last field, matched item flag, is a way of asking the full node to add any matched transactions to the Bloom filter.</p>
</div>
<div class="sect3">
<h4 id="_exercise_4_12">Exercise 4</h4>
<div class="paragraph">
<p>Write the  <code>filterload</code> method for the <code>BloomFilter</code> class.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getting_merkle_blocks">Getting Merkle Blocks</h3>
<div class="paragraph">
<p>There is one more command that a light client needs: Merkle block information about transactions of interest from the full node.
The <code>getdata</code> command is what communicates blocks and transactions.
The specific type of data that a light client will want from a full node is something called a <em>filtered block</em>.
A filtered block is asking for transactions that pass through the Bloom filter in the form of Merkle blocks.
In other words, the light client can ask for Merkle blocks whose transactions of interest match the Bloom filter.</p>
</div>
<div class="paragraph">
<p><a href="#parsed_getdata">Parsed getdata</a> depicts the payload for <code>getdata</code>.</p>
</div>
<div id="parsed_getdata" class="imageblock">
<div class="content">
<img src="./images/prbc_1205.png" alt="getdata Command">
</div>
<div class="title">Figure 133. Parsed getdata</div>
</div>
<div class="paragraph">
<p>The number of items as a varint specifies how many items we want.
Each item has a type.
A type value of 1 is a transaction (<a href="#chapter_tx_parsing">Transactions</a>), 2 is a normal block (<a href="#chapter_blocks">Blocks</a>), 3 is a Merkle block (<a href="#chapter_spv">Simplified Payment Verification</a>), and 4 is a compact block (not covered in this book).</p>
</div>
<div class="paragraph">
<p>We can create this message in <em>network.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class GetDataMessage:
    command = b'getdata'

    def __init__(self):
        self.data = []  # <b class="conum">(1)</b>

    def add_data(self, data_type, identifier):
        self.data.append((data_type, identifier))  # <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We store the items we want.</p>
</li>
<li>
<p>We add items to the message using the <code>add_data</code> method.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_5_11">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for the <code>GetDataMessage</code> class.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getting_transactions_of_interest">Getting Transactions of Interest</h3>
<div class="paragraph">
<p>A light client that loads a Bloom filter with a full node will get all the information needed to prove that transactions of interest are included in particular blocks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from bloomfilter import BloomFilter
&gt;&gt;&gt; from helper import decode_base58
&gt;&gt;&gt; from merkleblock import MerkleBlock
&gt;&gt;&gt; from network import FILTERED_BLOCK_DATA_TYPE, GetHeadersMessage, GetDataMe\
ssage, HeadersMessage, SimpleNode
&gt;&gt;&gt; from tx import Tx
&gt;&gt;&gt; last_block_hex = '00000000000538d5c2246336644f9a4956551afb44ba47278759ec55\
ea912e19'
&gt;&gt;&gt; address = 'mwJn1YPMq7y5F8J3LkC5Hxg9PHyZ5K4cFv'
&gt;&gt;&gt; h160 = decode_base58(address)
&gt;&gt;&gt; node = SimpleNode('testnet.programmingbitcoin.com', testnet=True, logging=\
False)
&gt;&gt;&gt; bf = BloomFilter(size=30, function_count=5, tweak=90210)  # <b class="conum">(1)</b>
&gt;&gt;&gt; bf.add(h160)  # <b class="conum">(2)</b>
&gt;&gt;&gt; node.handshake()
&gt;&gt;&gt; node.send(bf.filterload())  # <b class="conum">(3)</b>
&gt;&gt;&gt; start_block = bytes.fromhex(last_block_hex)
&gt;&gt;&gt; getheaders = GetHeadersMessage(start_block=start_block)
&gt;&gt;&gt; node.send(getheaders)  # <b class="conum">(4)</b>
&gt;&gt;&gt; headers = node.wait_for(HeadersMessage)
&gt;&gt;&gt; getdata = GetDataMessage()  # <b class="conum">(5)</b>
&gt;&gt;&gt; for b in headers.blocks:
...     if not b.check_pow():
...         raise RuntimeError('proof of work is invalid')
...     getdata.add_data(FILTERED_BLOCK_DATA_TYPE, b.hash())  # <b class="conum">(6)</b>
&gt;&gt;&gt; node.send(getdata)  # <b class="conum">(7)</b>
&gt;&gt;&gt; found = False
&gt;&gt;&gt; while not found:
...     message = node.wait_for(MerkleBlock, Tx)  # <b class="conum">(8)</b>
...     if message.command == b'merkleblock':
...         if not message.is_valid():  # <b class="conum">(9)</b>
...             raise RuntimeError('invalid merkle proof')
...     else:
...         for i, tx_out in enumerate(message.tx_outs):
...             if tx_out.script_pubkey.address(testnet=True) == address:  # <b class="conum">(10)</b>
...                 print('found: {}:{}'.format(message.id(), i))
...                 found = True
...                 break
found: e3930e1e566ca9b75d53b0eb9acb7607f547e1182d1d22bd4b661cfe18dcddf1:0</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are creating a Bloom filter that&#8217;s 30 bytes and uses 5 hash functions and a particularly popular '90s tweak.</p>
</li>
<li>
<p>We filter for the address above.</p>
</li>
<li>
<p>We send the <code>filterload</code> command from the Bloom filter we made.</p>
</li>
<li>
<p>We get the block headers after <code>last_block_hex</code>.</p>
</li>
<li>
<p>We create a getdata message for Merkle blocks that may have transactions of interest.</p>
</li>
<li>
<p>We request a Merkle block proving transactions of interest to us are included.
Most blocks will probably be complete misses.</p>
</li>
<li>
<p>The getdata message asks for 2,000 Merkle blocks after the block defined by <code>last_block_hex</code>.</p>
</li>
<li>
<p>We wait for the <code>merkleblock</code> command, which proves inclusion, and the <code>tx</code> command, which gives us the transaction of interest.</p>
</li>
<li>
<p>We check that the Merkle block proves transaction inclusion.</p>
</li>
<li>
<p>We&#8217;re looking for UTXOs for <code>address</code>, and we print to screen if we find one.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>What we&#8217;ve done is look at 2,000 blocks after a particular block for UTXOs corresponding to a particular address.
This is without the use of any block explorer, which preserves, to some degree, our privacy.</p>
</div>
<div class="sect3">
<h4 id="_exercise_6_9">Exercise 6</h4>
<div class="paragraph">
<p>Get the current testnet block ID, send yourself some testnet coins, find the UTXO corresponding to the testnet coins <em>without using a block explorer</em>, create a transaction using that UTXO as an input, and broadcast the tx message on the  testnet network.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_12">Conclusion</h3>
<div class="paragraph">
<p>In this chapter, we created everything necessary to connect peer to peer as a light client and ask for and receive the UTXOs necessary to construct a transaction, all while preserving some privacy by using a Bloom filter.</p>
</div>
<div class="paragraph">
<p>We now turn to Segwit, which is a new type of transaction that was activated in 2017.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_segwit">Segwit</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p><em>Segwit</em> stands for "segregated witness" and is a backward-compatible upgrade or "soft fork" that activated on the Bitcoin network in August 2017.
While the activation was controversial, the features of this technology require some explanation.
In this chapter, we&#8217;ll explore how Segwit works, why it&#8217;s backward compatible, and what Segwit enables.</p>
</div>
<div class="paragraph">
<p>As a brief overview, Segwit incorporated a multitude of changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Block size increase</p>
</li>
<li>
<p>Transaction malleability fix</p>
</li>
<li>
<p>Segwit versioning for clear upgrade paths</p>
</li>
<li>
<p>Quadratic hashing fix</p>
</li>
<li>
<p>Offline wallet fee calculation security</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s not entirely obvious what Segwit is without looking at how it&#8217;s implemented.
We&#8217;ll start by examining the most basic type of Segwit transaction, pay-to-witness-pubkey-hash.</p>
</div>
<div class="sect2">
<h3 id="_pay_to_witness_pubkey_hash_p2wpkh">Pay-to-Witness-Pubkey-Hash (p2wpkh)</h3>
<div class="paragraph">
<p>Pay-to-witness-pubkey-hash (p2wpkh) is one of four types of scripts defined by Segwit in BIP0141 and BIP0143.
This is a smart contract that acts a lot like pay-to-pubkey-hash and is named similarly for that reason.
The main change from p2pkh is that the data for the ScriptSig is now in the witness field.
The rearrangement is to fix transaction malleability.</p>
</div>
<div class="sect3">
<h4 id="_transaction_malleability">Transaction Malleability</h4>
<div class="paragraph">
<p><em>Transaction malleability</em> is the ability to change the transaction&#8217;s ID without altering the transaction&#8217;s meaning.
Mt. Gox CEO Mark Karpeles cited transaction malleability as the reason why his exchange was not allowing withdrawals back in 2013.</p>
</div>
<div class="paragraph">
<p>Malleability of the ID is an important consideration when creating payment channels, which are the atomic unit of the Lightning Network.
A malleable transaction ID makes the safe creation of payment channel transactions much more difficult.</p>
</div>
<div class="paragraph">
<p>The reason why transaction malleability is a problem at all is because the transaction ID is calculated from the entire transaction.
The ID of the transaction is the hash256 of the transaction.
Most of the fields in a transaction cannot be changed without invalidating the transaction&#8217;s signature (and thus the transaction itself), so from a malleability standpoint, these fields are not a problem.</p>
</div>
<div class="paragraph">
<p>The one field that does allow for some manipulation without invalidating the signature is the ScriptSig field on each input.
The ScriptSig is emptied before creating the signature hash (see <a href="#chapter_tx">Transaction Creation and Validation</a>), so it&#8217;s possible to change the ScriptSig without invalidating the signature.
Also, as we learned in <a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>, signatures contain a random component.
This means that two different ScriptSigs can essentially mean the same thing but be different byte-wise.</p>
</div>
<div class="paragraph">
<p>This makes the ScriptSig field <em>malleable</em>—that is, able to be changed without changing the meaning—and means that the entire transaction, and the transaction ID, are malleable.
A malleable transaction ID means that any <em>dependent</em> transactions (that is, any transaction spending one of the malleable transaction&#8217;s outputs) cannot be constructed in such a way as to guarantee validity.
The previous transaction hash is uncertain, so the dependent transaction&#8217;s transaction input field cannot be guaranteed to be valid.</p>
</div>
<div class="paragraph">
<p>This is not usually a problem as once a transaction enters the blockchain, the transaction ID is fixed and no longer malleable (at least without finding a proof-of-work!).
However, with payment channels, there are dependent transactions created <em>before</em> the funding transaction is added to the blockchain.</p>
</div>
</div>
<div class="sect3">
<h4 id="_fixing_malleability">Fixing Malleability</h4>
<div class="paragraph">
<p>Transaction malleability is fixed by emptying the ScriptSig field and putting the data in another field that&#8217;s not used for ID calculation.
For p2wpkh, the signature and pubkey are the items from ScriptSig, so those get moved to the witness field, which is not used for ID calculation.
This way, the transaction ID stays stable as the malleability vector disappears.
The witness field, and the whole Segwit serialization of a transaction, is only sent to nodes that ask for it.
In other words, old nodes that haven&#8217;t upgraded to Segwit don&#8217;t receive the witness field and don&#8217;t verify the pubkey and signature.</p>
</div>
<div class="paragraph">
<p>If this sounds familiar, it should.
This is similar to how p2sh works (<a href="#chapter_p2sh">Pay-to-Script Hash</a>) in that newer nodes do additional validation that older nodes do not, and is the basis for why Segwit is a soft fork (backward-compatible upgrade) and not a hard fork (backward-incompatible upgrade).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_p2wpkh_transactions">p2wpkh Transactions</h3>
<div class="paragraph">
<p>To understand Segwit, it helps to look at what a transaction looks like when sent to an old node (<a href="#pay_to_witness_pubkey_hash_as_seen_by_pre_bip0141_software">Pay-to-witness-pubkey-hash (p2wpkh) as seen by pre-BIP0141 software</a>) versus a new node (<a href="#pay_to_witness_pubkey_hash_as_seen_by_post_bip0141_software">Pay-to-witness-pubkey-hash (p2wpkh) as seen by post-BIP0141 software</a>).</p>
</div>
<div id="pay_to_witness_pubkey_hash_as_seen_by_pre_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1301.png" alt="p2wpkh to old nodes">
</div>
<div class="title">Figure 134. Pay-to-witness-pubkey-hash (p2wpkh) as seen by pre-BIP0141 software</div>
</div>
<div id="pay_to_witness_pubkey_hash_as_seen_by_post_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1302.png" alt="p2wpkh to new nodes">
</div>
<div class="title">Figure 135. Pay-to-witness-pubkey-hash (p2wpkh) as seen by post-BIP0141 software</div>
</div>
<div class="paragraph">
<p>The difference between these two serializations is that the latter transaction (Segwit serialization) has the marker, flag, and witness fields.
Otherwise, the two transactions look similar.
The reason the transaction ID is not malleable is because the first serialization is used for calculating the transaction ID.</p>
</div>
<div class="paragraph">
<p>The witness field in p2wpkh has the signature and pubkey as its two elements.
These will be used for validation for upgraded nodes only.</p>
</div>
<div class="paragraph">
<p>The ScriptPubKey for p2wpkh is <code>OP_0</code> <em>&lt;20-byte hash&gt;</em>.
The ScriptSig, as seen in both serializations, is empty.
The combined script is shown in <a href="#pay_to_witness_pubkey_hash_p2wpkh_scriptpubkey">Pay-to-witness-pubkey-hash (p2wpkh) ScriptPubKey</a>.</p>
</div>
<div id="pay_to_witness_pubkey_hash_p2wpkh_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_1303.png" alt="p2wpkh ScriptPubKey">
</div>
<div class="title">Figure 136. Pay-to-witness-pubkey-hash (p2wpkh) ScriptPubKey</div>
</div>
<div class="paragraph">
<p>The processing of the combined script starts like <a href="#p2wpkh_start">p2wpkh start</a>.</p>
</div>
<div id="p2wpkh_start" class="imageblock">
<div class="content">
<img src="./images/prbc_1304.png" alt="p2wpkh start">
</div>
<div class="title">Figure 137. p2wpkh start</div>
</div>
<div class="paragraph">
<p><code>OP_0</code> pushes a 0 to the stack (<a href="#p2wpkh_step_1">p2wpkh step 1</a>).</p>
</div>
<div id="p2wpkh_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_1305.png" alt="p2wpkh step 1">
</div>
<div class="title">Figure 138. p2wpkh step 1</div>
</div>
<div class="paragraph">
<p>The 20-byte hash is an element, so it&#8217;s pushed to the stack (<a href="#p2wpkh_step_2">p2wpkh step 2</a>).</p>
</div>
<div id="p2wpkh_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_1306.png" alt="p2wpkh step 2">
</div>
<div class="title">Figure 139. p2wpkh step 2</div>
</div>
<div class="paragraph">
<p>At this point, older nodes will stop as there are no more Script commands to be processed.
Since the top element is nonzero, this will be counted as a valid script.
This is very similar to p2sh (<a href="#chapter_p2sh">Pay-to-Script Hash</a>) in that older nodes cannot validate further.
Newer nodes, however, have a special Segwit rule much like the special rule for p2sh (see <a href="#chapter_p2sh">Pay-to-Script Hash</a>).
Recall that with p2sh, the exact script sequence of <em>&lt;RedeemScript&gt;</em> <code>OP_HASH160</code> <em>&lt;hash&gt;</em> <code>OP_EQUAL</code> triggers a special rule.</p>
</div>
<div class="paragraph">
<p>In the case of p2wpkh, the script sequence is <code>OP_0</code> <em>&lt;20-byte hash&gt;</em>.
When that script sequence is encountered, the pubkey and signature from the witness field and the 20-byte hash are added to the command set in exactly the same sequence as with p2pkh, namely <em>&lt;signature&gt;</em> <em>&lt;pubkey&gt;</em> <code>OP_DUP OP_HASH160</code> <em>&lt;20-byte hash&gt;</em> <code>OP_EQUALVERIFY OP_CHECKSIG</code>.
<a href="#p2wpkh_step_3">p2wpkh step 3</a> shows the state that is encountered next.</p>
</div>
<div id="p2wpkh_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_1307.png" alt="p2wpkh step 3">
</div>
<div class="title">Figure 140. p2wpkh step 3</div>
</div>
<div class="paragraph">
<p>The rest of the processing of p2wpkh is the same as the processing of p2pkh, as seen in <a href="#chapter_script">Script</a>.
The end state is a single 1 on the stack if and only if the 20-byte hash is the hash160 of the pubkey and the signature is valid (<a href="#p2wpkh_step_4">p2wpkh step 4</a>).</p>
</div>
<div id="p2wpkh_step_4" class="imageblock">
<div class="content">
<img src="./images/prbc_1308.png" alt="p2wpkh step 4">
</div>
<div class="title">Figure 141. p2wpkh step 4</div>
</div>
<div class="paragraph">
<p>For an older node, processing stops at <em>&lt;20-byte hash&gt;</em> 0, as older nodes don&#8217;t know the special Segwit rule.
Only upgraded nodes do the rest of the validation, much like with p2sh.
Note that less data is sent over the network to older nodes.
Also, nodes are given the option of not having to download (and hence not verify) transactions that are <em>x</em> blocks old if they don&#8217;t want to.
In a sense, the signature has been witnessed by a bunch of people and a node can choose to trust that this is valid instead of validating directly if it so chooses.</p>
</div>
<div class="paragraph">
<p>Note also that this is a special rule for Segwit version 0.
Segwit version 1 can have a completely different processing path.
<em>&lt;20-byte hash&gt;</em> <code>1</code> could be the special script sequence that triggers a different rule.
Upgrades of Segwit can introduce Schnorr signatures, Graftroot, or even a different scripting system altogether, like Simplicity.
Segwit gives us a clear upgrade path.
Software that understands how to validate Segwit version X will validate such transactions, but software that isn&#8217;t aware of Segwit version X simply processes only up to the point of the special rule.</p>
</div>
</div>
<div class="sect2">
<h3 id="_p2sh_p2wpkh">p2sh-p2wpkh</h3>
<div class="paragraph">
<p>p2wpkh is great, but unfortunately, this is a new type of script and older wallets cannot send bitcoins to p2wpkh ScriptPubKeys.
p2wpkh uses a new address format called Bech32, defined in BIP0173, whose ScriptPubKeys older wallets don&#8217;t know how to create.</p>
</div>
<div class="paragraph">
<p>The Segwit authors found an ingenious way to make Segwit backward compatible by "wrapping" p2wpkh inside p2sh.
This is called "nested" Segwit as the Segwit script is nested in a p2sh RedeemScript.</p>
</div>
<div class="paragraph">
<p>A p2sh-p2wpkh address is a normal p2sh address, but the RedeemScript is <code>OP_0</code> <em>&lt;20-byte hash&gt;</em>, or the ScriptPubKey of p2wpkh.
As with p2wpkh, different transactions are sent to older nodes (<a href="#p2sh_p2wpkh_to_pre_bip0141_software">Pay-to-script-hash-pay-to-witness-pubkey-hash (p2sh-p2wpkh) to pre-BIP0141 software</a>) versus newer nodes (<a href="#p2sh_p2wpkh_to_post_bip0141_software">p2sh-p2wpkh to post-BIP0141 software</a>).</p>
</div>
<div id="p2sh_p2wpkh_to_pre_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1309.png" alt="p2sh-p2wpkh to Old Nodes">
</div>
<div class="title">Figure 142. Pay-to-script-hash-pay-to-witness-pubkey-hash (p2sh-p2wpkh) to pre-BIP0141 software</div>
</div>
<div id="p2sh_p2wpkh_to_post_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1310.png" alt="p2sh-p2wpkh to New Nodes">
</div>
<div class="title">Figure 143. p2sh-p2wpkh to post-BIP0141 software</div>
</div>
<div class="paragraph">
<p>The difference from p2wpkh is that the ScriptSig is no longer empty.
The ScriptSig has a RedeemScript, which is equal to the ScriptPubkey in p2wpkh.
As this is a p2sh script, the ScriptPubKey is the same as in any other p2sh script.
The combined script looks like <a href="#p2sh_p2wpkh_scriptpubkey_is_the_same_as_a_normal_p2sh_scriptpubkey">p2sh-p2wpkh ScriptPubKey is the same as a normal p2sh ScriptPubKey</a>.</p>
</div>
<div id="p2sh_p2wpkh_scriptpubkey_is_the_same_as_a_normal_p2sh_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_1311.png" alt="p2sh-p2wpkh ScriptPubKey">
</div>
<div class="title">Figure 144. p2sh-p2wpkh ScriptPubKey is the same as a normal p2sh ScriptPubKey</div>
</div>
<div class="paragraph">
<p>We start the script evaluation like in <a href="#p2sh_p2wpkh_start">p2sh-p2wpkh start</a>.</p>
</div>
<div id="p2sh_p2wpkh_start" class="imageblock">
<div class="content">
<img src="./images/prbc_1312.png" alt="p2sh-p2wpkh start">
</div>
<div class="title">Figure 145. p2sh-p2wpkh start</div>
</div>
<div class="paragraph">
<p>Notice that the commands to be processed are exactly what triggers the p2sh special rule.
The RedeemScript goes on the stack (<a href="#p2sh_p2wpkh_step_1">p2sh-p2wpkh step 1</a>).</p>
</div>
<div id="p2sh_p2wpkh_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_1313.png" alt="p2sh-p2wpkh step 1">
</div>
<div class="title">Figure 146. p2sh-p2wpkh step 1</div>
</div>
<div class="paragraph">
<p>The <code>OP_HASH160</code> will return the RedeemScript&#8217;s hash (<a href="#p2sh_p2wpkh_step_2">p2sh-p2wpkh step 2</a>).</p>
</div>
<div id="p2sh_p2wpkh_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_1314.png" alt="p2sh-p2wpkh step 2">
</div>
<div class="title">Figure 147. p2sh-p2wpkh step 2</div>
</div>
<div class="paragraph">
<p>The hash will go on the stack, and we then get to <code>OP_EQUAL</code> (<a href="#p2sh_p2wpkh_step_3">p2sh-p2wpkh step 3</a>).</p>
</div>
<div id="p2sh_p2wpkh_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_1315.png" alt="p2sh-p2wpkh step 3">
</div>
<div class="title">Figure 148. p2sh-p2wpkh step 3</div>
</div>
<div class="paragraph">
<p>At this point, if the hashes are equal, pre-BIP0016 nodes will simply mark the input as valid, as they are unaware of the p2sh validation rules.
However, post-BIP0016 nodes recognize the special script sequence for p2sh, so the RedeemScript will then be evaluated as Script commands.
The RedeemScript is <code>OP_0</code> <em>&lt;20-byte hash&gt;</em>, which is the same as the ScriptPubKey for p2wpkh.
This makes the script state look like <a href="#p2sh_p2wpkh_step_4">p2sh-p2wpkh step 4</a>.</p>
</div>
<div id="p2sh_p2wpkh_step_4" class="imageblock">
<div class="content">
<img src="./images/prbc_1316.png" alt="p2sh-p2wpkh step 4">
</div>
<div class="title">Figure 149. p2sh-p2wpkh step 4</div>
</div>
<div class="paragraph">
<p>This should look familiar, as this is the state that p2wpkh starts with.
After <code>OP_0</code> and the 20-byte hash we are left with <a href="#p2sh_p2wpkh_step_5">p2sh-p2wpkh step 5</a>.</p>
</div>
<div id="p2sh_p2wpkh_step_5" class="imageblock">
<div class="content">
<img src="./images/prbc_1317.png" alt="p2sh-p2wpkh step 5">
</div>
<div class="title">Figure 150. p2sh-p2wpkh step 5</div>
</div>
<div class="paragraph">
<p>At this point, pre-Segwit nodes will mark this input as valid as they are unaware of the Segwit validation rules.
However, post-Segwit nodes will recognize the special script sequence for p2wpkh.
The signature and pubkey from the witness field along with the 20-byte hash will add the p2pkh commands (<a href="#p2sh_p2wpkh_step_6">p2sh-p2wpkh step 6</a>).</p>
</div>
<div id="p2sh_p2wpkh_step_6" class="imageblock">
<div class="content">
<img src="./images/prbc_1318.png" alt="p2sh-p2wpkh step 6">
</div>
<div class="title">Figure 151. p2sh-p2wpkh step 6</div>
</div>
<div class="paragraph">
<p>The rest of the processing is the same as p2pkh (<a href="#chapter_script">Script</a>).
Assuming the signature and pubkey are valid, we are left with <a href="#p2sh_p2wpkh_end">p2sh-p2wpkh end</a>.</p>
</div>
<div id="p2sh_p2wpkh_end" class="imageblock">
<div class="content">
<img src="./images/prbc_1319.png" alt="p2sh-p2wpkh end">
</div>
<div class="title">Figure 152. p2sh-p2wpkh end</div>
</div>
<div class="paragraph">
<p>As you can see, a p2sh-p2wpkh transaction is backward compatible all the way to before BIP0016.
A pre-BIP0016 node would consider the script valid once the RedeemScripts were equal, and a post-BIP0016, pre-Segwit node would consider the script valid at the 20-byte hash.
Both would not do the full validation and would accept the transaction.
A post-Segwit node would do the complete validation, including checking the signature and pubkey.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Can Anyone Spend Segwit Outputs?</div>
<div class="paragraph">
<p>Detractors of Segwit have referred to Segwit outputs as "anyone-can-spend."
This would have been true if the Bitcoin community had rejected Segwit.
In other words, if an economically significant part of the Bitcoin community had refused to do the Segwit validation and actively split from the network by accepting transactions that were not Segwit-valid, the outputs would have been anyone-can-spend.
However, due to a variety of economic incentives, Segwit was activated on the network, there was no network split, a lot of bitcoins are now locked in Segwit outputs, and Segwit transactions are validated per the soft-fork rules by the vast economic majority of nodes.
We can now say confidently that the detractors were wrong.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_coding_p2wpkh_and_p2sh_p2wpkh">Coding p2wpkh and p2sh-p2wpkh</h3>
<div class="paragraph">
<p>The first change we&#8217;re going to make is to the <code>Tx</code> class, where we need to mark whether the transaction is Segwit or not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
    command = b'tx'

    def __init__(self, version, tx_ins, tx_outs,
        locktime, testnet=False, segwit=False):
        self.version = version
        self.tx_ins = tx_ins
        self.tx_outs = tx_outs
        self.locktime = locktime
        self.testnet = testnet
        self.segwit = segwit
        self._hash_prevouts = None
        self._hash_sequence = None
        self._hash_outputs = None</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we change the <code>parse</code> method depending on the serialization we receive:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    @classmethod
    def parse(cls, s, testnet=False):
        s.read(4)  # <b class="conum">(1)</b>
        if s.read(1) == b'\x00':  # <b class="conum">(2)</b>
            parse_method = cls.parse_segwit
        else:
            parse_method = cls.parse_legacy
        s.seek(-5, 1)  # <b class="conum">(3)</b>
        return parse_method(s, testnet=testnet)

    @classmethod
    def parse_legacy(cls, s, testnet=False):
        version = little_endian_to_int(s.read(4))   # <b class="conum">(4)</b>
        num_inputs = read_varint(s)
        inputs = []
        for _ in range(num_inputs):
            inputs.append(TxIn.parse(s))
        num_outputs = read_varint(s)
        outputs = []
        for _ in range(num_outputs):
            outputs.append(TxOut.parse(s))
        locktime = little_endian_to_int(s.read(4))
        return cls(version, inputs, outputs, locktime,
                   testnet=testnet, segwit=False)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>To determine whether we have a Segwit transaction or not, we look at the fifth byte.
The first four are the version, the fifth is the Segwit marker.</p>
</li>
<li>
<p>The fifth byte being 0 is how we tell that this transaction is Segwit (this is not foolproof, but it&#8217;s what we&#8217;re going to use).
We use different parsers depending on whether it&#8217;s Segwit.</p>
</li>
<li>
<p>We put the stream back to the position before we examined the first 5 bytes.</p>
</li>
<li>
<p>We&#8217;ve moved the old <code>parse</code> method to <code>parse_legacy</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here&#8217;s a parser for the Segwit serialization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    @classmethod
    def parse_segwit(cls, s, testnet=False):
        version = little_endian_to_int(s.read(4))
        marker = s.read(2)
        if marker != b'\x00\x01':  # <b class="conum">(1)</b>
            raise RuntimeError('Not a segwit transaction {}'.format(marker))
        num_inputs = read_varint(s)
        inputs = []
        for _ in range(num_inputs):
            inputs.append(TxIn.parse(s))
        num_outputs = read_varint(s)
        outputs = []
        for _ in range(num_outputs):
            outputs.append(TxOut.parse(s))
        for tx_in in inputs:  # <b class="conum">(2)</b>
            num_items = read_varint(s)
            items = []
            for _ in range(num_items):
                item_len = read_varint(s)
                if item_len == 0:
                    items.append(0)
                else:
                    items.append(s.read(item_len))
            tx_in.witness = items
        locktime = little_endian_to_int(s.read(4))
        return cls(version, inputs, outputs, locktime,
                   testnet=testnet, segwit=True)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>There are two new fields; one of them is the Segwit marker.</p>
</li>
<li>
<p>The second new field is witness, which contains items for each input.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We now code the corresponding changes to the serialization methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def serialize(self):
        if self.segwit:
            return self.serialize_segwit()
        else:
            return self.serialize_legacy()

    def serialize_legacy(self):  # <b class="conum">(1)</b>
        result = int_to_little_endian(self.version, 4)
        result += encode_varint(len(self.tx_ins))
        for tx_in in self.tx_ins:
            result += tx_in.serialize()
        result += encode_varint(len(self.tx_outs))
        for tx_out in self.tx_outs:
            result += tx_out.serialize()
        result += int_to_little_endian(self.locktime, 4)
        return result

    def serialize_segwit(self):
        result = int_to_little_endian(self.version, 4)
        result += b'\x00\x01'  # <b class="conum">(2)</b>
        result += encode_varint(len(self.tx_ins))
        for tx_in in self.tx_ins:
            result += tx_in.serialize()
        result += encode_varint(len(self.tx_outs))
        for tx_out in self.tx_outs:
            result += tx_out.serialize()
        for tx_in in self.tx_ins:  # <b class="conum">(3)</b>
            result += int_to_little_endian(len(tx_in.witness), 1)
            for item in tx_in.witness:
                if type(item) == int:
                    result += int_to_little_endian(item, 1)
                else:
                    result += encode_varint(len(item)) + item
        result += int_to_little_endian(self.locktime, 4)
        return result</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>What used to be called <code>serialize</code> is now <code>serialize_legacy</code>.</p>
</li>
<li>
<p>The Segwit serialization adds the markers.</p>
</li>
<li>
<p>The witness is serialized at the end.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We also have to change the <code>hash</code> method to use the legacy serialization, even for Segwit transactions, as that will keep the transaction ID stable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def hash(self):
        '''Binary hash of the legacy serialization'''
        return hash256(self.serialize_legacy())[::-1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>verify_input</code> method requires a different <code>z</code> for Segwit transactions.
The Segwit transaction signature hash calculation is specified in BIP0143.
In addition, the witness field is passed through to the script evaluation engine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def verify_input(self, input_index):
        tx_in = self.tx_ins[input_index]
        script_pubkey = tx_in.script_pubkey(testnet=self.testnet)
        if script_pubkey.is_p2sh_script_pubkey():
            command = tx_in.script_sig.commands[-1]
            raw_redeem = int_to_little_endian(len(command), 1) + command
            redeem_script = Script.parse(BytesIO(raw_redeem))
            if redeem_script.is_p2wpkh_script_pubkey():  # <b class="conum">(1)</b>
                z = self.sig_hash_bip143(input_index, redeem_script)  # <b class="conum">(2)</b>
                witness = tx_in.witness
            else:
                z = self.sig_hash(input_index, redeem_script)
                witness = None
        else:
            if script_pubkey.is_p2wpkh_script_pubkey():  # <b class="conum">(3)</b>
                z = self.sig_hash_bip143(input_index)  # <b class="conum">(2)</b>
                witness = tx_in.witness
            else:
                z = self.sig_hash(input_index)
                witness = None
        combined_script = tx_in.script_sig + tx_in.script_pubkey(self.testnet)
        return combined_script.evaluate(z, witness)  # <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This handles the p2sh-p2wpkh case.</p>
</li>
<li>
<p>The BIP0143 signature hash generation code is in <em>tx.py</em> of this chapter&#8217;s code.</p>
</li>
<li>
<p>This handles the p2wpkh case.</p>
</li>
<li>
<p>The witness passes through to the evaluation engine so that p2wpkh can construct the right commands.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We also define what a p2wpkh script looks like in <em>script.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def p2wpkh_script(h160):
    '''Takes a hash160 and returns the p2wpkh ScriptPubKey'''
    return Script([0x00, h160])  # <b class="conum">(1)</b>
...
    def is_p2wpkh_script_pubkey(self):  # <b class="conum">(2)</b>
        return len(self.cmds) == 2 and self.cmds[0] == 0x00 \
            and type(self.cmds[1]) == bytes and len(self.cmds[1]) == 20</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is OP_0 <em>&lt;20-byte-hash&gt;</em>.</p>
</li>
<li>
<p>This checks if the current script is a p2wpkh ScriptPubKey.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Last, we need to implement the special rule in the <code>evaluate</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Script:
...
    def evaluate(self, z, witness):
    ...
        while len(commands) &gt; 0:
        ...
            else:
                stack.append(command)
		...
                if len(stack) == 2 and stack[0] == b'' and len(stack[1]) == 20:  # <b class="conum">(1)</b>
                    h160 = stack.pop()
                    stack.pop()
                    cmds.extend(witness)
                    cmds.extend(p2pkh_script(h160).cmds)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This is where we execute witness program version 0 for p2wpkh.
We make a p2pkh combined script from the 20-byte hash, signature, and pubkey and evaluate.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_pay_to_witness_script_hash_p2wsh">Pay-to-Witness-Script-Hash (p2wsh)</h3>
<div class="paragraph">
<p>While p2wpkh takes care of a major use case, we need something more flexible if we want more complicated (e.g., multisig) scripts.
This is where pay-to-witness-script-hash (p2wsh) comes in. p2wsh is like p2sh, but with all the ScriptSig data in the witness field instead.</p>
</div>
<div class="paragraph">
<p>As with p2wpkh, we send different data to pre-BIP0141 software (<a href="#p2wsh_as_seen_by_pre_bip0141_software">Pay-to-witness-script-hash as seen by pre-BIP0141 software</a>) versus post-BIP0141 software (<a href="#p2wsh_as_seen_by_post_bip0141_software">Pay-to-witness-script-hash as seen by post-BIP0141 software</a>).</p>
</div>
<div id="p2wsh_as_seen_by_pre_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1320.png" alt="p2wsh to old nodes">
</div>
<div class="title">Figure 153. Pay-to-witness-script-hash as seen by pre-BIP0141 software</div>
</div>
<div id="p2wsh_as_seen_by_post_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1321.png" alt="p2wsh to new nodes">
</div>
<div class="title">Figure 154. Pay-to-witness-script-hash as seen by post-BIP0141 software</div>
</div>
<div class="paragraph">
<p>The ScriptPubKey for p2wsh script is <code>OP_0</code> <em>&lt;32-byte hash&gt;</em>.
This sequence triggers another special rule.
The ScriptSig, as with p2wpkh, is empty.
When p2wsh outputs are being spent, the combined script looks like <a href="#p2wsh_scriptpubkey">Pay-to-witness-script-hash (p2wsh) ScriptPubKey</a>.</p>
</div>
<div id="p2wsh_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_1322.png" alt="p2wsh ScriptPubKey">
</div>
<div class="title">Figure 155. Pay-to-witness-script-hash (p2wsh) ScriptPubKey</div>
</div>
<div class="paragraph">
<p>The processing of this script starts similarly to p2wpkh (Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#p2wsh_start">#p2wsh_start</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#p2wsh_step_1">#p2wsh_step_1</a>).</p>
</div>
<div id="p2wsh_start" class="imageblock">
<div class="content">
<img src="./images/prbc_1323.png" alt="p2wsh start">
</div>
<div class="title">Figure 156. p2sh start</div>
</div>
<div id="p2wsh_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_1324.png" alt="p2wsh step 1">
</div>
<div class="title">Figure 157. p2wsh step 1</div>
</div>
<div class="paragraph">
<p>The 32-byte hash is an element, so it is pushed to the stack (<a href="#p2wsh_step_2">p2wsh step 2</a>).</p>
</div>
<div id="p2wsh_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_1325.png" alt="p2wsh step 2">
</div>
<div class="title">Figure 158. p2wsh step 2</div>
</div>
<div class="paragraph">
<p>As with p2wpkh, older nodes will stop here because there are no more Script commands to be processed.
Newer nodes will recognize the special sequence and do additional validation by looking at the witness field.</p>
</div>
<div class="paragraph">
<p>The witness field for p2wsh in our case is a 2-of-3 multisig (<a href="#p2wsh_witness">p2wsh witness</a>).</p>
</div>
<div id="p2wsh_witness" class="imageblock">
<div class="content">
<img src="./images/prbc_1326.png" alt="p2wsh witness">
</div>
<div class="title">Figure 159. p2wsh witness</div>
</div>
<div class="paragraph">
<p>The last item of the witness is called the <em>WitnessScript</em> and must sha256 to the 32-byte hash from the ScriptPubKey.
Note this is sha256, not hash256.
Once the WitnessScript is validated by having the same hash value, it is interpreted as script commands and put into the command set.
The WitnessScript looks like <a href="#p2wsh_witness_script">p2wsh WitnessScript</a>.</p>
</div>
<div id="p2wsh_witness_script" class="imageblock">
<div class="content">
<img src="./images/prbc_1327.png" alt="p2wsh WitnessScript">
</div>
<div class="title">Figure 160. p2wsh WitnessScript</div>
</div>
<div class="paragraph">
<p>The rest of the witness field is put on top to produce the command set in <a href="#p2wsh_step_3">p2wsh step 3</a>.</p>
</div>
<div id="p2wsh_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_1328.png" alt="p2wsh step 3">
</div>
<div class="title">Figure 161. p2wsh step 3</div>
</div>
<div class="paragraph">
<p>As you can see, this is a 2-of-3 multisig much like what was explored in <a href="#chapter_p2sh">Pay-to-Script Hash</a> (<a href="#p2wsh_step_4">p2wsh step 4</a>).</p>
</div>
<div id="p2wsh_step_4" class="imageblock">
<div class="content">
<img src="./images/prbc_1329.png" alt="p2wsh step 4">
</div>
<div class="title">Figure 162. p2wsh step 4</div>
</div>
<div class="paragraph">
<p>If the signatures are valid, we end like <a href="#p2wsh_step_5">p2wsh step 5</a>.</p>
</div>
<div id="p2wsh_step_5" class="imageblock">
<div class="content">
<img src="./images/prbc_1330.png" alt="p2wsh step 5">
</div>
<div class="title">Figure 163. p2wsh step 5</div>
</div>
<div class="paragraph">
<p>The WitnessScript is very similar to the RedeemScript in that the sha256 of the serialization is addressed in the ScriptPubKey, but only revealed when the output is being spent.
Once the sha256 of the WitnessScript is found to be the same as the 32-byte hash, the WitnessScript is interpreted as script commands and added to the command set.
The rest of the witness field is then added to the command set as well, producing the final set of commands to be evaluated.
p2wsh is particularly important, as unmalleable multisig transactions are required for creating bidirectional payment channels for the Lightning Network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_p2sh_p2wsh">p2sh-p2wsh</h3>
<div class="paragraph">
<p>Like p2sh-p2wpkh, p2sh-p2wsh is a way to make p2wsh backward compatible.
Again, different transactions are sent to older nodes (<a href="#p2sh_p2wsh_to_pre_bip0141_software">Pay-to-script-hash-pay-to-witness-script-hash (p2sh-p2wsh) to pre-BIP0141 software</a>) versus newer nodes (<a href="#p2sh_p2wsh_to_post_bip0141_software">p2sh-p2wsh to post-BIP0141 software</a>).</p>
</div>
<div id="p2sh_p2wsh_to_pre_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1331.png" alt="p2sh-p2wsh to Old Nodes">
</div>
<div class="title">Figure 164. Pay-to-script-hash-pay-to-witness-script-hash (p2sh-p2wsh) to pre-BIP0141 software</div>
</div>
<div id="p2sh_p2wsh_to_post_bip0141_software" class="imageblock">
<div class="content">
<img src="./images/prbc_1332.png" alt="p2sh-p2wsh to New Nodes">
</div>
<div class="title">Figure 165. p2sh-p2wsh to post-BIP0141 software</div>
</div>
<div class="paragraph pagebreak-before">
<p>As with p2sh-p2wpkh, the ScriptPubKey is indistinguishable from any other p2sh address and the ScriptSig is only the RedeemScript (<a href="#p2sh_p2wsh_scriptpubkey">p2sh-p2wsh ScriptPubKey</a>).</p>
</div>
<div id="p2sh_p2wsh_scriptpubkey" class="imageblock">
<div class="content">
<img src="./images/prbc_1311.png" alt="p2sh-p2wsh ScriptPubKey">
</div>
<div class="title">Figure 166. p2sh-p2wsh ScriptPubKey</div>
</div>
<div class="paragraph">
<p>We start the p2sh-p2wsh script evaluation in exactly the same way that p2sh-p2wpkh script evaluation starts (<a href="#p2sh_p2wsh_start">p2sh-p2wsh start</a>).</p>
</div>
<div id="p2sh_p2wsh_start" class="imageblock">
<div class="content">
<img src="./images/prbc_1312.png" alt="p2sh-p2wsh start">
</div>
<div class="title">Figure 167. p2sh-p2wsh start</div>
</div>
<div class="paragraph">
<p>The RedeemScript is pushed to the stack (<a href="#p2sh_p2wsh_step_1">p2sh-p2wsh step 1</a>).</p>
</div>
<div id="p2sh_p2wsh_step_1" class="imageblock">
<div class="content">
<img src="./images/prbc_1313.png" alt="p2sh-p2wsh step 1">
</div>
<div class="title">Figure 168. p2sh-p2wsh step 1</div>
</div>
<div class="paragraph">
<p>The <code>OP_HASH160</code> will return the RedeemScript&#8217;s hash (<a href="#p2sh_p2wsh_step_2">p2sh-p2wsh step 2</a>).</p>
</div>
<div id="p2sh_p2wsh_step_2" class="imageblock">
<div class="content">
<img src="./images/prbc_1314.png" alt="p2sh-p2wsh step 2">
</div>
<div class="title">Figure 169. p2sh-p2wsh step 2</div>
</div>
<div class="paragraph">
<p>The hash is pushed to the stack, and we then get to <code>OP_EQUAL</code> (<a href="#p2sh_p2wsh_step_3">p2sh-p2wsh step 3</a>).</p>
</div>
<div id="p2sh_p2wsh_step_3" class="imageblock">
<div class="content">
<img src="./images/prbc_1315.png" alt="p2sh-p2wsh step 3">
</div>
<div class="title">Figure 170. p2sh-p2wsh step 3</div>
</div>
<div class="paragraph">
<p>As with p2sh-p2wpkh, if the hashes are equal, pre-BIP0016 nodes will mark the input as valid as they are unaware of the p2sh validation rules.
However, post-BIP0016 nodes will recognize the special script sequence for p2sh, so the RedeemScript will be interpreted as new script commands.
The RedeemScript is <code>OP_0</code> <em>32-byte hash</em>, which is the same as the ScriptPubKey for p2wsh (<a href="#p2sh_p2wsh_redeemscript">p2sh-p2wsh RedeemScript</a>).</p>
</div>
<div id="p2sh_p2wsh_redeemscript" class="imageblock">
<div class="content">
<img src="./images/prbc_1338.png" alt="p2sh-p2wsh RedeemScript">
</div>
<div class="title">Figure 171. p2sh-p2wsh RedeemScript</div>
</div>
<div class="paragraph">
<p>This makes the script state look like <a href="#p2sh_p2wsh_step_4">p2sh-p2wsh step 4</a>.</p>
</div>
<div id="p2sh_p2wsh_step_4" class="imageblock">
<div class="content">
<img src="./images/prbc_1323.png" alt="p2sh-p2wsh step 4">
</div>
<div class="title">Figure 172. p2sh-p2wsh step 4</div>
</div>
<div class="paragraph">
<p>Of course, this is the exact same starting state as for p2wsh (<a href="#p2sh_p2wsh_step_5">p2sh-p2wsh step 5</a>).</p>
</div>
<div id="p2sh_p2wsh_step_5" class="imageblock">
<div class="content">
<img src="./images/prbc_1324.png" alt="p2sh-p2wsh step 5">
</div>
<div class="title">Figure 173. p2sh-p2wsh step 5</div>
</div>
<div class="paragraph">
<p>The 32-byte hash is an element, so it is pushed to the stack (<a href="#p2sh_p2wsh_step_6">p2sh-p2wsh step 6</a>).</p>
</div>
<div id="p2sh_p2wsh_step_6" class="imageblock">
<div class="content">
<img src="./images/prbc_1325.png" alt="p2sh-p2wsh step 6">
</div>
<div class="title">Figure 174. p2sh-p2wsh step 6</div>
</div>
<div class="paragraph">
<p>At this point, pre-Segwit nodes will mark this input as valid, as they are unaware of the Segwit validation rules.
However, post-Segwit nodes will recognize the special script sequence for p2wsh.
The witness field (<a href="#p2sh_p2wsh_witness">p2sh-p2wsh witness</a>) contains the WitnessScript (<a href="#p2sh_p2wsh_witness_script">p2sh-p2wsh WitnessScript</a>). The sha256 of the WitnessScript is checked against the 32-byte hash, and if they&#8217;re equal the WitnessScript is interpreted as script commands and put into the command set (<a href="#p2sh_p2wsh_step_7">p2sh-p2wsh step 7</a>).</p>
</div>
<div id="p2sh_p2wsh_witness" class="imageblock">
<div class="content">
<img src="./images/prbc_1342.png" alt="p2sh-p2wsh witness">
</div>
<div class="title">Figure 175. p2sh-p2wsh witness</div>
</div>
<div id="p2sh_p2wsh_witness_script" class="imageblock">
<div class="content">
<img src="./images/prbc_1327.png" alt="p2wsh WitnessScript">
</div>
<div class="title">Figure 176. p2sh-p2wsh WitnessScript</div>
</div>
<div id="p2sh_p2wsh_step_7" class="imageblock">
<div class="content">
<img src="./images/prbc_1328.png" alt="p2sh-p2wsh step 7">
</div>
<div class="title">Figure 177. p2sh-p2wsh step 7</div>
</div>
<div class="paragraph">
<p>As you can see, this is a 2-of-3 multisig as in <a href="#chapter_p2sh">Pay-to-Script Hash</a>.
If the signatures are valid, we end like <a href="#p2sh_p2wsh_end">p2sh-p2wsh end</a>.</p>
</div>
<div id="p2sh_p2wsh_end" class="imageblock">
<div class="content">
<img src="./images/prbc_1330.png" alt="p2sh-p2wsh end">
</div>
<div class="title">Figure 178. p2sh-p2wsh end</div>
</div>
<div class="paragraph">
<p>This makes p2wsh backward compatible, allowing older wallets to send to p2sh ScriptPubKeys that they can handle.</p>
</div>
</div>
<div class="sect2">
<h3 id="_coding_p2wsh_and_p2sh_p2wsh">Coding p2wsh and p2sh-p2wsh</h3>
<div class="paragraph">
<p>The parsing and serialization are exactly the same as before.
The main changes have to do with <code>verify_input</code> in <em>tx.py</em> and <code>evaluate</code> in <em>script.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def verify_input(self, input_index):
        tx_in = self.tx_ins[input_index]
        script_pubkey = tx_in.script_pubkey(testnet=self.testnet)
        if script_pubkey.is_p2sh_script_pubkey():
            command = tx_in.script_sig.commands[-1]
            raw_redeem = int_to_little_endian(len(command), 1) + command
            redeem_script = Script.parse(BytesIO(raw_redeem))
            if redeem_script.is_p2wpkh_script_pubkey():
                z = self.sig_hash_bip143(input_index, redeem_script)
                witness = tx_in.witness
            elif redeem_script.is_p2wsh_script_pubkey():  # <b class="conum">(1)</b>
                command = tx_in.witness[-1]
                raw_witness = encode_varint(len(command)) + command
                witness_script = Script.parse(BytesIO(raw_witness))
                z = self.sig_hash_bip143(input_index,
                                         witness_script=witness_script)
                witness = tx_in.witness
            else:
                z = self.sig_hash(input_index, redeem_script)
                witness = None
        else:
            if script_pubkey.is_p2wpkh_script_pubkey():
                z = self.sig_hash_bip143(input_index)
                witness = tx_in.witness
            elif script_pubkey.is_p2wsh_script_pubkey():  # <b class="conum">(2)</b>
                command = tx_in.witness[-1]
                raw_witness = encode_varint(len(command)) + command
                witness_script = Script.parse(BytesIO(raw_witness))
                z = self.sig_hash_bip143(input_index,
                                         witness_script=witness_script)
                witness = tx_in.witness
            else:
                z = self.sig_hash(input_index)
                witness = None
        combined_script = tx_in.script_sig + tx_in.script_pubkey(self.testnet)
        return combined_script.evaluate(z, witness)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This takes care of p2sh-p2wsh.</p>
</li>
<li>
<p>This takes care of p2wsh.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, we code a way to identify p2wsh in <em>script.py</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def p2wsh_script(h256):
    '''Takes a hash160 and returns the p2wsh ScriptPubKey'''
    return Script([0x00, h256])  # <b class="conum">(1)</b>
...
class Script:
...
    def is_p2wsh_script_pubkey(self):
        return len(self.cmds) == 2 and self.cmds[0] == 0x00 \
            and type(self.cmds[1]) == bytes and len(self.cmds[1]) == 32</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>OP_0</code> <em>&lt;32-byte script&gt;</em> is what we expect.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Last, we handle the special rule for p2wsh:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Script:
...
    def evaluate(self, z, witness):
    ...
        while len(commands) &gt; 0:
        ...
	   else:
                stack.append(command)
    	        ...
                if len(stack) == 2 and stack[0] == b'' and len(stack[1]) == 32:
                    s256 = stack.pop()  # <b class="conum">(1)</b>
                    stack.pop()  # <b class="conum">(2)</b>
                    cmds.extend(witness[:-1])  # <b class="conum">(3)</b>
                    witness_script = witness[-1]  # <b class="conum">(4)</b>
                    if s256 != sha256(witness_script):  # <b class="conum">(5)</b>
                        print('bad sha256 {} vs {}'.format
                            (s256.hex(), sha256(witness_script).hex()))
                        return False
                    stream = BytesIO(encode_varint(len(witness_script))
                        + witness_script)
                    witness_script_cmds = Script.parse(stream).cmds  # <b class="conum">(6)</b>
                    cmds.extend(witness_script_cmds)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The top element is the sha256 hash of the WitnessScript.</p>
</li>
<li>
<p>The second element is the witness version, 0.</p>
</li>
<li>
<p>Everything but the WitnessScript is added to the command set.</p>
</li>
<li>
<p>The WitnessScript is the last item of the witness field.</p>
</li>
<li>
<p>The WitnessScript must hash to the sha256 that was in the stack.</p>
</li>
<li>
<p>We parse the WitnessScript and add it to the command set.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_other_improvements">Other Improvements</h3>
<div class="paragraph">
<p>Segwit also fixes the quadratic hashing problem through a different calculation of the signature hash.
A lot of the calculations for the signature hash, <em>z</em>, can be reused instead of requiring a new hash256 hash for each input.
The signature hash calculation is detailed in BIP0143 and can be seen in <em>code-ch13/tx.py</em>.</p>
</div>
<div class="paragraph">
<p>Another improvement is that by policy, uncompressed SEC pubkeys are now forbidden; only compressed SEC pubkeys are used for Segwit, saving space.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_13">Conclusion</h3>
<div class="paragraph">
<p>The chapter covered the details of Segwit as a taste of what&#8217;s now possible.
<a href="#chapter_advanced">Advanced Topics and Next Steps</a> discusses the next steps that you can take on your Bitcoin developer journey.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter_advanced">Advanced Topics and Next Steps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;ve made it this far, congratulations!
You&#8217;ve learned a lot about Bitcoin&#8217;s inner workings, and hopefully you are inspired to learn a lot more.
This book has only scratched the surface.
In this chapter, we&#8217;ll go through some other topics you might want to explore, how to bootstrap your career as a Bitcoin developer, and ways to contribute to the community.</p>
</div>
<div class="sect2">
<h3 id="_suggested_topics_to_study_next">Suggested Topics to Study Next</h3>
<div class="sect3">
<h4 id="_wallets">Wallets</h4>
<div class="paragraph">
<p>Creating a wallet is a challenging task because securing private keys is very difficult.
That said, there are a bunch of standards for creating wallets that can help.</p>
</div>
<div class="sect4">
<h5 id="_hierarchical_deterministic_wallets">Hierarchical Deterministic Wallets</h5>
<div class="paragraph">
<p>For privacy purposes, reusing addresses is very bad (see <a href="#chapter_tx">Transaction Creation and Validation</a>).
That means we need to create lots of addresses.
Unfortunately, storing a different secret for each address generated can become a security and backup problem.
How do you back them all up in a secure way?
Do you generate a ton of secrets and then back them up?
What if you run out of secrets?
How do you back them up again?
What system can you use to ensure that the backups are current?</p>
</div>
<div class="paragraph">
<p>To combat this problem, Armory, an early Bitcoin wallet, first implemented <em>deterministic</em> wallets.
The idea of a deterministic wallet is that you can generate one seed and create lots and lots of different addresses with that one seed.
The Armory-style deterministic wallets were great, except people wanted some grouping of addresses—so, the <em>hierarchical deterministic</em> (HD) wallet standard, BIP0032, was born.
BIP0032 wallets have multiple layers and keys, each with a unique derivation path.
The specifications and test vectors are defined in the BIP0032 standard, so implementing your own HD wallet on testnet is a great way to learn.</p>
</div>
<div class="paragraph">
<p>Additionally, BIP0044 defines what each layer of the BIP0032 hierarchy can mean and the best practices for using a single HD seed to store coins from a lot of different cryptocurrencies.
Implementing BIP0044 can also be a way to understand the HD wallet infrastructure a lot better.
While many wallets (Trezor, Coinomi, etc.) implement both BIP0032 and BIP0044, some wallets ignore BIP0044 altogether and use their own BIP0032 hierarchy (Electrum and Edge being two examples).</p>
</div>
</div>
<div class="sect4">
<h5 id="_mnemonic_seeds">Mnemonic Seeds</h5>
<div class="paragraph">
<p>Writing down and transcribing a 256-bit seed is a pain, and fraught with errors.
To combat this, BIP0039 describes a way to encode the seed into a bunch of English words.
There are 2,048 possible words, or 2<sup>11</sup>, which means that each word encodes 11 bits of the seed.
The standard defines exactly how the mnemonic backup gets translated to a BIP0032 seed.
BIP0039 along with BIP0032 and BIP0044 is how most wallets implement backup and restoration.
Writing a testnet wallet that implements BIP0039 is another good way to get a taste for Bitcoin development.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_payment_channels_and_lightning_network">Payment Channels and Lightning Network</h4>
<div class="paragraph">
<p>Payment channels are the atomic unit of the Lightning Network, and learning how they work is a good next step.
There are many ways to implement payment channels, but the BOLT standard is the specification that lightning nodes use.
The specifications are in progress as of this writing and are available at <a href="https://github.com/lightningnetwork/lightning-rfc/" class="bare">https://github.com/lightningnetwork/lightning-rfc/</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_contributing">Contributing</h3>
<div class="paragraph">
<p>A large part of the Bitcoin ethic is contributing back to the community.
The main way you can do that is through open source projects.
There are almost too many to list, but here&#8217;s a sample:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a></dt>
<dd>
<p>The reference client</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/libbitcoin/libbitcoin">Libbitcoin</a></dt>
<dd>
<p>An alternate implementation of Bitcoin in C++</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/btcsuite/btcd">btcd</a></dt>
<dd>
<p>A Golang-based implementation of Bitcoin</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/bcoin-org/bcoin">Bcoin</a></dt>
<dd>
<p>A JavaScript-based implementation of Bitcoin, maintained by purse.io</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/richardkiss/pycoin">pycoin</a></dt>
<dd>
<p>A Python library for Bitcoin</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/bitcoinj/bitcoinj">BitcoinJ</a></dt>
<dd>
<p>A Java library for Bitcoin</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/bitcoinjs/bitcoinjs-lib">BitcoinJS</a></dt>
<dd>
<p>A JavaScript library for Bitcoin</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/btcpayserver/btcpayserver">BTCPay</a></dt>
<dd>
<p>A Bitcoin payment processing engine written in C#</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Contributing can be very beneficial for a lot of reasons, including future employment opportunities, learning, getting good business ideas, and so on.</p>
</div>
</div>
<div class="sect2">
<h3 id="_suggested_next_projects">Suggested Next Projects</h3>
<div class="paragraph">
<p>If at this point you&#8217;re still wondering what projects would be beneficial for you, what follows are some suggestions.</p>
</div>
<div class="sect3">
<h4 id="_testnet_wallet">Testnet Wallet</h4>
<div class="paragraph">
<p>It&#8217;s hard to understate the importance of security in Bitcoin.
Writing a wallet even on testnet will help you understand the various considerations that go into creating a wallet.
UI, backups, address books, and transaction histories are just some of the things that you have to deal with when creating a wallet.
As this is the most popular application of Bitcoin, creating a wallet will give you a lot of insight into users' needs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_block_explorer">Block Explorer</h4>
<div class="paragraph">
<p>A more ambitious project would be to write your own block explorer.
The key to making your own block explorer is to store the blockchain data in an easy-to-access fashion.
Using a traditional database like Postgres or MySQL may be useful here.
As Bitcoin Core does not have address indexes, adding one will make it possible for you to allow lookups of UTXOs and past transactions by address, which is what most users desire.</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_shop">Web Shop</h4>
<div class="paragraph">
<p>A Bitcoin-based shop is another project that helps you learn.
This is particularly appropriate for web developers as they typically know how to create a web application.
A web application with a Bitcoin backend can be a powerful way to avoid third-party dependencies for payment.
Once again, it&#8217;s advised that you start on testnet and use the cryptographically secure libraries that are available to hook up the plumbing for payments.</p>
</div>
</div>
<div class="sect3">
<h4 id="_utility_library">Utility Library</h4>
<div class="paragraph">
<p>A utility library like the one built in this book is another great way to learn more about Bitcoin.
Writing the BIP0143 serialization for the signature hash of Segwit, for example, can be instructive in getting used to protocol programming.
Porting the code from this book to another language would also be a great learning tool.</p>
</div>
</div>
<div class="sect3">
<h4 id="_finding_a_job">Finding a Job</h4>
<div class="paragraph">
<p>If you are interested in getting into this industry in more depth, there are lots of great opportunities for developers.
The key to proving that you know something is to have a portfolio of projects that you&#8217;ve done on your own.
Contributing to an existing open source project or making your own project will help you get noticed by companies.
In addition, programming against the API of any particular company is a great way to get an interview!</p>
</div>
<div class="paragraph">
<p>Generally, local work is going to be a lot easier to get as companies don&#8217;t like the risk profile of remote workers.
Go to local meetups and network with people that you meet there, and the local Bitcoin jobs will be a lot easier to come by.</p>
</div>
<div class="paragraph">
<p>Similarly, remote work requires that you put yourself out there to be noticed.
Besides open source contributions, go to conferences, network, and create technical content (YouTube videos, blog posts, etc.).
These will help quite a bit in getting noticed and getting a remote job.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_14">Conclusion</h3>
<div class="paragraph">
<p>I&#8217;m excited that you&#8217;ve made it to the end.
If you are so inclined, please send me notes about your progress, as I would love to hear from you!
I can be reached at <a href="mailto:jimmy@programmingblockchain.com">jimmy@programmingblockchain.com</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix_solutions">Appendix A: Solutions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_finite_fields_finite_fields"><a href="#chapter_finite_fields">Finite Fields</a>: Finite Fields</h3>
<div class="sect3">
<h4 id="_exercise_1_13">Exercise 1</h4>
<div class="paragraph">
<p>Write the corresponding method <code><em>ne</em></code>, which checks if two <code>FieldElement</code> objects are <em>not equal</em> to each other.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:
...
    def __ne__(self, other):
        # this should be the inverse of the == operator
        return not (self == other)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_13">Exercise 2</h4>
<div class="paragraph">
<p>Solve these problems in <em>F</em><sub>57</sub> (assume all +'s here are +<sub><em>f</em></sub> and –'s here are –<sub><em>f</em></sub>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>44 + 33</p>
</li>
<li>
<p>9 – 29</p>
</li>
<li>
<p>17 + 42 + 49</p>
</li>
<li>
<p>52 – 30 – 38</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; prime = 57
&gt;&gt;&gt; print((44+33)%prime)
20
&gt;&gt;&gt; print((9-29)%prime)
37
&gt;&gt;&gt; print((17+42+49)%prime)
51
&gt;&gt;&gt; print((52-30-38)%prime)
41</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_13">Exercise 3</h4>
<div class="paragraph">
<p>Write the corresponding <code><em>sub</em></code> method that defines the subtraction of two <span class="keep-together"><code>FieldElement</code></span> objects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:
...
    def __sub__(self, other):
        if self.prime != other.prime:
            raise TypeError('Cannot subtract two numbers in different Fields')
        # self.num and other.num are the actual values
        # self.prime is what we need to mod against
        num = (self.num - other.num) % self.prime
        # we return an element of the same class
        return self.__class__(num, self.prime)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_13">Exercise 4</h4>
<div class="paragraph">
<p>Solve the following equations in <em>F</em><sub>97</sub> (again, assume ⋅ and exponentiation are field <span class="keep-together">versions</span>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>95 ⋅ 45 ⋅ 31</p>
</li>
<li>
<p>17 ⋅ 13 ⋅ 19 ⋅ 44</p>
</li>
<li>
<p>12<sup>7</sup> ⋅ 77<sup>49</sup></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; prime = 97
&gt;&gt;&gt; print(95*45*31 % prime)
23
&gt;&gt;&gt; print(17*13*19*44 % prime)
68
&gt;&gt;&gt; print(12**7*77**49 % prime)
63</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_12">Exercise 5</h4>
<div class="paragraph">
<p>For <em>k</em> = 1, 3, 7, 13, 18, what is this set in <em>F</em><sub>19</sub>?</p>
</div>
<ul class="simplelist">
<li>{<em>k</em> ⋅ 0, <em>k</em> ⋅ 1, <em>k</em> ⋅ 2, <em>k</em> ⋅ 3, ... <em>k</em> ⋅ 18}</li>
</ul>
<div class="paragraph">
<p>Do you notice anything about these sets?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; prime = 19
&gt;&gt;&gt; for k in (1,3,7,13,18):
...     print([k*i % prime for i in range(prime)])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
[0, 3, 6, 9, 12, 15, 18, 2, 5, 8, 11, 14, 17, 1, 4, 7, 10, 13, 16]
[0, 7, 14, 2, 9, 16, 4, 11, 18, 6, 13, 1, 8, 15, 3, 10, 17, 5, 12]
[0, 13, 7, 1, 14, 8, 2, 15, 9, 3, 16, 10, 4, 17, 11, 5, 18, 12, 6]
[0, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
&gt;&gt;&gt; for k in (1,3,7,13,18):
...     print(sorted([k*i % prime for i in range(prime)]))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]</code></pre>
</div>
</div>
<div class="paragraph">
<p>When sorted, the results are always the same set.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_10">Exercise 6</h4>
<div class="paragraph">
<p>Write the corresponding <code><em>mul</em></code> method that defines the multiplication of two finite field elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:
...
    def __mul__(self, other):
        if self.prime != other.prime:
            raise TypeError('Cannot multiply two numbers in different Fields')
        # self.num and other.num are the actual values
        # self.prime is what we need to mod against
        num = (self.num * other.num) % self.prime
        # we return an element of the same class
        return self.__class__(num, self.prime)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_7">Exercise 7</h4>
<div class="paragraph">
<p>For <em>p</em> = 7, 11, 17, 31, what is this set in <em>F<sub>p</sub></em>?</p>
</div>
<ul class="simplelist">
<li>{1<sup>(<em>p</em> – 1)</sup>, 2<sup>(<em>p</em> – 1)</sup>, 3<sup>(<em>p</em> – 1)</sup>, 4<sup>(<em>p</em> – 1)</sup>, ... (<em>p</em> – 1)<sup>(<em>p</em> – 1)</sup>}</li>
</ul>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; for prime in (7, 11, 17, 31):
...     print([pow(i, prime-1, prime) for i in range(1, prime)])
[1, 1, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
1, 1, 1, 1, 1, 1]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_8_4">Exercise 8</h4>
<div class="paragraph">
<p>Solve the following equations in <em>F</em><sub>31</sub>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>3 / 24</p>
</li>
<li>
<p>17<sup>–3</sup></p>
</li>
<li>
<p>4<sup>–4</sup> ⋅ 11</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; prime = 31
&gt;&gt;&gt; print(3*pow(24, prime-2, prime) % prime)
4
&gt;&gt;&gt; print(pow(17, prime-4, prime))
29
&gt;&gt;&gt; print(pow(4, prime-5, prime)*11 % prime)
13</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_9_4">Exercise 9</h4>
<div class="paragraph">
<p>Write the corresponding <code><em>truediv</em></code> method that defines the division of two field elements.</p>
</div>
<div class="paragraph">
<p>Note that in Python 3, division is separated into <code><em>truediv</em></code> and <code><em>floordiv</em></code>. The first does normal division and the second does integer division.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class FieldElement:
...
    def __truediv__(self, other):
        if self.prime != other.prime:
            raise TypeError('Cannot divide two numbers in different Fields')
        # use Fermat's little theorem:
        # self.num**(p-1) % p == 1
        # this means:
        # 1/n == pow(n, p-2, p)
        # we return an element of the same class
        num = self.num * pow(other.num, self.prime - 2, self.prime) % self.prime
        return self.__class__(num, self.prime)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_elliptic_curves_elliptic_curves"><a href="#chapter_elliptic_curves">Elliptic Curves</a>: Elliptic Curves</h3>
<div class="sect3">
<h4 id="_exercise_1_14">Exercise 1</h4>
<div class="paragraph">
<p>Determine which of these points are on the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> + 7:</p>
</div>
<ul class="simplelist">
<li>(2,4), (–1,–1), (18,77), (5,7)</li>
</ul>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; def on_curve(x, y):
...     return y**2 == x**3 + 5*x + 7
&gt;&gt;&gt; print(on_curve(2,4))
False
&gt;&gt;&gt; print(on_curve(-1,-1))
True
&gt;&gt;&gt; print(on_curve(18,77))
True
&gt;&gt;&gt; print(on_curve(5,7))
False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_14">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code><em>ne</em></code> method for <code>Point</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:
...
    def __ne__(self, other):
        return not (self == other)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_14">Exercise 3</h4>
<div class="paragraph">
<p>Handle the case where the two points are additive inverses (that is, they have the same <code>x</code> but a different <code>y</code>, causing a vertical line). This should return the point at infinity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:
...
    if self.x == other.x and self.y != other.y:
        return self.__class__(None, None, self.a, self.b)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_14">Exercise 4</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> + 7, what is (2,5) + (–1,–1)?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; x1, y1 = 2, 5
&gt;&gt;&gt; x2, y2 = -1, -1
&gt;&gt;&gt; s = (y2 - y1) / (x2 - x1)
&gt;&gt;&gt; x3 = s**2 - x1 - x2
&gt;&gt;&gt; y3 = s * (x1 - x3) - y1
&gt;&gt;&gt; print(x3, y3)
3.0 -7.0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_13">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code><em>add</em></code> method where <em>x</em><sub>1</sub> ≠ <em>x</em><sub>2</sub>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:
...
    def __add__(self, other):
    ...
    if self.x != other.x:
        s = (other.y - self.y) / (other.x - self.x)
        x = s**2 - self.x - other.x
        y = s * (self.x - x) - self.y
        return self.__class__(x, y, self.a, self.b)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_11">Exercise 6</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 5<em>x</em> + 7, what is (–1,–1) + (–1,–1)?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; a, x1, y1 = 5, -1, -1
&gt;&gt;&gt; s = (3 * x1**2 + a) / (2 * y1)
&gt;&gt;&gt; x3 = s**2 - 2*x1
&gt;&gt;&gt; y3 = s*(x1-x3)-y1
&gt;&gt;&gt; print(x3,y3)
18.0 77.0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_8">Exercise 7</h4>
<div class="paragraph">
<p>Write the <code><em>add</em></code> method when <em>P</em><sub>1</sub> = <em>P</em><sub>2</sub>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Point:
...
    def __add__(self, other):
    ...
    if self == other:
        s = (3 * self.x**2 + self.a) / (2 * self.y)
        x = s**2 - 2 * self.x
        y = s * (self.x - x) - self.y
        return self.__class__(x, y, self.a, self.b)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_elliptic_curve_cryptography_elliptic_curve_cryptography"><a href="#chapter_elliptic_curve_cryptography">Elliptic Curve Cryptography</a>: Elliptic Curve Cryptography</h3>
<div class="sect3">
<h4 id="_exercise_1_15">Exercise 1</h4>
<div class="paragraph">
<p>Evaluate whether these points are on the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>:</p>
</div>
<ul class="simplelist">
<li>(192,105), (17,56), (200,119), (1,193), (42,99)</li>
</ul>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement
&gt;&gt;&gt; prime = 223
&gt;&gt;&gt; a = FieldElement(0, prime)
&gt;&gt;&gt; b = FieldElement(7, prime)
&gt;&gt;&gt; def on_curve(x,y):
...     return y**2 == x**3 + a*x + b
&gt;&gt;&gt; print(on_curve(FieldElement(192, prime), FieldElement(105, prime)))
True
&gt;&gt;&gt; print(on_curve(FieldElement(17, prime), FieldElement(56, prime)))
True
&gt;&gt;&gt; print(on_curve(FieldElement(200, prime), FieldElement(119, prime)))
False
&gt;&gt;&gt; print(on_curve(FieldElement(1, prime), FieldElement(193, prime)))
True
&gt;&gt;&gt; print(on_curve(FieldElement(42, prime), FieldElement(99, prime)))
False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_15">Exercise 2</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>, find:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(170,142) + (60,139)</p>
</li>
<li>
<p>(47,71) + (17,56)</p>
</li>
<li>
<p>(143,98) + (76,66)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement, Point
&gt;&gt;&gt; prime = 223
&gt;&gt;&gt; a = FieldElement(0, prime)
&gt;&gt;&gt; b = FieldElement(7, prime)
&gt;&gt;&gt; p1 = Point(FieldElement(170, prime), FieldElement(142, prime), a, b)
&gt;&gt;&gt; p2 = Point(FieldElement(60, prime), FieldElement(139, prime), a, b)
&gt;&gt;&gt; print(p1+p2)
Point(220,181)_0_7 FieldElement(223)
&gt;&gt;&gt; p1 = Point(FieldElement(47, prime), FieldElement(71, prime), a, b)
&gt;&gt;&gt; p2 = Point(FieldElement(17, prime), FieldElement(56, prime), a, b)
&gt;&gt;&gt; print(p1+p2)
Point(215,68)_0_7 FieldElement(223)
&gt;&gt;&gt; p1 = Point(FieldElement(143, prime), FieldElement(98, prime), a, b)
&gt;&gt;&gt; p2 = Point(FieldElement(76, prime), FieldElement(66, prime), a, b)
&gt;&gt;&gt; print(p1+p2)
Point(47,71)_0_7 FieldElement(223)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_15">Exercise 3</h4>
<div class="paragraph">
<p>Extend <code>ECCTest</code> to test for the additions from the previous exercise. Call this <code>test_add</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def test_add(self):
    prime = 223
    a = FieldElement(0, prime)
    b = FieldElement(7, prime)
    additions = (
        (192, 105, 17, 56, 170, 142),
        (47, 71, 117, 141, 60, 139),
        (143, 98, 76, 66, 47, 71),
    )
    for x1_raw, y1_raw, x2_raw, y2_raw, x3_raw, y3_raw in additions:
        x1 = FieldElement(x1_raw, prime)
        y1 = FieldElement(y1_raw, prime)
        p1 = Point(x1, y1, a, b)
        x2 = FieldElement(x2_raw, prime)
        y2 = FieldElement(y2_raw, prime)
        p2 = Point(x2, y2, a, b)
        x3 = FieldElement(x3_raw, prime)
        y3 = FieldElement(y3_raw, prime)
        p3 = Point(x3, y3, a, b)
        self.assertEqual(p1 + p2, p3)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_15">Exercise 4</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>, find:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2 ⋅ (192,105)</p>
</li>
<li>
<p>2 ⋅ (143,98)</p>
</li>
<li>
<p>2 ⋅ (47,71)</p>
</li>
<li>
<p>4 ⋅ (47,71)</p>
</li>
<li>
<p>8 ⋅ (47,71)</p>
</li>
<li>
<p>21 ⋅ (47,71)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import FieldElement, Point
&gt;&gt;&gt; prime = 223
&gt;&gt;&gt; a = FieldElement(0, prime)
&gt;&gt;&gt; b = FieldElement(7, prime)
&gt;&gt;&gt; x1 = FieldElement(num=192, prime=prime)
&gt;&gt;&gt; y1 = FieldElement(num=105, prime=prime)
&gt;&gt;&gt; p = Point(x1,y1,a,b)
&gt;&gt;&gt; print(p+p)
Point(49,71)_0_7 FieldElement(223)
&gt;&gt;&gt; x1 = FieldElement(num=143, prime=prime)
&gt;&gt;&gt; y1 = FieldElement(num=98, prime=prime)
&gt;&gt;&gt; p = Point(x1,y1,a,b)
&gt;&gt;&gt; print(p+p)
Point(64,168)_0_7 FieldElement(223)
&gt;&gt;&gt; x1 = FieldElement(num=47, prime=prime)
&gt;&gt;&gt; y1 = FieldElement(num=71, prime=prime)
&gt;&gt;&gt; p = Point(x1,y1,a,b)
&gt;&gt;&gt; print(p+p)
Point(36,111)_0_7 FieldElement(223)
&gt;&gt;&gt; print(p+p+p+p)
Point(194,51)_0_7 FieldElement(223)
&gt;&gt;&gt; print(p+p+p+p+p+p+p+p)
Point(116,55)_0_7 FieldElement(223)
&gt;&gt;&gt; print(p+p+p+p+p+p+p+p+p+p+p+p+p+p+p+p+p+p+p+p+p)
Point(infinity)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_14">Exercise 5</h4>
<div class="paragraph">
<p>For the curve <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + 7 over <em>F</em><sub>223</sub>, find the order of the group generated by (15,86).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; prime = 223
&gt;&gt;&gt; a = FieldElement(0, prime)
&gt;&gt;&gt; b = FieldElement(7, prime)
&gt;&gt;&gt; x = FieldElement(15, prime)
&gt;&gt;&gt; y = FieldElement(86, prime)
&gt;&gt;&gt; p = Point(x, y, a, b)
&gt;&gt;&gt; inf = Point(None, None, a, b)
&gt;&gt;&gt; product = p
&gt;&gt;&gt; count = 1
&gt;&gt;&gt; while product != inf:
...     product += p
...     count += 1
&gt;&gt;&gt; print(count)
7</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_12">Exercise 6</h4>
<div class="paragraph">
<p>Verify whether these signatures are valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>P = (0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c,
     0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34)

# signature 1
z = 0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60
r = 0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395
s = 0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4

# signature 2
z = 0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d
r = 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c
s = 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import S256Point, N, G
&gt;&gt;&gt; point = S256Point(
...     0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c,
...     0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34)
&gt;&gt;&gt; z = 0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60
&gt;&gt;&gt; r = 0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395
&gt;&gt;&gt; s = 0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4
&gt;&gt;&gt; u = z * pow(s, N-2, N) % N
&gt;&gt;&gt; v = r * pow(s, N-2, N) % N
&gt;&gt;&gt; print((u*G + v*point).x.num == r)
True
&gt;&gt;&gt; z = 0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d
&gt;&gt;&gt; r = 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c
&gt;&gt;&gt; s = 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6
&gt;&gt;&gt; u = z * pow(s, N-2, N) % N
&gt;&gt;&gt; v = r * pow(s, N-2, N) % N
&gt;&gt;&gt; print((u*G + v*point).x.num == r)
True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_9">Exercise 7</h4>
<div class="paragraph">
<p>Sign the following message with the secret:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>e = 12345
z = int.from_bytes(hash256('Programming Bitcoin!'), 'big')</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import S256Point, G, N
&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; e = 12345
&gt;&gt;&gt; z = int.from_bytes(hash256(b'Programming Bitcoin!'), 'big')
&gt;&gt;&gt; k = 1234567890
&gt;&gt;&gt; r = (k*G).x.num
&gt;&gt;&gt; k_inv = pow(k, N-2, N)
&gt;&gt;&gt; s = (z+r*e) * k_inv % N
&gt;&gt;&gt; print(e*G)
S256Point(f01d6b9018ab421dd410404cb869072065522bf85734008f105cf385a023a80f, \
0eba29d0f0c5408ed681984dc525982abefccd9f7ff01dd26da4999cf3f6a295)
&gt;&gt;&gt; print(hex(z))
0x969f6056aa26f7d2795fd013fe88868d09c9f6aed96965016e1936ae47060d48
&gt;&gt;&gt; print(hex(r))
0x2b698a0f0a4041b77e63488ad48c23e8e8838dd1fb7520408b121697b782ef22
&gt;&gt;&gt; print(hex(s))
0x1dbc63bfef4416705e602a7b564161167076d8b20990a0f26f316cff2cb0bc1a</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_serialization_serialization"><a href="#chapter_serialization">Serialization</a>: Serialization</h3>
<div class="sect3">
<h4 id="_exercise_1_16">Exercise 1</h4>
<div class="paragraph">
<p>Find the uncompressed SEC format for the public key where the private key secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5,000</p>
</li>
<li>
<p>2,018<sup>5</sup></p>
</li>
<li>
<p>0xdeadbeef12345</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; priv = PrivateKey(5000)
&gt;&gt;&gt; print(priv.point.sec(compressed=False).hex())
04ffe558e388852f0120e46af2d1b370f85854a8eb0841811ece0e3e03d282d57c315dc72890a4\
f10a1481c031b03b351b0dc79901ca18a00cf009dbdb157a1d10
&gt;&gt;&gt; priv = PrivateKey(2018**5)
&gt;&gt;&gt; print(priv.point.sec(compressed=False).hex())
04027f3da1918455e03c46f659266a1bb5204e959db7364d2f473bdf8f0a13cc9dff87647fd023\
c13b4a4994f17691895806e1b40b57f4fd22581a4f46851f3b06
&gt;&gt;&gt; priv = PrivateKey(0xdeadbeef12345)
&gt;&gt;&gt; print(priv.point.sec(compressed=False).hex())
04d90cd625ee87dd38656dd95cf79f65f60f7273b67d3096e68bd81e4f5342691f842efa762fd5\
9961d0e99803c61edba8b3e3f7dc3a341836f97733aebf987121</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_16">Exercise 2</h4>
<div class="paragraph">
<p>Find the compressed SEC format for the public key where the private key secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5,001</p>
</li>
<li>
<p>2,019<sup>5</sup></p>
</li>
<li>
<p>0xdeadbeef54321</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; priv = PrivateKey(5001)
&gt;&gt;&gt; print(priv.point.sec(compressed=True).hex())
0357a4f368868a8a6d572991e484e664810ff14c05c0fa023275251151fe0e53d1
&gt;&gt;&gt; priv = PrivateKey(2019**5)
&gt;&gt;&gt; print(priv.point.sec(compressed=True).hex())
02933ec2d2b111b92737ec12f1c5d20f3233a0ad21cd8b36d0bca7a0cfa5cb8701
&gt;&gt;&gt; priv = PrivateKey(0xdeadbeef54321)
&gt;&gt;&gt; print(priv.point.sec(compressed=True).hex())
0296be5b1292f6c856b3c5654e886fc13511462059089cdf9c479623bfcbe77690</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_16">Exercise 3</h4>
<div class="paragraph">
<p>Find the DER format for a signature whose <code>r</code> and <code>s</code> values are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>r = 0x37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6

s = 0x8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import Signature
&gt;&gt;&gt; r = 0x37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6
&gt;&gt;&gt; s = 0x8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec
&gt;&gt;&gt; sig = Signature(r,s)
&gt;&gt;&gt; print(sig.der().hex())
3045022037206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6022100\
8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_16">Exercise 4</h4>
<div class="paragraph">
<p>Convert the following hex values to binary and then to Base58:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d</code></p>
</li>
<li>
<p><code>eff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c</code></p>
</li>
<li>
<p><code>c7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import encode_base58
&gt;&gt;&gt; h = '7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d'
&gt;&gt;&gt; print(encode_base58(bytes.fromhex(h)))
9MA8fRQrT4u8Zj8ZRd6MAiiyaxb2Y1CMpvVkHQu5hVM6
&gt;&gt;&gt; h = 'eff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c'
&gt;&gt;&gt; print(encode_base58(bytes.fromhex(h)))
4fE3H2E6XMp4SsxtwinF7w9a34ooUrwWe4WsW1458Pd
&gt;&gt;&gt; h = 'c7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6'
&gt;&gt;&gt; print(encode_base58(bytes.fromhex(h)))
EQJsjkd6JaGwxrjEhfeqPenqHwrBmPQZjJGNSCHBkcF7</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_15">Exercise 5</h4>
<div class="paragraph">
<p>Find the addresses corresponding to the public keys whose private key secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5002 (use uncompressed SEC on testnet)</p>
</li>
<li>
<p>2020<sup>5</sup> (use compressed SEC on testnet)</p>
</li>
<li>
<p>0x12345deadbeef (use compressed SEC on mainnet)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; priv = PrivateKey(5002)
&gt;&gt;&gt; print(priv.point.address(compressed=False, testnet=True))
mmTPbXQFxboEtNRkwfh6K51jvdtHLxGeMA
&gt;&gt;&gt; priv = PrivateKey(2020**5)
&gt;&gt;&gt; print(priv.point.address(compressed=True, testnet=True))
mopVkxp8UhXqRYbCYJsbeE1h1fiF64jcoH
&gt;&gt;&gt; priv = PrivateKey(0x12345deadbeef)
&gt;&gt;&gt; print(priv.point.address(compressed=True, testnet=False))
1F1Pn2y6pDb68E5nYJJeba4TLg2U7B6KF1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_13">Exercise 6</h4>
<div class="paragraph">
<p>Find the WIF for the private key whose secrets are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5003 (compressed, testnet)</p>
</li>
<li>
<p>2021<sup>5</sup> (uncompressed, testnet)</p>
</li>
<li>
<p>0x54321deadbeef (compressed, mainnet)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; priv = PrivateKey(5003)
&gt;&gt;&gt; print(priv.wif(compressed=True, testnet=True))
cMahea7zqjxrtgAbB7LSGbcQUr1uX1ojuat9jZodMN8rFTv2sfUK
&gt;&gt;&gt; priv = PrivateKey(2021**5)
&gt;&gt;&gt; print(priv.wif(compressed=False, testnet=True))
91avARGdfge8E4tZfYLoxeJ5sGBdNJQH4kvjpWAxgzczjbCwxic
&gt;&gt;&gt; priv = PrivateKey(0x54321deadbeef)
&gt;&gt;&gt; print(priv.wif(compressed=True, testnet=False))
KwDiBf89QgGbjEhKnhXJuH7LrciVrZi3qYjgiuQJv1h8Ytr2S53a</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_10">Exercise 7</h4>
<div class="paragraph">
<p>Write a function <code>little_endian_to_int</code> that takes Python bytes, interprets those bytes in little-endian, and returns the number.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def little_endian_to_int(b):
    '''little_endian_to_int takes byte sequence as a little-endian number.
    Returns an integer'''
    return int.from_bytes(b, 'little')</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_8_5">Exercise 8</h4>
<div class="paragraph">
<p>Write a function <code>int_to_little_endian</code> that does the reverse of the last exercise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def int_to_little_endian(n, length):
    '''endian_to_little_endian takes an integer and returns the little-endian
    byte sequence of length'''
    return n.to_bytes(length, 'little')</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_9_5">Exercise 9</h4>
<div class="paragraph">
<p>Create a testnet address for yourself using a long secret that only you know. This is important as there are bots on testnet trying to steal testnet coins. Make sure you write this secret down somewhere! You will be using it later to sign transactions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; from helper import hash256, little_endian_to_int
&gt;&gt;&gt; passphrase = b'jimmy@programmingblockchain.com my secret'
&gt;&gt;&gt; secret = little_endian_to_int(hash256(passphrase))
&gt;&gt;&gt; priv = PrivateKey(secret)
&gt;&gt;&gt; print(priv.point.address(testnet=True))
mft9LRNtaBNtpkknB8xgm17UvPedZ4ecYL</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transactions_transactions"><a href="#chapter_tx_parsing">Transactions</a>: Transactions</h3>
<div class="sect3">
<h4 id="_exercise_1_17">Exercise 1</h4>
<div class="paragraph">
<p>Write the version parsing part of the <code>parse</code> method that we&#8217;ve defined. To do this properly, you&#8217;ll have to convert 4 bytes into a little-endian integer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
@classmethod
def parse(cls, s, testnet=False):
    version = little_endian_to_int(s.read(4))
    return cls(version, None, None, None, testnet=testnet)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_17">Exercise 2</h4>
<div class="paragraph">
<p>Write the inputs parsing part of the <code>parse</code> method in <code>Tx</code> and the <code>parse</code> method for <code>TxIn</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    @classmethod
    def parse(cls, s, testnet=False):
        version = little_endian_to_int(s.read(4))
        num_inputs = read_varint(s)
        inputs = []
        for _ in range(num_inputs):
            inputs.append(TxIn.parse(s))
        return cls(version, inputs, None, None, testnet=testnet)
...

class TxIn:
...
    @classmethod
    def parse(cls, s):
        '''Takes a byte stream and parses the tx_input at the start.
        Returns a TxIn object.
        '''
        prev_tx = s.read(32)[::-1]
        prev_index = little_endian_to_int(s.read(4))
        script_sig = Script.parse(s)
        sequence = little_endian_to_int(s.read(4))
        return cls(prev_tx, prev_index, script_sig, sequence)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_17">Exercise 3</h4>
<div class="paragraph">
<p>Write the outputs parsing part of the <code>parse</code> method in <code>Tx</code> and the <code>parse</code> method for <code>TxOut</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
class Tx:
...
    @classmethod
    def parse(cls, s, testnet=False):
        version = little_endian_to_int(s.read(4))
        num_inputs = read_varint(s)
        inputs = []
        for _ in range(num_inputs):
            inputs.append(TxIn.parse(s))
        num_outputs = read_varint(s)
        outputs = []
        for _ in range(num_outputs):
            outputs.append(TxOut.parse(s))
        return cls(version, inputs, outputs, None, testnet=testnet)
...

class TxOut:
...
    @classmethod
    def parse(cls, s):
        '''Takes a byte stream and parses the tx_output at the start.
        Returns a TxOut object.
        '''
        amount = little_endian_to_int(s.read(8))
        script_pubkey = Script.parse(s)
        return cls(amount, script_pubkey)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_17">Exercise 4</h4>
<div class="paragraph">
<p>Write the locktime parsing part of the <code>parse</code> method in <code>Tx</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
@classmethod
def parse(cls, s, testnet=False):
    version = little_endian_to_int(s.read(4))
    num_inputs = read_varint(s)
    inputs = []
    for _ in range(num_inputs):
        inputs.append(TxIn.parse(s))
    num_outputs = read_varint(s)
    outputs = []
    for _ in range(num_outputs):
        outputs.append(TxOut.parse(s))
    locktime = little_endian_to_int(s.read(4))
    return cls(version, inputs, outputs, locktime, testnet=testnet)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_16">Exercise 5</h4>
<div class="paragraph">
<p>What are the ScriptSig of the second input, the ScriptPubKey of the first output, and the amount of the second output for this transaction?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>010000000456919960ac691763688d3d3bcea9ad6ecaf875df5339e148a1fc61c6ed7a069e0100
00006a47304402204585bcdef85e6b1c6af5c2669d4830ff86e42dd205c0e089bc2a821657e951
c002201024a10366077f87d6bce1f7100ad8cfa8a064b39d4e8fe4ea13a7b71aa8180f012102f0
da57e85eec2934a82a585ea337ce2f4998b50ae699dd79f5880e253dafafb7feffffffeb8f51f4
038dc17e6313cf831d4f02281c2a468bde0fafd37f1bf882729e7fd3000000006a473044022078
99531a52d59a6de200179928ca900254a36b8dff8bb75f5f5d71b1cdc26125022008b422690b84
61cb52c3cc30330b23d574351872b7c361e9aae3649071c1a7160121035d5c93d9ac96881f19ba
1f686f15f009ded7c62efe85a872e6a19b43c15a2937feffffff567bf40595119d1bb8a3037c35
6efd56170b64cbcc160fb028fa10704b45d775000000006a47304402204c7c7818424c7f7911da
6cddc59655a70af1cb5eaf17c69dadbfc74ffa0b662f02207599e08bc8023693ad4e9527dc42c3
4210f7a7d1d1ddfc8492b654a11e7620a0012102158b46fbdff65d0172b7989aec8850aa0dae49
abfb84c81ae6e5b251a58ace5cfeffffffd63a5e6c16e620f86f375925b21cabaf736c779f88fd
04dcad51d26690f7f345010000006a47304402200633ea0d3314bea0d95b3cd8dadb2ef79ea833
1ffe1e61f762c0f6daea0fabde022029f23b3e9c30f080446150b23852028751635dcee2be669c
2a1686a4b5edf304012103ffd6f4a67e94aba353a00882e563ff2722eb4cff0ad6006e86ee20df
e7520d55feffffff0251430f00000000001976a914ab0c0b2e98b1ab6dbf67d4750b0a56244948
a87988ac005a6202000000001976a9143c82d7df364eb6c75be8c80df2b3eda8db57397088ac46
430600</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from tx import Tx
&gt;&gt;&gt; hex_transaction = '010000000456919960ac691763688d3d3bcea9ad6ecaf875df5339e\
148a1fc61c6ed7a069e010000006a47304402204585bcdef85e6b1c6af5c2669d4830ff86e42dd\
205c0e089bc2a821657e951c002201024a10366077f87d6bce1f7100ad8cfa8a064b39d4e8fe4e\
a13a7b71aa8180f012102f0da57e85eec2934a82a585ea337ce2f4998b50ae699dd79f5880e253\
dafafb7feffffffeb8f51f4038dc17e6313cf831d4f02281c2a468bde0fafd37f1bf882729e7fd\
3000000006a47304402207899531a52d59a6de200179928ca900254a36b8dff8bb75f5f5d71b1c\
dc26125022008b422690b8461cb52c3cc30330b23d574351872b7c361e9aae3649071c1a716012\
1035d5c93d9ac96881f19ba1f686f15f009ded7c62efe85a872e6a19b43c15a2937feffffff567\
bf40595119d1bb8a3037c356efd56170b64cbcc160fb028fa10704b45d775000000006a4730440\
2204c7c7818424c7f7911da6cddc59655a70af1cb5eaf17c69dadbfc74ffa0b662f02207599e08\
bc8023693ad4e9527dc42c34210f7a7d1d1ddfc8492b654a11e7620a0012102158b46fbdff65d0\
172b7989aec8850aa0dae49abfb84c81ae6e5b251a58ace5cfeffffffd63a5e6c16e620f86f375\
925b21cabaf736c779f88fd04dcad51d26690f7f345010000006a47304402200633ea0d3314bea\
0d95b3cd8dadb2ef79ea8331ffe1e61f762c0f6daea0fabde022029f23b3e9c30f080446150b23\
852028751635dcee2be669c2a1686a4b5edf304012103ffd6f4a67e94aba353a00882e563ff272\
2eb4cff0ad6006e86ee20dfe7520d55feffffff0251430f00000000001976a914ab0c0b2e98b1a\
b6dbf67d4750b0a56244948a87988ac005a6202000000001976a9143c82d7df364eb6c75be8c80\
df2b3eda8db57397088ac46430600'
&gt;&gt;&gt; stream = BytesIO(bytes.fromhex(hex_transaction))
&gt;&gt;&gt; tx_obj = Tx.parse(stream)
&gt;&gt;&gt; print(tx_obj.tx_ins[1].script_sig)
304402207899531a52d59a6de200179928ca900254a36b8dff8bb75f5f5d71b1cdc26125022008\
b422690b8461cb52c3cc30330b23d574351872b7c361e9aae3649071c1a71601 035d5c93d9ac9\
6881f19ba1f686f15f009ded7c62efe85a872e6a19b43c15a2937
&gt;&gt;&gt; print(tx_obj.tx_outs[0].script_pubkey)
OP_DUP OP_HASH160 ab0c0b2e98b1ab6dbf67d4750b0a56244948a879 \
OP_EQUALVERIFY OP_CHECKSIG
&gt;&gt;&gt; print(tx_obj.tx_outs[1].amount)
40000000</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_14">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>fee</code> method for the <code>Tx</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def fee(self, testnet=False):
        input_sum, output_sum = 0, 0
        for tx_in in self.tx_ins:
            input_sum += tx_in.value(testnet=testnet)
        for tx_out in self.tx_outs:
            output_sum += tx_out.amount
        return input_sum - output_sum</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_script_script"><a href="#chapter_script">Script</a>: Script</h3>
<div class="sect3">
<h4 id="_exercise_1_18">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>op_hash160</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def op_hash160(stack):
    if len(stack) &lt; 1:
        return False
    element = stack.pop()
    h160 = hash160(element)
    stack.append(h160)
    return True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_18">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>op_checksig</code> function in <em>op.py</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def op_checksig(stack, z):
    if len(stack) &lt; 2:
        return False
    sec_pubkey = stack.pop()
    der_signature = stack.pop()[:-1]
    try:
        point = S256Point.parse(sec_pubkey)
        sig = Signature.parse(der_signature)
    except (ValueError, SyntaxError) as e:
        return False
    if point.verify(z, sig):
        stack.append(encode_num(1))
    else:
        stack.append(encode_num(0))
    return True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_18">Exercise 3</h4>
<div class="paragraph">
<p>Create a ScriptSig that can unlock this ScriptPubKey:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>767695935687</pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>OP_MUL</code> multiplies the top two elements of the stack.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>56 = OP_6</code></p>
</li>
<li>
<p><code>76 = OP_DUP</code></p>
</li>
<li>
<p><code>87 = OP_EQUAL</code></p>
</li>
<li>
<p><code>93 = OP_ADD</code></p>
</li>
<li>
<p><code>95 = OP_MUL</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from script import Script
&gt;&gt;&gt; script_pubkey = Script([0x76, 0x76, 0x95, 0x93, 0x56, 0x87])
&gt;&gt;&gt; script_sig = Script([0x52])
&gt;&gt;&gt; combined_script = script_sig + script_pubkey
&gt;&gt;&gt; print(combined_script.evaluate(0))
True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OP_2</code> or <code>52</code> will satisfy the equation <em>x</em><sup>2</sup> + <em>x</em> – 6 = 0.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_18">Exercise 4</h4>
<div class="paragraph">
<p>Figure out what this script is doing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>6e879169a77ca787</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>69 = OP_VERIFY</code></p>
</li>
<li>
<p><code>6e = OP_2DUP</code></p>
</li>
<li>
<p><code>7c = OP_SWAP</code></p>
</li>
<li>
<p><code>87 = OP_EQUAL</code></p>
</li>
<li>
<p><code>91 = OP_NOT</code></p>
</li>
<li>
<p><code>a7 = OP_SHA1</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use the <code>Script.parse</code> method and look up what various opcodes do at <a href="https://en.bitcoin.it/wiki/Script" class="bare">https://en.bitcoin.it/wiki/Script</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from script import Script
&gt;&gt;&gt; script_pubkey = Script([0x6e, 0x87, 0x91, 0x69, 0xa7, 0x7c, 0xa7, 0x87])
&gt;&gt;&gt; c1 = '255044462d312e330a25e2e3cfd30a0a0a312030206f626a0a3c3c2f576964746820\
32203020522f4865696768742033203020522f547970652034203020522f537562747970652035\
203020522f46696c7465722036203020522f436f6c6f7253706163652037203020522f4c656e67\
74682038203020522f42697473506572436f6d706f6e656e7420383e3e0a73747265616d0affd8\
fffe00245348412d3120697320646561642121212121852fec092339759c39b1a1c63c4c97e1ff\
fe017f46dc93a6b67e013b029aaa1db2560b45ca67d688c7f84b8c4c791fe02b3df614f86db169\
0901c56b45c1530afedfb76038e972722fe7ad728f0e4904e046c230570fe9d41398abe12ef5bc\
942be33542a4802d98b5d70f2a332ec37fac3514e74ddc0f2cc1a874cd0c78305a215664613097\
89606bd0bf3f98cda8044629a1'
&gt;&gt;&gt; c2 = '255044462d312e330a25e2e3cfd30a0a0a312030206f626a0a3c3c2f576964746820\
32203020522f4865696768742033203020522f547970652034203020522f537562747970652035\
203020522f46696c7465722036203020522f436f6c6f7253706163652037203020522f4c656e67\
74682038203020522f42697473506572436f6d706f6e656e7420383e3e0a73747265616d0affd8\
fffe00245348412d3120697320646561642121212121852fec092339759c39b1a1c63c4c97e1ff\
fe017346dc9166b67e118f029ab621b2560ff9ca67cca8c7f85ba84c79030c2b3de218f86db3a9\
0901d5df45c14f26fedfb3dc38e96ac22fe7bd728f0e45bce046d23c570feb141398bb552ef5a0\
a82be331fea48037b8b5d71f0e332edf93ac3500eb4ddc0decc1a864790c782c76215660dd3097\
91d06bd0af3f98cda4bc4629b1'
&gt;&gt;&gt; collision1 = bytes.fromhex(c1)  # <b class="conum">(1)</b>
&gt;&gt;&gt; collision2 = bytes.fromhex(c2)
&gt;&gt;&gt; script_sig = Script([collision1, collision2])
&gt;&gt;&gt; combined_script = script_sig + script_pubkey
&gt;&gt;&gt; print(combined_script.evaluate(0))
True</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>collision1</code> and <code>collision2</code> are from the SHA-1 preimages that <a href="http://bit.ly/2HZF3om">Google found to collide</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is looking for a SHA-1 collision. The only way to satisfy this script is to give <code>x</code> and <code>y</code> such that <code>x≠y</code> but <code>sha1(x)=sha1(y)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_creation_and_validation_transaction_creation_and_validation"><a href="#chapter_tx">Transaction Creation and Validation</a>: Transaction Creation and Validation</h3>
<div class="sect3">
<h4 id="_exercise_1_19">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>sig_hash</code> method for the <code>Tx</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def sig_hash(self, input_index):
        s = int_to_little_endian(self.version, 4)
        s += encode_varint(len(self.tx_ins))
        for i, tx_in in enumerate(self.tx_ins):
            if i == input_index:
                s += TxIn(
                    prev_tx=tx_in.prev_tx,
                    prev_index=tx_in.prev_index,
                    script_sig=tx_in.script_pubkey(self.testnet),
                    sequence=tx_in.sequence,
                ).serialize()
            else:
                s += TxIn(
                    prev_tx=tx_in.prev_tx,
                    prev_index=tx_in.prev_index,
                    sequence=tx_in.sequence,
                ).serialize()
        s += encode_varint(len(self.tx_outs))
        for tx_out in self.tx_outs:
            s += tx_out.serialize()
        s += int_to_little_endian(self.locktime, 4)
        s += int_to_little_endian(SIGHASH_ALL, 4)
        h256 = hash256(s)
        return int.from_bytes(h256, 'big')</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_19">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>verify_input</code> method for the <code>Tx</code> class. You will want to use the <code>TxIn.script_pubkey</code>, <code>Tx.sig_hash</code>, and <code>Script.evaluate</code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def verify_input(self, input_index):
        tx_in = self.tx_ins[input_index]
        script_pubkey = tx_in.script_pubkey(testnet=self.testnet)
        z = self.sig_hash(input_index)
        combined = tx_in.script_sig + script_pubkey
        return combined.evaluate(z)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_19">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>sign_input</code> method for the <code>Tx</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def sign_input(self, input_index, private_key):
        z = self.sig_hash(input_index)
        der = private_key.sign(z).der()
        sig = der + SIGHASH_ALL.to_bytes(1, 'big')
        sec = private_key.point.sec()
        self.tx_ins[input_index].script_sig = Script([sig, sec])
        return self.verify_input(input_index)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_19">Exercise 4</h4>
<div class="paragraph">
<p>Create a testnet transaction that sends 60% of a single UTXO to <code>mwJn1YPMq7y5F8J3LkC5Hxg9PHyZ5K4cFv</code>. The remaining amount minus fees should go back to your own change address. This should be a one-input, two-output <span class="keep-together">transaction</span>.</p>
</div>
<div class="paragraph">
<p>You can broadcast the transaction at <a href="https://blockstream.info/testnet/tx/push" class="bare">https://blockstream.info/testnet/tx/push</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; from helper import decode_base58, SIGHASH_ALL
&gt;&gt;&gt; from script import p2pkh_script, Script
&gt;&gt;&gt; from tx import TxIn, TxOut, Tx
&gt;&gt;&gt; prev_tx = bytes.fromhex('75a1c4bc671f55f626dda1074c7725991e6f68b8fcefcfca7\
b64405ca3b45f1c')
&gt;&gt;&gt; prev_index = 1
&gt;&gt;&gt; target_address = 'miKegze5FQNCnGw6PKyqUbYUeBa4x2hFeM'
&gt;&gt;&gt; target_amount = 0.01
&gt;&gt;&gt; change_address = 'mzx5YhAH9kNHtcN481u6WkjeHjYtVeKVh2'
&gt;&gt;&gt; change_amount = 0.009
&gt;&gt;&gt; secret = 8675309
&gt;&gt;&gt; priv = PrivateKey(secret=secret)
&gt;&gt;&gt; tx_ins = []
&gt;&gt;&gt; tx_ins.append(TxIn(prev_tx, prev_index))
&gt;&gt;&gt; tx_outs = []
&gt;&gt;&gt; h160 = decode_base58(target_address)
&gt;&gt;&gt; script_pubkey = p2pkh_script(h160)
&gt;&gt;&gt; target_satoshis = int(target_amount*100000000)
&gt;&gt;&gt; tx_outs.append(TxOut(target_satoshis, script_pubkey))
&gt;&gt;&gt; h160 = decode_base58(change_address)
&gt;&gt;&gt; script_pubkey = p2pkh_script(h160)
&gt;&gt;&gt; change_satoshis = int(change_amount*100000000)
&gt;&gt;&gt; tx_outs.append(TxOut(change_satoshis, script_pubkey))
&gt;&gt;&gt; tx_obj = Tx(1, tx_ins, tx_outs, 0, testnet=True)
&gt;&gt;&gt; print(tx_obj.sign_input(0, priv))
True
&gt;&gt;&gt; print(tx_obj.serialize().hex())
01000000011c5fb4a35c40647bcacfeffcb8686f1e9925774c07a1dd26f6551f67bcc4a1750100\
00006b483045022100a08ebb92422b3599a2d2fcdaa11f8f807a66ccf33e7f4a9ff0a3c51f1b1e\
c5dd02205ed21dfede5925362b8d9833e908646c54be7ac6664e31650159e8f69b6ca539012103\
935581e52c354cd2f484fe8ed83af7a3097005b2f9c60bff71d35bd795f54b67ffffffff024042\
0f00000000001976a9141ec51b3654c1f1d0f4929d11a1f702937eaf50c888ac9fbb0d00000000\
001976a914d52ad7ca9b3d096a38e752c2018e6fbc40cdf26f88ac00000000</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_17">Exercise 5</h4>
<div class="paragraph">
<p>Advanced: Get some more testnet coins from a testnet faucet and create a two-input, one-output transaction. One input should be from the faucet, the other should be from the previous exercise; the output can be your own address.</p>
</div>
<div class="paragraph">
<p>You can broadcast the transaction at <a href="https://blockstream.info/testnet/tx/push" class="bare">https://blockstream.info/testnet/tx/push</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; from helper import decode_base58, SIGHASH_ALL
&gt;&gt;&gt; from script import p2pkh_script, Script
&gt;&gt;&gt; from tx import TxIn, TxOut, Tx
&gt;&gt;&gt; prev_tx_1 = bytes.fromhex('11d05ce707c1120248370d1cbf5561d22c4f83aeba04367\
92c82e0bd57fe2a2f')
&gt;&gt;&gt; prev_index_1 = 1
&gt;&gt;&gt; prev_tx_2 = bytes.fromhex('51f61f77bd061b9a0da60d4bedaaf1b1fad0c11e65fdc74\
4797ee22d20b03d15')
&gt;&gt;&gt; prev_index_2 = 1
&gt;&gt;&gt; target_address = 'mwJn1YPMq7y5F8J3LkC5Hxg9PHyZ5K4cFv'
&gt;&gt;&gt; target_amount = 0.0429
&gt;&gt;&gt; secret = 8675309
&gt;&gt;&gt; priv = PrivateKey(secret=secret)
&gt;&gt;&gt; tx_ins = []
&gt;&gt;&gt; tx_ins.append(TxIn(prev_tx_1, prev_index_1))
&gt;&gt;&gt; tx_ins.append(TxIn(prev_tx_2, prev_index_2))
&gt;&gt;&gt; tx_outs = []
&gt;&gt;&gt; h160 = decode_base58(target_address)
&gt;&gt;&gt; script_pubkey = p2pkh_script(h160)
&gt;&gt;&gt; target_satoshis = int(target_amount*100000000)
&gt;&gt;&gt; tx_outs.append(TxOut(target_satoshis, script_pubkey))
&gt;&gt;&gt; tx_obj = Tx(1, tx_ins, tx_outs, 0, testnet=True)
&gt;&gt;&gt; print(tx_obj.sign_input(0, priv))
True
&gt;&gt;&gt; print(tx_obj.sign_input(1, priv))
True
&gt;&gt;&gt; print(tx_obj.serialize().hex())
01000000022f2afe57bde0822c793604baae834f2cd26155bf1c0d37480212c107e75cd0110100\
00006a47304402204cc5fe11b2b025f8fc9f6073b5e3942883bbba266b71751068badeb8f11f03\
64022070178363f5dea4149581a4b9b9dbad91ec1fd990e3fa14f9de3ccb421fa5b26901210393\
5581e52c354cd2f484fe8ed83af7a3097005b2f9c60bff71d35bd795f54b67ffffffff153db020\
2de27e7944c7fd651ec1d0fab1f1aaed4b0da60d9a1b06bd771ff651010000006b483045022100\
b7a938d4679aa7271f0d32d83b61a85eb0180cf1261d44feaad23dfd9799dafb02205ff2f366dd\
d9555f7146861a8298b7636be8b292090a224c5dc84268480d8be1012103935581e52c354cd2f4\
84fe8ed83af7a3097005b2f9c60bff71d35bd795f54b67ffffffff01d0754100000000001976a9\
14ad346f8eb57dee9a37981716e498120ae80e44f788ac00000000</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pay_to_script_hash_pay_to_script_hash"><a href="#chapter_p2sh">Pay-to-Script Hash</a>: Pay to Script Hash</h3>
<div class="sect3">
<h4 id="_exercise_1_20">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>op_checkmultisig</code> function of <em>op.py</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def op_checkmultisig(stack, z):
    if len(stack) &lt; 1:
        return False
    n = decode_num(stack.pop())
    if len(stack) &lt; n + 1:
        return False
    sec_pubkeys = []
    for _ in range(n):
        sec_pubkeys.append(stack.pop())
    m = decode_num(stack.pop())
    if len(stack) &lt; m + 1:
        return False
    der_signatures = []
    for _ in range(m):
        der_signatures.append(stack.pop()[:-1])
    stack.pop()
    try:
        points = [S256Point.parse(sec) for sec in sec_pubkeys]
        sigs = [Signature.parse(der) for der in der_signatures]
        for sig in sigs:
            if len(points) == 0:
                return False
            while points:
                point = points.pop(0)
                if point.verify(z, sig):
                    break
        stack.append(encode_num(1))
    except (ValueError, SyntaxError):
        return False
    return True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_20">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>h160_to_p2pkh_address</code> function that converts a 20-byte hash160 into a p2pkh address.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def h160_to_p2pkh_address(h160, testnet=False):
    if testnet:
        prefix = b'\x6f'
    else:
        prefix = b'\x00'
    return encode_base58_checksum(prefix + h160)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_20">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>h160_to_p2sh_address</code> function that converts a 20-byte hash160 into a p2sh address.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def h160_to_p2sh_address(h160, testnet=False):
    if testnet:
        prefix = b'\xc4'
    else:
        prefix = b'\x05'
    return encode_base58_checksum(prefix + h160)</code></pre>
</div>
</div>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_exercise_4_20">Exercise 4</h4>
<div class="paragraph">
<p>Validate the second signature from the preceding transaction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from ecc import S256Point, Signature
&gt;&gt;&gt; from helper import hash256, int_to_little_endian
&gt;&gt;&gt; from script import Script
&gt;&gt;&gt; from tx import Tx, SIGHASH_ALL
&gt;&gt;&gt; hex_tx = '0100000001868278ed6ddfb6c1ed3ad5f8181eb0c7a385aa0836f01d5e4789e6\
bd304d87221a000000db00483045022100dc92655fe37036f47756db8102e0d7d5e28b3beb83a8\
fef4f5dc0559bddfb94e02205a36d4e4e6c7fcd16658c50783e00c341609977aed3ad00937bf4e\
e942a8993701483045022100da6bee3c93766232079a01639d07fa869598749729ae323eab8eef\
53577d611b02207bef15429dcadce2121ea07f233115c6f09034c0be68db99980b9a6c5e754022\
01475221022626e955ea6ea6d98850c994f9107b036b1334f18ca8830bfff1295d21cfdb702103\
b287eaf122eea69030a0e9feed096bed8045c8b98bec453e1ffac7fbdbd4bb7152aeffffffff04\
d3b11400000000001976a914904a49878c0adfc3aa05de7afad2cc15f483a56a88ac7f40090000\
0000001976a914418327e3f3dda4cf5b9089325a4b95abdfa0334088ac722c0c00000000001976\
a914ba35042cfe9fc66fd35ac2224eebdafd1028ad2788acdc4ace020000000017a91474d691da\
1574e6b3c192ecfb52cc8984ee7b6c568700000000'
&gt;&gt;&gt; hex_sec = '03b287eaf122eea69030a0e9feed096bed8045c8b98bec453e1ffac7fbdbd4b\
b71'
&gt;&gt;&gt; hex_der = '3045022100da6bee3c93766232079a01639d07fa869598749729ae323eab8ee\
f53577d611b02207bef15429dcadce2121ea07f233115c6f09034c0be68db99980b9a6c5e75402\
2'
&gt;&gt;&gt; hex_redeem_script = '475221022626e955ea6ea6d98850c994f9107b036b1334f18ca88\
30bfff1295d21cfdb702103b287eaf122eea69030a0e9feed096bed8045c8b98bec453e1ffac7f\
bdbd4bb7152ae'
&gt;&gt;&gt; sec = bytes.fromhex(hex_sec)
&gt;&gt;&gt; der = bytes.fromhex(hex_der)
&gt;&gt;&gt; redeem_script = Script.parse(BytesIO(bytes.fromhex(hex_redeem_script)))
&gt;&gt;&gt; stream = BytesIO(bytes.fromhex(hex_tx))
&gt;&gt;&gt; tx_obj = Tx.parse(stream)
&gt;&gt;&gt; s = int_to_little_endian(tx_obj.version, 4)
&gt;&gt;&gt; s += encode_varint(len(tx_obj.tx_ins))
&gt;&gt;&gt; i = tx_obj.tx_ins[0]
&gt;&gt;&gt; s += TxIn(i.prev_tx, i.prev_index, redeem_script, i.sequence).serialize()
&gt;&gt;&gt; s += encode_varint(len(tx_obj.tx_outs))
&gt;&gt;&gt; for tx_out in tx_obj.tx_outs:
...    s += tx_out.serialize()
&gt;&gt;&gt; s += int_to_little_endian(tx_obj.locktime, 4)
&gt;&gt;&gt; s += int_to_little_endian(SIGHASH_ALL, 4)
&gt;&gt;&gt; z = int.from_bytes(hash256(s), 'big')
&gt;&gt;&gt; point = S256Point.parse(sec)
&gt;&gt;&gt; sig = Signature.parse(der)
&gt;&gt;&gt; print(point.verify(z, sig))
True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_18">Exercise 5</h4>
<div class="paragraph">
<p>Modify the <code>sig_hash</code> and <code>verify_input</code> methods to be able to verify p2sh <span class="keep-together">transactions</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def sig_hash(self, input_index, redeem_script=None):
        '''Returns the integer representation of the hash that needs to get
        signed for index input_index'''
        s = int_to_little_endian(self.version, 4)
        s += encode_varint(len(self.tx_ins))
        for i, tx_in in enumerate(self.tx_ins):
            if i == input_index:
                if redeem_script:
                    script_sig = redeem_script
                else:
                    script_sig = tx_in.script_pubkey(self.testnet)
            else:
                script_sig = None
            s += TxIn(
                prev_tx=tx_in.prev_tx,
                prev_index=tx_in.prev_index,
                script_sig=script_sig,
                sequence=tx_in.sequence,
            ).serialize()
        s += encode_varint(len(self.tx_outs))
        for tx_out in self.tx_outs:
            s += tx_out.serialize()
        s += int_to_little_endian(self.locktime, 4)
        s += int_to_little_endian(SIGHASH_ALL, 4)
        h256 = hash256(s)
        return int.from_bytes(h256, 'big')


    def verify_input(self, input_index):
        tx_in = self.tx_ins[input_index]
        script_pubkey = tx_in.script_pubkey(testnet=self.testnet)
        if script_pubkey.is_p2sh_script_pubkey():
            cmd = tx_in.script_sig.cmds[-1]
            raw_redeem = encode_varint(len(cmd)) + cmd
            redeem_script = Script.parse(BytesIO(raw_redeem))
        else:
            redeem_script = None
        z = self.sig_hash(input_index, redeem_script)
        combined = tx_in.script_sig + script_pubkey
        return combined.evaluate(z)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_blocks_blocks"><a href="#chapter_blocks">Blocks</a>: Blocks</h3>
<div class="sect3">
<h4 id="_exercise_1_21">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>is_coinbase</code> method of the <code>Tx</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def is_coinbase(self):
        if len(self.tx_ins) != 1:
            return False
        first_input = self.tx_ins[0]
        if first_input.prev_tx != b'\x00' * 32:
            return False
        if first_input.prev_index != 0xffffffff:
            return False
        return True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_21">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>coinbase_height</code> method for the <code>Tx</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Tx:
...
    def coinbase_height(self):
        if not self.is_coinbase():
            return None
        element = self.tx_ins[0].script_sig.cmds[0]
        return little_endian_to_int(element)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_21">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>parse</code> method for <code>Block</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    @classmethod
    def parse(cls, s):
        version = little_endian_to_int(s.read(4))
        prev_block = s.read(32)[::-1]
        merkle_root = s.read(32)[::-1]
        timestamp = little_endian_to_int(s.read(4))
        bits = s.read(4)
        nonce = s.read(4)
        return cls(version, prev_block, merkle_root, timestamp, bits, nonce)</code></pre>
</div>
</div>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_exercise_4_21">Exercise 4</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>Block</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def serialize(self):
        result = int_to_little_endian(self.version, 4)
        result += self.prev_block[::-1]
        result += self.merkle_root[::-1]
        result += int_to_little_endian(self.timestamp, 4)
        result += self.bits
        result += self.nonce
        return result</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_19">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code>hash</code> method for <code>Block</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def hash(self):
        s = self.serialize()
        sha = hash256(s)
        return sha[::-1]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_15">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>bip9</code> method for the <code>Block</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def bip9(self):
        return self.version &gt;&gt; 29 == 0b001</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_11">Exercise 7</h4>
<div class="paragraph">
<p>Write the <code>bip91</code> method for the <code>Block</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def bip91(self):
        return self.version &gt;&gt; 4 &amp; 1 == 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_8_6">Exercise 8</h4>
<div class="paragraph">
<p>Write the <code>bip141</code> method for the <code>Block</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def bip141(self):
        return self.version &gt;&gt; 1 &amp; 1 == 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_9_6">Exercise 9</h4>
<div class="paragraph">
<p>Write the <code>bits_to_target</code> function in <em>helper.py</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def bits_to_target(bits):
    exponent = bits[-1]
    coefficient = little_endian_to_int(bits[:-1])
    return coefficient * 256**(exponent - 3)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_10_2">Exercise 10</h4>
<div class="paragraph">
<p>Write the <code>difficulty</code> method for <code>Block</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def difficulty(self):
        lowest = 0xffff * 256**(0x1d - 3)
        return lowest / self.target()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_11_2">Exercise 11</h4>
<div class="paragraph">
<p>Write the <code>check_pow</code> method for <code>Block</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def check_pow(self):
        sha = hash256(self.serialize())
        proof = little_endian_to_int(sha)
        return proof &lt; self.target()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_12_2">Exercise 12</h4>
<div class="paragraph">
<p>Calculate the new bits given the first and last blocks of this 2,016-block difficulty adjustment period:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Block 471744:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>000000203471101bbda3fe307664b3283a9ef0e97d9a38a7eacd88000000000000000000
10c8aba8479bbaa5e0848152fd3c2289ca50e1c3e58c9a4faaafbdf5803c5448ddb84559
7e8b0118e43a81d3</code></pre>
</div>
</div>
</li>
<li>
<p>Block 473759:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>02000020f1472d9db4b563c35f97c428ac903f23b7fc055d1cfc26000000000000000000
b3f449fcbe1bc4cfbcb8283a0d2c037f961a3fdf2b8bedc144973735eea707e126425859
7e8b0118e5f00474</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; from block import Block
&gt;&gt;&gt; from helper import TWO_WEEKS
&gt;&gt;&gt; from helper import target_to_bits
&gt;&gt;&gt; block1_hex = '000000203471101bbda3fe307664b3283a9ef0e97d9a38a7eacd88000000\
00000000000010c8aba8479bbaa5e0848152fd3c2289ca50e1c3e58c9a4faaafbdf5803c5448dd\
b845597e8b0118e43a81d3'
&gt;&gt;&gt; block2_hex = '02000020f1472d9db4b563c35f97c428ac903f23b7fc055d1cfc26000000\
000000000000b3f449fcbe1bc4cfbcb8283a0d2c037f961a3fdf2b8bedc144973735eea707e126\
4258597e8b0118e5f00474'
&gt;&gt;&gt; last_block = Block.parse(BytesIO(bytes.fromhex(block1_hex)))
&gt;&gt;&gt; first_block = Block.parse(BytesIO(bytes.fromhex(block2_hex)))
&gt;&gt;&gt; time_differential = last_block.timestamp - first_block.timestamp
&gt;&gt;&gt; if time_differential &gt; TWO_WEEKS * 4:
...     time_differential = TWO_WEEKS * 4
&gt;&gt;&gt; if time_differential &lt; TWO_WEEKS // 4:
...     time_differential = TWO_WEEKS // 4
&gt;&gt;&gt; new_target = last_block.target() * time_differential // TWO_WEEKS
&gt;&gt;&gt; new_bits = target_to_bits(new_target)
&gt;&gt;&gt; print(new_bits.hex())
80df6217</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_13_2">Exercise 13</h4>
<div class="paragraph">
<p>Write the <code>calculate_new_bits</code> function in <em>helper.py</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def calculate_new_bits(previous_bits, time_differential):
    if time_differential &gt; TWO_WEEKS * 4:
        time_differential = TWO_WEEKS * 4
    if time_differential &lt; TWO_WEEKS // 4:
        time_differential = TWO_WEEKS // 4
    new_target = bits_to_target(previous_bits) * time_differential // TWO_WEEKS
    return target_to_bits(new_target)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_networking_networking"><a href="#chapter_networking">Networking</a>: Networking</h3>
<div class="sect3">
<h4 id="_exercise_1_22">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>parse</code> method for <code>NetworkEnvelope</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@classmethod
def parse(cls, s, testnet=False):
    magic = s.read(4)
    if magic == b'':
        raise IOError('Connection reset!')
    if testnet:
        expected_magic = TESTNET_NETWORK_MAGIC
    else:
        expected_magic = NETWORK_MAGIC
    if magic != expected_magic:
        raise SyntaxError('magic is not right {} vs {}'.format(magic.hex(),
          expected_magic.hex()))
    command = s.read(12)
    command = command.strip(b'\x00')
    payload_length = little_endian_to_int(s.read(4))
    checksum = s.read(4)
    payload = s.read(payload_length)
    calculated_checksum = hash256(payload)[:4]
    if calculated_checksum != checksum:
        raise IOError('checksum does not match')
    return cls(command, payload, testnet=testnet)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_22">Exercise 2</h4>
<div class="paragraph">
<p>Determine what this network message is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>f9beb4d976657261636b000000000000000000005df6e0e2</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class NetworkEnvelope:
...
    &gt;&gt;&gt; from network import NetworkEnvelope
    &gt;&gt;&gt; from io import BytesIO
    &gt;&gt;&gt; message_hex = 'f9beb4d976657261636b000000000000000000005df6e0e2'
    &gt;&gt;&gt; stream = BytesIO(bytes.fromhex(message_hex))
    &gt;&gt;&gt; envelope = NetworkEnvelope.parse(stream)
    &gt;&gt;&gt; print(envelope.command)
    b'verack'
    &gt;&gt;&gt; print(envelope.payload)
    b''</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_22">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>NetworkEnvelope</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class NetworkEnvelope:
...
    def serialize(self):
        result = self.magic
        result += self.command + b'\x00' * (12 - len(self.command))
        result += int_to_little_endian(len(self.payload), 4)
        result += hash256(self.payload)[:4]
        result += self.payload
        return result</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_22">Exercise 4</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>VersionMessage</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class VersionMessage:
...
    def serialize(self):
        result = int_to_little_endian(self.version, 4)
        result += int_to_little_endian(self.services, 8)
        result += int_to_little_endian(self.timestamp, 8)
        result += int_to_little_endian(self.receiver_services, 8)
        result += b'\x00' * 10 + b'\xff\xff' + self.receiver_ip
        result += self.receiver_port.to_bytes(2, 'big')
        result += int_to_little_endian(self.sender_services, 8)
        result += b'\x00' * 10 + b'\xff\xff' + self.sender_ip
        result += self.sender_port.to_bytes(2, 'big')
        result += self.nonce
        result += encode_varint(len(self.user_agent))
        result += self.user_agent
        result += int_to_little_endian(self.latest_block, 4)
        if self.relay:
            result += b'\x01'
        else:
            result += b'\x00'
        return result</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_20">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code>handshake</code> method for <code>SimpleNode</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class SimpleNode:
...
    def handshake(self):
        version = VersionMessage()
        self.send(version)
        self.wait_for(VerAckMessage)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_16">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for <code>GetHeadersMessage</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class GetHeadersMessage:
...
    def serialize(self):
        result = int_to_little_endian(self.version, 4)
        result += encode_varint(self.num_hashes)
        result += self.start_block[::-1]
        result += self.end_block[::-1]
        return result</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_simplified_payment_verification_simplified_payment_verification"><a href="#chapter_spv">Simplified Payment Verification</a>: Simplified Payment Verification</h3>
<div class="sect3">
<h4 id="_exercise_1_23">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>merkle_parent</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def merkle_parent(hash1, hash2):
    '''Takes the binary hashes and calculates the hash256'''
    return hash256(hash1 + hash2)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_23">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>merkle_parent_level</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def merkle_parent_level(hashes):
    '''Takes a list of binary hashes and returns a list that's half
    the length'''
    if len(hashes) == 1:
        raise RuntimeError('Cannot take a parent level with only 1 item')
    if len(hashes) % 2 == 1:
        hashes.append(hashes[-1])
    parent_level = []
    for i in range(0, len(hashes), 2):
        parent = merkle_parent(hashes[i], hashes[i + 1])
        parent_level.append(parent)
    return parent_level</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_23">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>merkle_root</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def merkle_root(hashes):
    '''Takes a list of binary hashes and returns the merkle root
    '''
    current_level = hashes
    while len(current_level) &gt; 1:
        current_level = merkle_parent_level(current_level)
    return current_level[0]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_23">Exercise 4</h4>
<div class="paragraph">
<p>Write the <code>validate_merkle_root</code> method for <code>Block</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:
...
    def validate_merkle_root(self):
        hashes = [h[::-1] for h in self.tx_hashes]
        root = merkle_root(hashes)
        return root[::-1] == self.merkle_root</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_21">Exercise 5</h4>
<div class="paragraph">
<p>Create an empty Merkle Tree with 27 items and print each level.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; import math
&gt;&gt;&gt; total = 27
&gt;&gt;&gt; max_depth = math.ceil(math.log(total, 2))
&gt;&gt;&gt; merkle_tree = []
&gt;&gt;&gt; for depth in range(max_depth + 1):
...     num_items = math.ceil(total / 2**(max_depth - depth))
...     level_hashes = [None] * num_items
...     merkle_tree.append(level_hashes)
&gt;&gt;&gt; for level in merkle_tree:
...     print(level)
[None]
[None, None]
[None, None, None, None]
[None, None, None, None, None, None, None]
[None, None, None, None, None, None, None, None, None, None, None, None, None,\
 None]
[None, None, None, None, None, None, None, None, None, None, None, None, None,\
 None, None, None, None, None, None, None, None, None, None, None, None, None,\
 None]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_17">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>parse</code> method for <code>MerkleBlock</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleBlock:
...
    @classmethod
    def parse(cls, s):
        version = little_endian_to_int(s.read(4))
        prev_block = s.read(32)[::-1]
        merkle_root = s.read(32)[::-1]
        timestamp = little_endian_to_int(s.read(4))
        bits = s.read(4)
        nonce = s.read(4)
        total = little_endian_to_int(s.read(4))
        num_hashes = read_varint(s)
        hashes = []
        for _ in range(num_hashes):
            hashes.append(s.read(32)[::-1])
        flags_length = read_varint(s)
        flags = s.read(flags_length)
        return cls(version, prev_block, merkle_root, timestamp, bits,
                   nonce, total, hashes, flags)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7_12">Exercise 7</h4>
<div class="paragraph">
<p>Write the <code>is_valid</code> method for <code>MerkleBlock</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleBlock:
...
    def is_valid(self):
        flag_bits = bytes_to_bit_field(self.flags)
        hashes = [h[::-1] for h in self.hashes]
        merkle_tree = MerkleTree(self.total)
        merkle_tree.populate_tree(flag_bits, hashes)
        return merkle_tree.root()[::-1] == self.merkle_root</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bloom_filters_bloom_filters"><a href="#chapter_bloom_filters">Bloom Filters</a>: Bloom Filters</h3>
<div class="sect3">
<h4 id="_exercise_1_24">Exercise 1</h4>
<div class="paragraph">
<p>Calculate the Bloom Filter for "hello world" and "goodbye" using the hash160 hash function over a bit field of 10.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import hash160
&gt;&gt;&gt; bit_field_size = 10
&gt;&gt;&gt; bit_field = [0] * bit_field_size
&gt;&gt;&gt; for item in (b'hello world', b'goodbye'):
...     h = hash160(item)
...     bit = int.from_bytes(h, 'big') % bit_field_size
...     bit_field[bit] = 1
&gt;&gt;&gt; print(bit_field)
[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_2_24">Exercise 2</h4>
<div class="paragraph">
<p>Given a Bloom Filter with <code>size=10</code>, <code>function_count=5</code>, <code>tweak=99</code>, what are the bytes that are set after adding these items? (Use <code>bit_field_to_bytes</code> to convert to bytes.)</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>b&#8217;Hello World'</code></p>
</li>
<li>
<p><code>b&#8217;Goodbye!'</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from bloomfilter import BloomFilter, BIP37_CONSTANT
&gt;&gt;&gt; from helper import bit_field_to_bytes, murmur3
&gt;&gt;&gt; field_size = 10
&gt;&gt;&gt; function_count = 5
&gt;&gt;&gt; tweak = 99
&gt;&gt;&gt; items = (b'Hello World',  b'Goodbye!')
&gt;&gt;&gt; bit_field_size = field_size * 8
&gt;&gt;&gt; bit_field = [0] * bit_field_size
&gt;&gt;&gt; for item in items:
...     for i in range(function_count):
...         seed = i * BIP37_CONSTANT + tweak
...         h = murmur3(item, seed=seed)
...         bit = h % bit_field_size
...         bit_field[bit] = 1
&gt;&gt;&gt; print(bit_field_to_bytes(bit_field).hex())
4000600a080000010940</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_3_24">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>add</code> method for <code>BloomFilter</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class BloomFilter:
...
    def add(self, item):
        for i in range(self.function_count):
            seed = i * BIP37_CONSTANT + self.tweak
            h = murmur3(item, seed=seed)
            bit = h % (self.size * 8)
            self.bit_field[bit] = 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_4_24">Exercise 4</h4>
<div class="paragraph">
<p>Write the  <code>filterload</code> method for the <code>BloomFilter</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class BloomFilter:
...
    def filterload(self, flag=1):
        payload = encode_varint(self.size)
        payload += self.filter_bytes()
        payload += int_to_little_endian(self.function_count, 4)
        payload += int_to_little_endian(self.tweak, 4)
        payload += int_to_little_endian(flag, 1)
        return GenericMessage(b'filterload', payload)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5_22">Exercise 5</h4>
<div class="paragraph">
<p>Write the <code>serialize</code> method for the <code>GetDataMessage</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class GetDataMessage:
...
    def serialize(self):
        result = encode_varint(len(self.data))
        for data_type, identifier in self.data:
            result += int_to_little_endian(data_type, 4)
            result += identifier[::-1]
        return result</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6_18">Exercise 6</h4>
<div class="paragraph">
<p>Get the current testnet block ID, send yourself some testnet coins, find the UTXO corresponding to the testnet coins <em>without using a block explorer</em>, create a transaction using that UTXO as an input, and broadcast the tx message on the  testnet network.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; import time
&gt;&gt;&gt; from block import Block
&gt;&gt;&gt; from bloomfilter import BloomFilter
&gt;&gt;&gt; from ecc import PrivateKey
&gt;&gt;&gt; from helper import (
...     decode_base58,
...     encode_varint,
...     hash256,
...     little_endian_to_int,
...     read_varint,
... )
&gt;&gt;&gt; from merkleblock import MerkleBlock
&gt;&gt;&gt; from network import (
...     GetDataMessage,
...     GetHeadersMessage,
...     HeadersMessage,
...     NetworkEnvelope,
...     SimpleNode,
...     TX_DATA_TYPE,
...     FILTERED_BLOCK_DATA_TYPE,
... )
&gt;&gt;&gt; from script import p2pkh_script, Script
&gt;&gt;&gt; from tx import Tx, TxIn, TxOut
&gt;&gt;&gt; last_block_hex = '00000000000000a03f9432ac63813c6710bfe41712ac5ef6faab093f\
e2917636'
&gt;&gt;&gt; secret = little_endian_to_int(hash256(b'Jimmy Song'))
&gt;&gt;&gt; private_key = PrivateKey(secret=secret)
&gt;&gt;&gt; addr = private_key.point.address(testnet=True)
&gt;&gt;&gt; h160 = decode_base58(addr)
&gt;&gt;&gt; target_address = 'mwJn1YPMq7y5F8J3LkC5Hxg9PHyZ5K4cFv'
&gt;&gt;&gt; target_h160 = decode_base58(target_address)
&gt;&gt;&gt; target_script = p2pkh_script(target_h160)
&gt;&gt;&gt; fee = 5000  # fee in satoshis
&gt;&gt;&gt; # connect to testnet.programmingbitcoin.com in testnet mode
&gt;&gt;&gt; node = SimpleNode('testnet.programmingbitcoin.com', testnet=True, logging=\
False)
&gt;&gt;&gt; # Create a Bloom Filter of size 30 and 5 functions. Add a tweak.
&gt;&gt;&gt; bf = BloomFilter(30, 5, 90210)
&gt;&gt;&gt; # add the h160 to the Bloom Filter
&gt;&gt;&gt; bf.add(h160)
&gt;&gt;&gt; # complete the handshake
&gt;&gt;&gt; node.handshake()
&gt;&gt;&gt; # load the Bloom Filter with the filterload command
&gt;&gt;&gt; node.send(bf.filterload())
&gt;&gt;&gt; # set start block to last_block from above
&gt;&gt;&gt; start_block = bytes.fromhex(last_block_hex)
&gt;&gt;&gt; # send a getheaders message with the starting block
&gt;&gt;&gt; getheaders = GetHeadersMessage(start_block=start_block)
&gt;&gt;&gt; node.send(getheaders)
&gt;&gt;&gt; # wait for the headers message
&gt;&gt;&gt; headers = node.wait_for(HeadersMessage)
&gt;&gt;&gt; # store the last block as None
&gt;&gt;&gt; last_block = None
&gt;&gt;&gt; # initialize the GetDataMessage
&gt;&gt;&gt; getdata = GetDataMessage()
&gt;&gt;&gt; # loop through the blocks in the headers
&gt;&gt;&gt; for b in headers.blocks:
...     # check that the proof of work on the block is valid
...     if not b.check_pow():
...         raise RuntimeError('proof of work is invalid')
...     # check that this block's prev_block is the last block
...     if last_block is not None and b.prev_block != last_block:
...         raise RuntimeError('chain broken')
...     # add a new item to the getdata message
...     # should be FILTERED_BLOCK_DATA_TYPE and block hash
...     getdata.add_data(FILTERED_BLOCK_DATA_TYPE, b.hash())
...     # set the last block to the current hash
...     last_block = b.hash()
&gt;&gt;&gt; # send the getdata message
&gt;&gt;&gt; node.send(getdata)
&gt;&gt;&gt; # initialize prev_tx, prev_index, and prev_amount to None
&gt;&gt;&gt; prev_tx, prev_index, prev_amount = None, None, None
&gt;&gt;&gt; # loop while prev_tx is None
&gt;&gt;&gt; while prev_tx is None:
...     # wait for the merkleblock or tx commands
...     message = node.wait_for(MerkleBlock, Tx)
...     # if we have the merkleblock command
...     if message.command == b'merkleblock':
...         # check that the MerkleBlock is valid
...         if not message.is_valid():
...             raise RuntimeError('invalid merkle proof')
...     # else we have the tx command
...     else:
...         # set the tx's testnet to be True
...         message.testnet = True
...         # loop through the tx outs
...         for i, tx_out in enumerate(message.tx_outs):
...             # if our output has the same address as our address we found it
...             if tx_out.script_pubkey.address(testnet=True) == addr:
...                 # we found our utxo; set prev_tx, prev_index, and tx
...                 prev_tx = message.hash()
...                 prev_index = i
...                 prev_amount = tx_out.amount
...                 print('found: {}:{}'.format(prev_tx.hex(), prev_index))
found: b2cddd41d18d00910f88c31aa58c6816a190b8fc30fe7c665e1cd2ec60efdf3f:7
&gt;&gt;&gt; # create the TxIn
&gt;&gt;&gt; tx_in = TxIn(prev_tx, prev_index)
&gt;&gt;&gt; # calculate the output amount (previous amount minus the fee)
&gt;&gt;&gt; output_amount = prev_amount - fee
&gt;&gt;&gt; # create a new TxOut to the target script with the output amount
&gt;&gt;&gt; tx_out = TxOut(output_amount, target_script)
&gt;&gt;&gt; # create a new transaction with the one input and one output
&gt;&gt;&gt; tx_obj = Tx(1, [tx_in], [tx_out], 0, testnet=True)
&gt;&gt;&gt; # sign the only input of the transaction
&gt;&gt;&gt; print(tx_obj.sign_input(0, private_key))
True
&gt;&gt;&gt; # serialize and hex to see what it looks like
&gt;&gt;&gt; print(tx_obj.serialize().hex())
01000000013fdfef60ecd21c5e667cfe30fcb890a116688ca51ac3880f91008dd141ddcdb20700\
00006b483045022100ff77d2559261df5490ed00d231099c4b8ea867e6ccfe8e3e6d077313ed4f\
1428022033a1db8d69eb0dc376f89684d1ed1be75719888090388a16f1e8eedeb8067768012103\
dc585d46cfca73f3a75ba1ef0c5756a21c1924587480700c6eb64e3f75d22083ffffffff019334\
e500000000001976a914ad346f8eb57dee9a37981716e498120ae80e44f788ac00000000
&gt;&gt;&gt; # send this signed transaction on the network
&gt;&gt;&gt; node.send(tx_obj)
&gt;&gt;&gt; # wait a sec so this message goes through with time.sleep(1)
&gt;&gt;&gt; time.sleep(1)
&gt;&gt;&gt; # now ask for this transaction from the other node
&gt;&gt;&gt; # create a GetDataMessage
&gt;&gt;&gt; getdata = GetDataMessage()
&gt;&gt;&gt; # ask for our transaction by adding it to the message
&gt;&gt;&gt; getdata.add_data(TX_DATA_TYPE, tx_obj.hash())
&gt;&gt;&gt; # send the message
&gt;&gt;&gt; node.send(getdata)
&gt;&gt;&gt; # now wait for a Tx response
&gt;&gt;&gt; received_tx = node.wait_for(Tx)
&gt;&gt;&gt; # if the received tx has the same id as our tx, we are done!
&gt;&gt;&gt; if received_tx.id() == tx_obj.id():
...     print('success!')
success!</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.0<br>
Last updated 2020-03-09 20:30:59 +0100
</div>
</div>
</body>
</html>